<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>locust学习</title>
      <link href="/2024/12/10/locust%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/12/10/locust%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Locust学习"><a href="#Locust学习" class="headerlink" title="Locust学习"></a>Locust学习</h1><hr><p> 最近修复一个内存泄漏的bug ，低并发情况下很难复现 因此，在运维老哥的建议下，我学习了Locust 进行压力测试，以达到复现内存泄漏的问题</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>当我们做Web系统性能测试方案时，压力模拟工具的选择通常是一个绕不开的环节。对于大部分互联网公司的业务规模和测试资源投入，JMeter这个老牌开源性能测试工具能够满足大部分测试需求，它也可能是世面上书籍、博客教程丰富程度仅次于LoadRunner的性能测试工具。然而当我们的场景需要模拟的并发用户数以千为单位时，使用JMeter的成本越来越大，甚至超出我们掌握的资源。此时，我们开始寻找更低成本的方案，而Locust，为这样的方案带来了一种可能。</p><p>Locust是开源、使用Python开发、基于事件、支持分布式并且提供Web Ul进行测试执行和结果展示的性能测试工具。而它之所以能够在资源占用方面明显优于JMeter，一个关键点在于两者模拟虚拟用户的方式不同，JMeter通过线程来作为虚拟用户，而Locust借助gevent库对协程的支持，以greenlet来实现对用户的模拟，相同配置下Locust能支持的并发用户数相比JMeter可以达到一个数量级的提升。Locust使用Python代码定义测试场景，它自带-个Web Ui,用于定义用户模型，发起测试，实时测试数据，错误统计等，在最新未正式发布的v0.8a2(当前最新发布版本v0.8a1)，还提供QPS、评价响应时间等几个简单的图表。</p><h2 id="二、Locust安装"><a href="#二、Locust安装" class="headerlink" title="二、Locust安装"></a>二、Locust安装</h2><ol><li><a href="https://docs.python-guide.org/starting/installation/">安装 Python</a>（如果还没有）</li><li>安装 Locust</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install locust</span><br></pre></td></tr></table></figure><ol><li>验证安装</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ locust -V</span><br><span class="line">locust 2.31.8 from /usr/local/lib/python3.12/site-packages/locust (Python 3.12.5)</span><br></pre></td></tr></table></figure><h2 id="三、Locust测试"><a href="#三、Locust测试" class="headerlink" title="三、Locust测试"></a>三、Locust测试</h2><p>Locust 测试本质上只是一个 Python 程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> locust <span class="keyword">import</span> HttpUser, task, between</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QuickstartUser</span>(<span class="title class_ inherited__">HttpUser</span>):</span><br><span class="line">    wait_time = between(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello_world</span>(<span class="params">self</span>):</span><br><span class="line">        self.client.get(<span class="string">&quot;/hello&quot;</span>)</span><br><span class="line">        self.client.get(<span class="string">&quot;/world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task(<span class="params"><span class="number">3</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">view_items</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> item_id <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            self.client.get(<span class="string">f&quot;/item?id=<span class="subst">&#123;item_id&#125;</span>&quot;</span>, name=<span class="string">&quot;/item&quot;</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_start</span>(<span class="params">self</span>):</span><br><span class="line">        self.client.post(<span class="string">&quot;/login&quot;</span>, json=&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;password&quot;</span>:<span class="string">&quot;bar&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Locust </tag>
            
            <tag> 测试 </tag>
            
            <tag> 压力测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2024/12/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/12/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习</title>
      <link href="/2024/12/10/Docker%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/12/10/Docker%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker学习"><a href="#Docker学习" class="headerlink" title="Docker学习"></a>Docker学习</h1><p>Docker 是一个应用打包、分发、部署的工具<br>你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，<br>而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件。</p><h3 id="打包、分发、部署"><a href="#打包、分发、部署" class="headerlink" title="打包、分发、部署"></a>打包、分发、部署</h3><p><strong>打包</strong>：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包<br><strong>分发</strong>：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装<br><strong>部署</strong>：拿着“安装包”就可以一个命令运行起来你的应用，自动模拟出一摸一样的运行环境，不管是在 Windows&#x2F;Mac&#x2F;Linux。<a></a></p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/kv7rlicu.png"><a></a></p><h3 id="重要概念：镜像、容器"><a href="#重要概念：镜像、容器" class="headerlink" title="重要概念：镜像、容器"></a>重要概念：镜像、容器</h3><p><strong>镜像</strong>：可以理解为软件安装包，可以方便的进行传播和安装。<br><strong>容器</strong>：软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。</p><h2 id="Docker-命令"><a href="#Docker-命令" class="headerlink" title="Docker 命令"></a>Docker 命令</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">docker images  #查看镜像</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从服务器拉取镜像拉取镜像</span></span><br><span class="line">docker pull 镜像名       #拉取最新版本的镜像</span><br><span class="line">docker pull 镜像名:tag   #拉取镜像，指定版本</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">推送镜像到服务</span></span><br><span class="line">docker push 镜像名</span><br><span class="line">docker push 镜像名:tag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker save -o 保存的目标文件名称 镜像名 #保存镜像为一个压缩包</span><br><span class="line">docker load -i 文件名    #加载压缩包为镜像</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从Docker Hub查找/搜索镜像</span></span><br><span class="line">docker search [options] TERM      </span><br><span class="line">docker search -f STARS=9000 mysql  #搜索stars收藏数不小于10以上的mysql镜像</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除镜像。当前镜像没有被任何容器使用 才可以删除</span></span><br><span class="line">docker rmi 镜像名/镜像ID     #删除镜像 </span><br><span class="line">docker rmi -f 镜像名/镜像ID  #强制删除</span><br><span class="line">docker rmi -f 镜像名 镜像名 镜像名     #删除多个 其镜像ID或镜像用用空格隔开即可 </span><br><span class="line">docker rmi -f $(docker images -aq)  #删除全部镜像，-a 意思为显示全部, -q 意思为只显示ID</span><br><span class="line"></span><br><span class="line">docker image rm 镜像名称/镜像ID  #强制删除镜像</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">给镜像打标签【有时候根据业务需求 需要对一个镜像进行分类或版本迭代操作，此时就需要给镜像打上标签】</span></span><br><span class="line">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br></pre></td></tr></table></figure><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><p>容器保护三个状态：</p><ul><li>运行：进程正常运行</li><li>暂停：进程暂停，CPU不再运行，并不释放内存</li><li>停止：进程终止，回收进程占用的内存、CPU等资源</li></ul><p>其中：</p><ul><li>docker run：创建并运行一个容器，处于运行状态</li><li>docker pause name：让一个运行的容器暂停</li><li>docker unpause name：让一个容器从暂停状态恢复运行</li><li>docker stop name：停止一个运行的容器（杀死进程、回收内存，仅剩文件系统）</li><li>docker start name：让一个停止的容器再次运行</li><li>docker restart name：重启容器</li><li>docker rm：删除一个容器（进程、内存回收、文件系统彻底干掉）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">docker ps      #显示正在运行的容器</span><br><span class="line">docker ps -a   #-a,--all  显示全部容器，包括已停止的（默认只显示运行中的容器）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">容器怎么来？ docker run 创建并运行一个容器，处于运行状态。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--name 给要运行的容器起的名字；   -p 将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口；   -d 表示可后台运行容器 （守护式运行）。具体样例见下</span></span><br><span class="line">docker run --name containerName -p 80:80 -d nginx   </span><br><span class="line"></span><br><span class="line">docker pause 容器名/容器ID    #让一个运行的容器暂停</span><br><span class="line">docker unpause name  #让一个容器从暂停状态恢复运行</span><br><span class="line">docker stop name     #停止一个运行的容器（杀死进程、回收内存，仅剩文件系统）</span><br><span class="line">docker start name    #让一个停止的容器再次运行</span><br><span class="line">docker restart name  #重启容器</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker stop与docker <span class="built_in">kill</span>的区别：都可以终止运行中的docker容器。类似于linux中的<span class="built_in">kill</span>和<span class="built_in">kill</span> -9这两个命令，docker stop与<span class="built_in">kill</span>相似，docker <span class="built_in">kill</span>与<span class="built_in">kill</span> -9类似</span></span><br><span class="line">docker kill 容器名    #杀掉一个运行中的容器</span><br><span class="line">docker rename 容器名 新容器名  #更换容器名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除容器</span></span><br><span class="line">docker rm 容器名/容器ID            #删除容器  </span><br><span class="line">docker rm -f CONTAINER           #强制删除</span><br><span class="line">docker rm -f 容器名 容器名 容器名   #删除多个容器 空格隔开要删除的容器名或容器ID</span><br><span class="line">docker rm -f $(docker ps -aq)    #删除全部容器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker logs 容器名        #查看容器运行日志         </span><br><span class="line">docker logs -f 容器名     #持续跟踪日志</span><br><span class="line">docker logs -f --tail=20 容器名  #查看末尾多少行</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入容器执行命令，两种方式 docker <span class="built_in">exec</span> 和 docker attach，推荐docker <span class="built_in">exec</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方式一 docker <span class="built_in">exec</span>。</span></span><br><span class="line">docker exec -it 容器名/容器ID bash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方式二 docker attach，推荐使用docker <span class="built_in">exec</span></span></span><br><span class="line">docker attach 容器名/容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从容器退到自己服务器中（不能用ctrl+C）</span></span><br><span class="line">exit      #直接退出。未添加-d(持久化运行容器)时，执行此参数 容器会被关闭</span><br><span class="line">ctrl+p+q  #优雅退出。无论是否添加-d参数，执行此命令容器都不会被关闭</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置容器开机自启动</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">法一 创建容器、使用docker run命令时，添加参数--restart=always，表示该容器随docker服务启动而自动启动</span></span><br><span class="line">docker run --name mysqlLatest -p 3307:3306 --restart=always -d mysql</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">若容器已启动，希望设置开机自启动</span></span><br><span class="line">docker update 容器名/容器ID --restart=always</span><br></pre></td></tr></table></figure><h4 id="创建并运行一个容器"><a href="#创建并运行一个容器" class="headerlink" title="创建并运行一个容器"></a>创建并运行一个容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><ul><li>docker run ：创建并运行一个容器</li><li>–name : 给容器起一个名字，比如叫做mn</li><li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口。宿主机端口可以任意，只要没有被占用，容器内端口取决于应用本身</li><li>-d：后台运行容器，一般都会加</li><li>nginx：镜像名称，例如nginx，没写标签tag 默认最新版本</li></ul><p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p><p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p><p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Docker </tag>
            
            <tag> 容器化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot速成</title>
      <link href="/2024/12/10/Springboot%E9%80%9F%E6%88%90/"/>
      <url>/2024/12/10/Springboot%E9%80%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang学习</title>
      <link href="/2024/12/10/Golang%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/12/10/Golang%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Golang速成"><a href="#Golang速成" class="headerlink" title="Golang速成"></a>Golang速成</h1><hr><p>golang里的main函数必须要导入package main </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br></pre></td></tr></table></figure><h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p> 函数的{ 一定是 和函数名在同一行的，否则编译错误</p><p>golang中的表达式，加”;”，和不加 都可以，建议是不加</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.<span class="built_in">println</span>(<span class="string">&quot;hello Go!&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>*time.Second)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量的声明方式"><a href="#变量的声明方式" class="headerlink" title="变量的声明方式"></a>变量的声明方式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//方法-:声明一个变量 默认的值是0</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">fmt.Println(<span class="string">&quot;a=&quot;</span>，a)fmt.Printf(<span class="string">&quot;type ofa=&amp;T\n&quot;</span>,a)</span><br><span class="line"><span class="comment">//方法二:声明一个变量，初始化一个值var b int = 100fmt.Printin(&quot;b =&quot;,b)fmt.Printf(&quot;type of b=&amp;T\n&quot;,b)</span></span><br><span class="line"><span class="keyword">var</span> bb <span class="type">string</span> =<span class="string">&quot;abcd&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;bb =%s,type of bb = &amp;T\n&quot;</span>, bb, bb)</span><br><span class="line"><span class="comment">//方法三:在初始化的时候，可以省去数据类型，通过值自动匹配当前的变量的数据类型varc=100</span></span><br><span class="line">fmt.Println(<span class="string">&quot;c=&quot;</span>，c)fmt.Printf(<span class="string">&quot;type of c = &amp;T\n&quot;</span>, c)</span><br><span class="line"><span class="keyword">var</span> cc=<span class="string">&quot;abcd&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;cc=%s,type of cc=%T\n&quot;</span>,cc，cc)</span><br><span class="line"><span class="comment">//方法四:(常用的方法)省去var关键字，直接自动匹配e :=100fmt.Println(&quot;e=&quot;，e)fmt.Printf(&quot;type of e=&amp;T\n&quot;,e)</span></span><br><span class="line">f :=<span class="string">&quot;abcd&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;f=”，f)</span></span><br><span class="line"><span class="string">fmt.Printf(&quot;</span><span class="keyword">type</span> of f=&amp;T\n<span class="string">&quot;,f)</span></span><br><span class="line"><span class="string">            &#125;</span></span><br></pre></td></tr></table></figure><h3 id="全局变量的声明"><a href="#全局变量的声明" class="headerlink" title="全局变量的声明"></a>全局变量的声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明全局变量 方法一、方法二、方法三是可以的</span></span><br><span class="line"><span class="keyword">var</span> gA <span class="type">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> gB=<span class="number">200</span></span><br><span class="line"><span class="comment">//用方法四来声明全局变量//:= 只能够用在 函数体内来声明//gc := 200</span></span><br></pre></td></tr></table></figure><h3 id="多变量-声明"><a href="#多变量-声明" class="headerlink" title="多变量 声明"></a>多变量 声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xx，yy <span class="type">int</span>=<span class="number">100</span>，<span class="number">200</span></span><br><span class="line">fmt.Println<span class="string">&quot;xx=&quot;</span>，xx，<span class="string">&quot;，yy =&quot;</span>，yy)</span><br><span class="line"><span class="keyword">var</span> kk,ll= <span class="number">100</span>，<span class="string">&quot;Aceld&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;kk=&quot;</span>，kk,<span class="string">&quot;，l=&quot;</span>，ll)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多行的多变量声明var(vv int = 100jj bool = true</span></span><br><span class="line">fmt.Println(</span><br><span class="line">    <span class="string">&quot;vv=&quot;</span>，,<span class="string">&quot;，jj=&quot;</span>，jj</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a><strong>常量</strong></h2><blockquote><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p><p>常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p></blockquote><p>常量的定义格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br></pre></td></tr></table></figure><p>你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。</p><ul><li><p>显式类型定义：</p></li><li><pre><code class="go">const b string = &quot;abc&quot;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 隐式类型定义：</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">const b = &quot;abc&quot;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>常量还可以用作枚举：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown = <span class="number">0</span></span><br><span class="line">    Female = <span class="number">1</span></span><br><span class="line">    Male = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>数字 0、1 和 2 分别代表未知性别、女性和男性。</p><p>常量可以用len(), cap(), unsafe.Sizeof()常量计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;unsafe&quot;</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    b = <span class="built_in">len</span>(a)</span><br><span class="line">    c = unsafe.Sizeof(a)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">println</span>(a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：abc, 3, 16</p><blockquote><p>unsafe.Sizeof(a)输出的结果是16 。</p><p>字符串类型在 go 里是个结构, 包含指向底层数组的指针和长度,这两部分每部分都是 8 个字节，所以字符串类型大小为 16 个字节。</p></blockquote><h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><p>Go 函数可以返回多个值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Mahesh&quot;</span>, <span class="string">&quot;Kumar&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="init函数与import"><a href="#init函数与import" class="headerlink" title="init函数与import"></a>init函数与import</h4><p>首先我们看一个例子：init函数：</p><p>init 函数可在package main中，可在其他package中，可在同一个package中出现多次。</p><p><strong>main函数</strong></p><p>main 函数只能在package main中。</p><p><strong>执行顺序</strong></p><p>golang里面有两个保留的函数：init函数（能够应用于所有的package）和main函数（只能应用于package main）。这两个函数在定义时不能有任何的参数和返回值。</p><p>虽然一个package里面可以写任意多个init函数，但这无论是对于可读性还是以后的可维护性来说，我们都强烈建议用户在一个package中每个文件只写一个init函数。</p><p>go程序会自动调用init()和main()，所以你不需要在任何地方调用这两个函数。每个package中的init函数都是可选的，但package main就必须包含一个main函数。</p><p>程序的初始化和执行都起始于main包。</p><p>如果main包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到fmt包，但它只会被导入一次，因为没有必要导入多次）。</p><p>当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话），依次类推。</p><p>等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（如果存在的话），最后执行main函数。下图详细地解释了整个执行过程：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26269664/1650528765014-63d3d631-428e-4468-bc95-40206d8cd252.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_60,text_5YiY5Li55YawQWNlbGQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10/format,webp/resize,w_1125,limit_0" alt="31-init.png"></p><p>Lib1.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> InitLib1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;lib1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lib2.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> InitLib2</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;lib2&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    _ <span class="string">&quot;GolangTraining/InitLib1&quot;</span></span><br><span class="line">    _ <span class="string">&quot;GolangTraining/InitLib2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;libmain init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;libmian main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lib1</span><br><span class="line">lib2</span><br><span class="line">libmain init</span><br><span class="line">libmian main</span><br></pre></td></tr></table></figure><h4 id="匿名导包"><a href="#匿名导包" class="headerlink" title="匿名导包"></a>匿名导包</h4><h5 id="import-”fmt“"><a href="#import-”fmt“" class="headerlink" title="import_”fmt“"></a>import_”fmt“</h5><p>给fmt包起一个别名，匿名，无法使用当前包的方法，但是会执行当前的包内部的init()方法</p><h5 id="import-aa-“fmt”"><a href="#import-aa-“fmt”" class="headerlink" title="import aa “fmt”"></a>import aa “fmt”</h5><p>给fmt包起一个别名，aa，aa.Println()来直接调用。</p><h5 id="import-“fmt”"><a href="#import-“fmt”" class="headerlink" title="import . “fmt”"></a>import . “fmt”</h5><p>将当前fmt包中的全部方法，导入到当前本包的作用中，fmt包中的全部的方法可以直接使用API来调用，不需要 </p><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>函数如果使用参数，该变量可称为函数的形参。</p><p>形参就像定义在函数体内的局部变量。</p><p>调用函数，可以通过两种方式来传递参数：</p><h5 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h5><p>值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p><p>默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p><p>以下定义了 swap() 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义相互交换值的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   temp = x <span class="comment">/* 保存 x 的值 */</span></span><br><span class="line">   x = y    <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   y = temp <span class="comment">/* 将 temp 值赋给 y*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前 a 的值为 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前 b 的值为 : %d\n&quot;</span>, b )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 通过调用函数来交换值 */</span></span><br><span class="line">   swap(a, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后 a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后 b 的值 : %d\n&quot;</span>, b )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义相互交换值的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   temp = x <span class="comment">/* 保存 x 的值 */</span></span><br><span class="line">   x = y    <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   y = temp <span class="comment">/* 将 temp 值赋给 y*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码执行结果为：</p><p>交换前 a 的值为 : 100</p><p>交换前 b 的值为 : 200</p><p>交换后 a 的值 : 100</p><p>交换后 b 的值 : 200</p><h5 id="引用传递-指针传递"><a href="#引用传递-指针传递" class="headerlink" title="引用传递(指针传递)"></a>引用传递(指针传递)</h5><p>指针</p><p>Go 语言中指针是很容易学习的，Go 语言中使用指针可以更简单的执行一些任务。</p><p>接下来让我们来一步步学习 Go 语言指针。</p><p>我们都知道，变量是一种使用方便的占位符，用于引用计算机内存地址。</p><p>Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址。</p><p>以下实例演示了变量在内存中地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span>= <span class="number">200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前，a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前，b 的值 : %d\n&quot;</span>, b )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 swap() 函数</span></span><br><span class="line"><span class="comment">   * &amp;a 指向 a 指针，a 变量的地址</span></span><br><span class="line"><span class="comment">   * &amp;b 指向 b 指针，b 变量的地址</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   swap(&amp;a, &amp;b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后，a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后，b 的值 : %d\n&quot;</span>, b )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="type">int</span>, y *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">   temp = *x    <span class="comment">/* 保存 x 地址上的值 */</span></span><br><span class="line">   *x = *y      <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   *y = temp    <span class="comment">/* 将 temp 值赋给 y */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><blockquote><p>defer语句被用于预定对一个函数的调用。可以把这类被defer语句调用的函数称为延迟函数。</p><p>defer作用：</p><ul><li>释放占用的资源</li><li>捕捉处理异常</li><li>输出日志</li></ul><p>结果</p><p>如果一个函数中有多个defer语句，它们会以LIFO（后进先出）的顺序执行。栈</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Demo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>return  和 defer在同一个函数中 return先执行 defer后执行</p><p>因为defer 是在函数的生命周期结束后执行 类似于Python的“ __del__”函数</p><h4 id="recover错误拦截"><a href="#recover错误拦截" class="headerlink" title="recover错误拦截"></a>recover错误拦截</h4><blockquote><p>运行时panic异常一旦被引发就会导致程序崩溃。</p><p>Go语言提供了专用于“拦截”运行时panic的内建函数“recover”。它可以是当前的程序从运行时panic的状态中恢复并重新获得流程控制权。</p><p><strong>注意：</strong>recover只有在defer调用的函数中有效。</p><p><strong>示例代码</strong></p><p><strong>结果</strong></p><p>如果程序没有异常，不会打印错误信息。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recover</span> <span class="title">interface</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Demo</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//定义10个元素的数组</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line"><span class="comment">//错误拦截要在产生错误前设置</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//设置recover拦截错误信息</span></span><br><span class="line">err := <span class="built_in">recover</span>()</span><br><span class="line"><span class="comment">//产生panic异常  打印错误信息</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//根据函数参数为数组元素赋值</span></span><br><span class="line"><span class="comment">//如果i的值超过数组下标 会报错误：数组下标越界</span></span><br><span class="line">arr[i] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Demo(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//产生错误后 程序继续</span></span><br><span class="line">fmt.Println(<span class="string">&quot;程序继续执行...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片-slice"><a href="#切片-slice" class="headerlink" title="切片 slice"></a>切片 slice</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h3 id="slice（动态数组）"><a href="#slice（动态数组）" class="headerlink" title="slice（动态数组）"></a>slice（动态数组）</h3><p><strong>slice</strong></p><p>Go 语言切片是对数组的抽象。</p><p>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片<code>(&quot;动态数组&quot;)</code>,与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p><h4 id="定义切片"><a href="#定义切片" class="headerlink" title="定义切片"></a>定义切片</h4><p>你可以声明一个未指定大小的数组来定义切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>切片不需要说明长度。</p><p>或使用make()函数来创建切片:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">也可以简写为</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure><p>也可以指定容量，其中capacity为可选参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, length, capacity)</span><br></pre></td></tr></table></figure><h4 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a>切片初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :=[] <span class="type">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure><p>直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap&#x3D;len&#x3D;3</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:]</span><br></pre></td></tr></table></figure><p>初始化切片s,是数组arr的引用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:endIndex]</span><br></pre></td></tr></table></figure><p>将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:]</span><br></pre></td></tr></table></figure><p>缺省endIndex时将表示一直到arr的最后一个元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:endIndex]</span><br></pre></td></tr></table></figure><p>缺省startIndex时将表示从arr的第一个元素开始</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 := s[startIndex:endIndex]</span><br></pre></td></tr></table></figure><p>通过切片s初始化切片s1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><p>通过内置函数make()初始化切片s,[]int 标识为其元素类型为int的切片</p><h4 id="切片容量的增加"><a href="#切片容量的增加" class="headerlink" title="切片容量的增加"></a>切片容量的增加</h4><p>切片的长度和容量不同，长度表示左指针至右指针之间的距离，容量表示左指针至底层数组未尾的距离。</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20241117185646836.png" alt="image-20241117185646836"></p><p>切片扩容机制， append的时候，如果长度增加后超过容量，则容量增加2倍</p><h4 id="len-和-cap-函数"><a href="#len-和-cap-函数" class="headerlink" title="len() 和 cap() 函数"></a>len() 和 cap() 函数</h4><p>切片是可索引的，并且可以由 len() 方法获取长度。</p><p>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p><p>以下为具体实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers = <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空-nil-切片"><a href="#空-nil-切片" class="headerlink" title="空(nil)切片"></a>空(nil)切片</h4><p>一个切片在未初始化之前默认为 nil，长度为 0，实例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(numbers == <span class="literal">nil</span>)&#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;切片是空的&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切片截取"><a href="#切片截取" class="headerlink" title="切片截取"></a>切片截取</h4><p>可以通过设置下限及上限来设置截取切片*[lower-bound:upper-bound]*，实例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 创建切片 */</span></span><br><span class="line">   numbers := []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;   </span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印原始切片 */</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers ==&quot;</span>, numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引1(包含) 到索引4(不包含)*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[1:4] ==&quot;</span>, numbers[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认下限为 0*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[:3] ==&quot;</span>, numbers[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认上限为 len(s)*/</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;numbers[4:] ==&quot;</span>, numbers[<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">   printSlice(numbers1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引  0(包含) 到索引 2(不包含) */</span></span><br><span class="line">   number2 := numbers[:<span class="number">2</span>]</span><br><span class="line">   printSlice(number2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引 2(包含) 到索引 5(不包含) */</span></span><br><span class="line">   number3 := numbers[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">   printSlice(number3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="append-和-copy-函数"><a href="#append-和-copy-函数" class="headerlink" title="append() 和 copy() 函数"></a>append() 和 copy() 函数</h4><p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</p><p>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map（dict）"><a href="#map（dict）" class="headerlink" title="map（dict）"></a>map（dict）</h2><p>map和slice类似，只不过是数据结构不同，下面是map的一些声明方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//第一种声明</span></span><br><span class="line">    <span class="keyword">var</span> test1 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">    <span class="comment">//在使用map前，需要先make，make的作用就是给map分配数据空间</span></span><br><span class="line">    test1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">10</span>) </span><br><span class="line">    test1[<span class="string">&quot;one&quot;</span>] = <span class="string">&quot;php&quot;</span></span><br><span class="line">    test1[<span class="string">&quot;two&quot;</span>] = <span class="string">&quot;golang&quot;</span></span><br><span class="line">    test1[<span class="string">&quot;three&quot;</span>] = <span class="string">&quot;java&quot;</span></span><br><span class="line">    fmt.Println(test1) <span class="comment">//map[two:golang three:java one:php]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种声明</span></span><br><span class="line">    test2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">    test2[<span class="string">&quot;one&quot;</span>] = <span class="string">&quot;php&quot;</span></span><br><span class="line">    test2[<span class="string">&quot;two&quot;</span>] = <span class="string">&quot;golang&quot;</span></span><br><span class="line">    test2[<span class="string">&quot;three&quot;</span>] = <span class="string">&quot;java&quot;</span></span><br><span class="line">    fmt.Println(test2) <span class="comment">//map[one:php two:golang three:java]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种声明</span></span><br><span class="line">    test3 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;one&quot;</span> : <span class="string">&quot;php&quot;</span>,</span><br><span class="line">        <span class="string">&quot;two&quot;</span> : <span class="string">&quot;golang&quot;</span>,</span><br><span class="line">        <span class="string">&quot;three&quot;</span> : <span class="string">&quot;java&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(test3) <span class="comment">//map[one:php two:golang three:java]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    language := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">    language[<span class="string">&quot;php&quot;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    language[<span class="string">&quot;php&quot;</span>][<span class="string">&quot;id&quot;</span>] = <span class="string">&quot;1&quot;</span></span><br><span class="line">    language[<span class="string">&quot;php&quot;</span>][<span class="string">&quot;desc&quot;</span>] = <span class="string">&quot;php是世界上最美的语言&quot;</span></span><br><span class="line">    language[<span class="string">&quot;golang&quot;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    language[<span class="string">&quot;golang&quot;</span>][<span class="string">&quot;id&quot;</span>] = <span class="string">&quot;2&quot;</span></span><br><span class="line">    language[<span class="string">&quot;golang&quot;</span>][<span class="string">&quot;desc&quot;</span>] = <span class="string">&quot;golang抗并发非常good&quot;</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(language) <span class="comment">//map[php:map[id:1 desc:php是世界上最美的语言] golang:map[id:2 desc:golang抗并发非常good]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增删改查</span></span><br><span class="line">    <span class="comment">// val, key := language[&quot;php&quot;]  //查找是否有php这个子元素</span></span><br><span class="line">    <span class="comment">// if key &#123;</span></span><br><span class="line">    <span class="comment">//     fmt.Printf(&quot;%v&quot;, val)</span></span><br><span class="line">    <span class="comment">// &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//     fmt.Printf(&quot;no&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//language[&quot;php&quot;][&quot;id&quot;] = &quot;3&quot; //修改了php子元素的id值</span></span><br><span class="line">    <span class="comment">//language[&quot;php&quot;][&quot;nickname&quot;] = &quot;啪啪啪&quot; //增加php元素里的nickname值</span></span><br><span class="line">    <span class="comment">//delete(language, &quot;php&quot;)  //删除了php子元素</span></span><br><span class="line">    fmt.Println(language)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key,value := <span class="keyword">range</span> cityMap&#123;</span><br><span class="line">    fmt.<span class="built_in">println</span>(key,value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象特性"><a href="#面向对象特性" class="headerlink" title="面向对象特性"></a>面向对象特性</h2><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>假设有两个方法，一个方法的接收者是指针类型，一个方法的接收者是值类型，那么：</p><ul><li>对于值类型的变量和指针类型的变量，这两个方法有什么区别？</li><li>如果这两个方法是为了实现一个接口，那么这两个方法都可以调用吗？</li><li>如果方法是嵌入到其他结构体中的，那么上面两种情况又是怎样的？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个结构体</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> method1() &#123;</span><br><span class="line">    t.name = <span class="string">&quot;new name1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> method2() &#123;</span><br><span class="line">    t.name = <span class="string">&quot;new name2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    t := T&#123;<span class="string">&quot;old name&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;method1 调用前 &quot;</span>, t.name)</span><br><span class="line">    t.method1()</span><br><span class="line">    fmt.Println(<span class="string">&quot;method1 调用后 &quot;</span>, t.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;method2 调用前 &quot;</span>, t.name)</span><br><span class="line">    t.method2()</span><br><span class="line">    fmt.Println(<span class="string">&quot;method2 调用后 &quot;</span>, t.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">method1 调用前  old name</span><br><span class="line">method1 调用后  old name</span><br><span class="line">method2 调用前  old name</span><br><span class="line">method2 调用后  new name2</span><br></pre></td></tr></table></figure><p>当调用<code>t.method1()</code>时相当于<code>method1(t)</code>，实参和行参都是类型 T，可以接受。此时在<code>method1</code>()中的t只是参数t的值拷贝，所以<code>method1</code>()的修改影响不到main中的t变量。</p><p>当调用<code>t.method2()</code>&#x3D;&gt;<code>method2(t)</code>，这是将 T 类型传给了 *T 类型，go可能会取 t 的地址传进去：<code>method2(&amp;t)</code>。所以 <code>method1</code>() 的修改可以影响 t。</p><p>T 类型的变量这两个方法都是拥有的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="type">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是给struct Point类型定义一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span></span> Distance(q Point) <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    distanceFormP := p.Distance   <span class="comment">// 方法值(相当于C语言的函数地址,函数指针)</span></span><br><span class="line">    fmt.Println(distanceFormP(q)) <span class="comment">// &quot;5&quot;</span></span><br><span class="line">    fmt.Println(p.Distance(q))    <span class="comment">// &quot;5&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实际上distanceFormP 就绑定了 p接收器的方法Distance</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    distanceFormQ := q.Distance   <span class="comment">//</span></span><br><span class="line">    fmt.Println(distanceFormQ(p)) <span class="comment">// &quot;5&quot;</span></span><br><span class="line">    fmt.Println(q.Distance(p))    <span class="comment">// &quot;5&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实际上distanceFormQ 就绑定了 q接收器的方法Distance</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类名首字母大写，表示其他包也能够访问</p><p>如果说类的属性首字母大写，表示该属性是对外能够访问的，否则的话只能够类的内部访问</p>]]></content>
      
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis学习</title>
      <link href="/2024/09/02/redis%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/09/02/redis%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis学习"><a href="#Redis学习" class="headerlink" title="Redis学习"></a>Redis学习</h1><hr><h3 id="什么是-Redis？"><a href="#什么是-Redis？" class="headerlink" title="什么是 Redis？"></a>什么是 Redis？</h3><p>Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此<strong>读写速度非常快</strong>，常用于缓存，消息队列、分布式锁等场景Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是<strong>原子性</strong>的，因为执行命令由单线程负责的，不存在并发竞争的问题。除此之外，Redis 还支持事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布&#x2F;订阅模式，内存淘汰机制、过期删除机制等等。</p><h3 id="为什么用-Redis-作为-MySQL-的缓存？"><a href="#为什么用-Redis-作为-MySQL-的缓存？" class="headerlink" title="为什么用 Redis 作为 MySQL 的缓存？"></a>为什么用 Redis 作为 MySQL 的缓存？</h3><p>主要是因为 <strong>Redis 具备「高性能」和「高并发」两种特性</strong>。</p><p><em><strong>1、Redis 具备高性能</strong></em></p><p>假如用户第一次访问 MySQL 中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。</p><p>如果 MySQL 中的对应数据改变的之后，同步改变 Redis 缓存中相应的数据即可，不过这里会有 Redis 和 MySQL 双写一致性的问题，后面我们会提到。</p><p><em><strong>2、 Redis 具备高并发</strong></em></p><p>单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数）单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数）所以，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的，我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><h2 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h2><h3 id="Redis-数据类型以及使用场景分别是什么？"><a href="#Redis-数据类型以及使用场景分别是什么？" class="headerlink" title="Redis 数据类型以及使用场景分别是什么？"></a>Redis 数据类型以及使用场景分别是什么？</h3><p>Redis 提供了丰富的数据类型，常见的有五种数据类型<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong>。</p><p>随着 Redis 版本的更新，后面又支持了四种数据类型： <strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增</strong>。 redis的应用场景</p><ul><li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。</li><li>List 类型的应用场景：消息队列 （但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</li><li>Hash 类型：缓存对象、购物车等。</li><li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li><li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Langchain学习</title>
      <link href="/2024/07/17/Langchain%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/07/17/Langchain%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Langchain学习"><a href="#Langchain学习" class="headerlink" title="Langchain学习"></a>Langchain学习</h1><hr><p><strong>LangChain</strong>是一个框架，用于开发由大型语言模型（LLM）驱动的应用程序。</p><p>LangChain 简化了 LLM 应用程序生命周期的每个阶段：</p><ul><li><strong>开发</strong>：使用LangChain的开源<a href="https://python.langchain.com/v0.1/docs/expression_language/">构建块</a>和<a href="https://python.langchain.com/v0.1/docs/modules/">组件</a>构建应用程序。使用<a href="https://python.langchain.com/v0.1/docs/integrations/platforms/">第三方集成</a>和<a href="https://python.langchain.com/v0.1/docs/templates/">模板</a>开始运行。</li><li><strong>生产化</strong>：使用 <a href="https://python.langchain.com/v0.1/docs/langsmith/">LangSmith</a> 检查、监控和评估您的链条，以便您可以自信地持续优化和部署。</li><li><strong>部署</strong>：使用 <a href="https://python.langchain.com/v0.1/docs/langserve/">LangServe</a> 将任何链转换为 API。</li></ul><p>LLM 支持的最强大的应用程序之一是复杂的问答 （Q&amp;A） 聊天机器人。这些应用程序可以回答有关特定源信息的问题。这些应用程序使用一种称为检索增强生成 （RAG） 的技术。</p><h3 id="什么是RAG？"><a href="#什么是RAG？" class="headerlink" title="什么是RAG？"></a>什么是RAG？</h3><p>RAG 是一种使用额外数据增强 LLM 知识的技术。</p><p>LLM 可以对广泛的主题进行推理，但他们的知识仅限于他们接受培训的特定时间点之前的公共数据。如果要构建可以推理私有数据或模型截止日期后引入的数据的 AI 应用程序，则需要使用模型所需的特定信息来增强模型的知识。引入适当信息并将其插入模型提示符的过程称为检索增强生成 （RAG）。</p><p>LangChain有许多组件，旨在帮助构建Q&amp;A应用程序，以及更普遍的RAG应用程序。</p><h2 id="RAG-架构"><a href="#RAG-架构" class="headerlink" title="RAG 架构"></a>RAG 架构</h2><p>典型的 RAG 应用程序有两个主要组件：</p><p><strong>索引</strong>：用于从源引入数据并对其进行索引的管道。<em>这通常发生在离线状态。</em></p><p><strong>检索和生成</strong>：实际的 RAG 链，它在运行时接受用户查询并从索引中检索相关数据，然后将其传递给模型。</p><p>从原始数据到答案最常见的完整序列如下所示：</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ol><li><strong>加载</strong>：首先我们需要加载数据。这是使用 <a href="https://python.langchain.com/v0.1/docs/modules/data_connection/document_loaders/">DocumentLoaders</a> 完成的。</li><li><strong>拆分</strong>：<a href="https://python.langchain.com/v0.1/docs/modules/data_connection/document_transformers/">文本拆分器将</a>大块拆分为更小的块。这对于索引数据和将数据传递到模型都很有用，因为大块更难搜索，并且不适合模型的有限上下文窗口。<code>Documents</code></li><li><strong>存储</strong>：我们需要某个地方来存储和索引我们的拆分，以便以后可以搜索它们。这通常是使用 <a href="https://python.langchain.com/v0.1/docs/modules/data_connection/vectorstores/">VectorStore</a> 和 <a href="https://python.langchain.com/v0.1/docs/modules/data_connection/text_embedding/">Embeddings</a> 模型完成的。</li></ol><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20240610205424416.png" alt="image-20240610205424416"></p><h4 id="检索和生成"><a href="#检索和生成" class="headerlink" title="检索和生成"></a>检索和生成</h4><ol><li><strong>检索</strong>：给定用户输入，使用 <a href="https://python.langchain.com/v0.1/docs/modules/data_connection/retrievers/">Retriever</a> 从存储中检索相关拆分。</li><li><strong>生成</strong>：<a href="https://python.langchain.com/v0.1/docs/modules/model_io/chat/">ChatModel</a> &#x2F; <a href="https://python.langchain.com/v0.1/docs/modules/model_io/llms/">LLM</a> 使用包含问题和检索数据的提示生成答案</li></ol><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20240610205525304.png" alt="image-20240610205525304"></p><h2 id="Langchain"><a href="#Langchain" class="headerlink" title="Langchain"></a>Langchain</h2><p>LangChain应用程序的核心构建块是LLMChain。这结合了三件事：</p><ol><li>1.LLM：语言模型是这里的核心推理引擎。为了使用 LangChain，您需要了解不同类型的语言模型以及如何使用它们。</li><li>2.提示模板：这为语言模型提供说明。这控制语言模型输出的内容，因此了解如何构造提示和不同的提示策略至关重要。</li><li>3.输出解析器：这些将来自LLM的原始响应转换为更可行的格式，从而可以轻松使用下游的输出。</li></ol><p>我们将单独介绍这三个组件，然后介绍组合所有这些组件的LLMChain。</p><p>了解这些概念将为您能够使用和自定义 LangChain 应用程序做好准备。</p><p>大多数LangChain应用程序都允许您配置LLM和&#x2F;或使用的提示，因此知道如何利用这一点将是一个很大的推动因素。</p><h2 id="LLMs"><a href="#LLMs" class="headerlink" title="LLMs"></a>LLMs</h2><p>有两种类型的语言模型，在LangChain中称为：</p><ul><li>llms：这是一个语言模型，它将字符串作为输入并返回一个字符串</li><li>chat_models：这是一种语言模型，它将消息列表作为输入并返回消息</li></ul><p>LLM 的输入&#x2F;输出简单易懂 - 一个字符串。</p><p>但是chat_models呢？</p><p>那里的输入是ChatMessage的列表 ，输出是单个ChatMessage .</p><p>一个ChatMessage有两个必需的组件：</p><ul><li><blockquote><p>content ：这是消息的内容。</p></blockquote></li><li><blockquote><p>role ：这是来自的 ChatMessage 实体的角色。</p></blockquote></li></ul><p>LangChain 提供了几个对象来轻松区分不同的角色：</p><ul><li>HumanMessage ： ChatMessage来自人类&#x2F;用户。</li><li>AIMessage ： ChatMessage来自AI&#x2F;助手。</li><li>SystemMessage ：来自系统的ChatMessage 。</li><li>FunctionMessage ：来自函数调用的ChatMessage 。</li></ul><p>LangChain 为两者公开了一个标准接口，但了解这种差异以便为给定语言模型构造提示很有用。LangChain 公开的标准接口有两种方法：</p><ul><li>predict ：接受字符串，返回字符串</li><li>predict_messages ：接收消息列表，返回消息。</li></ul><p>对于这两种方法，还可以将参数作为关键字参数传入。</p><p>例如，您可以传入 temperature&#x3D;0 以根据对象的配置调整使用的温度。在运行时传入的任何值都将始终覆盖对象配置的内容。</p><h3 id="提示模板"><a href="#提示模板" class="headerlink" title="提示模板"></a>提示模板</h3><p>大多数LLM应用程序不会将用户输入直接传递到LLM。</p><p>通常，他们会将用户输入添加到称为提示模板的较大文本中，该文本为手头的特定任务提供额外的上下文。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line">prompt = PromptTemplate.from_template(<span class="string">&quot;What is a good name for a company that makes &#123;product&#125;?&quot;</span>)</span><br><span class="line">prompt.<span class="built_in">format</span>(product=<span class="string">&quot;colorful socks&quot;</span>)</span><br></pre></td></tr></table></figure><p>​    提示模板还可用于生成消息列表。在这种情况下，提示不仅包含有关内容的信息，还包含每条消息（其角色，其在列表中的位置等）在这里，最常发生的是聊天提示模板是聊天消息模板的列表。每个聊天消息模板都包含有关如何格式化该聊天消息的说明         - 它的角色，然后是它的内容。      </p><h3 id="输出解析器"><a href="#输出解析器" class="headerlink" title="输出解析器"></a>输出解析器</h3><p> 输出解析器将LLM的原始输出转换为可以在下游使用的格式。输出分析器的主要类型很少，包括：      </p><p> 从LLM转换文本-&gt;结构化信息（例如JSON）      </p><p> 将聊天消息转换为字符串 </p><p> 将调用返回的额外信息转换为字符串，而不是消息（如 OpenAI 函数调用）。 </p><h3 id="大语言模型链"><a href="#大语言模型链" class="headerlink" title="大语言模型链"></a>大语言模型链</h3><p>我们现在可以将所有这些组合成一个链。此链将获取输入变量，将这些变量传递给提示模板以创建提示，将提示传递给 LLM，然后通过（可选）输出分析器传递输出。这是捆绑模块化逻辑的便捷方法。让我们看看它的实际效果！</p><h1 id="langchain-提示词"><a href="#langchain-提示词" class="headerlink" title="langchain 提示词"></a>langchain 提示词</h1><hr><p>任何语言模型应用程序的核心元素都是…模型。<br>LangChain为您提供了与任何语言模型交互的构建块。<br>Prompts：模板化、动态选择和管理模型输入<br>语言模型：通过通用接口调用语言模型<br>输出解析器：从模型输出中提取信息</p><h2 id="Prompts"><a href="#Prompts" class="headerlink" title="Prompts"></a>Prompts</h2><p>语言模型提示是用户提供的一组指令或输入，用于指导模型的响应，帮助它理解上下文并生成相关且连贯的基于语言的输出，例如回答问题、完成句子或参与对话。<br>LangChain 提供了多个类和函数来帮助构造和使用提示。<br>提示模板：参数化模型输入<br>示例选择器：动态选择要包含在提示中的示例</p><h3 id="PromptTemplate"><a href="#PromptTemplate" class="headerlink" title="PromptTemplate"></a>PromptTemplate</h3><p>提示模板是为语言模型生成提示的预定义配方。<br>模板可能包括说明、几个镜头示例以及适合给定任务的特定上下文和问题。<br>LangChain 提供了创建和使用提示模板的工具。<br>LangChain 致力于创建与模型无关的模板，以便轻松地跨不同语言模型重用现有模板。<br>通常，语言模型希望提示是字符串或聊天消息列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> PromptTemplate <span class="comment">#用于 PromptTemplate 为字符串提示创建模板。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#默认情况下， PromptTemplate 使用 Python 的 str.format 语法进行模板化;但是可以使用其他模板语法（例如， jinja2 ）</span></span><br><span class="line">prompt_template = PromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;Tell me a &#123;adjective&#125; joke about &#123;content&#125;.&quot;</span></span><br><span class="line">)</span><br><span class="line">prompt_template.<span class="built_in">format</span>(adjective=<span class="string">&quot;funny&quot;</span>, content=<span class="string">&quot;chickens&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment">#对于其他验证，请显式指定 input_variables 。</span></span><br><span class="line"><span class="comment">#在实例化期间，这些变量将与模板字符串中存在的变量进行比较，如果不匹配，则会引发异常;</span></span><br><span class="line">invalid_prompt = PromptTemplate(</span><br><span class="line">    input_variables=[<span class="string">&quot;adjective&quot;</span>],</span><br><span class="line">    template=<span class="string">&quot;Tell me a &#123;adjective&#125; joke about &#123;content&#125;.&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>聊天模型的提示是聊天消息列表。<br>每条聊天消息都与内容相关联，以及一个名为 role 的附加参数。例如，在 OpenAI 聊天完成 API 中，聊天消息可以与 AI 助手、人员或系统角色相关联。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> ChatPromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment">#ChatPromptTemplate.from_messages 接受各种消息表示形式。</span></span><br><span class="line">template = ChatPromptTemplate.from_messages([</span><br><span class="line">    (<span class="string">&quot;system&quot;</span>, <span class="string">&quot;You are a helpful AI bot. Your name is &#123;name&#125;.&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;human&quot;</span>, <span class="string">&quot;Hello, how are you doing?&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;ai&quot;</span>, <span class="string">&quot;I&#x27;m doing well, thanks!&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;human&quot;</span>, <span class="string">&quot;&#123;user_input&#125;&quot;</span>),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">messages = template.format_messages(</span><br><span class="line">    name=<span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">    user_input=<span class="string">&quot;What is your name?&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>除了使用上一个代码块中使用的（类型、内容）的 2 元组表示形式外，<br>还可以传入 or BaseMessage 的 MessagePromptTemplate 实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> ChatPromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain.prompts.chat <span class="keyword">import</span> SystemMessage, HumanMessagePromptTemplate</span><br><span class="line"></span><br><span class="line">template = ChatPromptTemplate.from_messages(</span><br><span class="line">    [</span><br><span class="line">        SystemMessage(</span><br><span class="line">            content=(</span><br><span class="line">                <span class="string">&quot;You are a helpful assistant that re-writes the user&#x27;s text to &quot;</span></span><br><span class="line">                <span class="string">&quot;sound more upbeat.&quot;</span></span><br><span class="line">            )</span><br><span class="line">        ),</span><br><span class="line">        HumanMessagePromptTemplate.from_template(<span class="string">&quot;&#123;text&#125;&quot;</span>),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置代理</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&#x27;http_proxy&#x27;</span>] = <span class="string">&#x27;http://127.0.0.1:10809&#x27;</span></span><br><span class="line">os.environ[<span class="string">&#x27;https_proxy&#x27;</span>] = <span class="string">&#x27;http://127.0.0.1:10809&#x27;</span></span><br><span class="line"></span><br><span class="line">llm = ChatOpenAI()</span><br><span class="line">llm(template.format_messages(text=<span class="string">&#x27;i dont like eating tasty things.&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="自定义提示模板"><a href="#自定义提示模板" class="headerlink" title="自定义提示模板"></a>自定义提示模板</h3><p>LangChain 提供了一组默认的提示模板，可用于为各种任务生成提示。但是，在某些情况下，默认提示模板可能无法满足您的需求。例如，您可能希望创建一个提示模板，其中包含语言模型的特定动态说明。在这种情况下，您可以创建自定义提示模板。</p><p>我们在写提示词模板的时候，有些情况下，我们需要给出一些例子，这样可以让模型更好的理解我们的意图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.prompts.few_shot <span class="keyword">import</span> FewShotPromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain.prompts.prompt <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里我们用字典来表示一个例子，每个示例都应该是一个字典，其中键是输入变量，值是这些输入变量的值。</span></span><br><span class="line">examples = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;question&quot;</span>: <span class="string">&quot;Who lived longer, Muhammad Ali or Alan Turing?&quot;</span>,</span><br><span class="line">    <span class="string">&quot;answer&quot;</span>:</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Are follow up questions needed here: Yes.</span></span><br><span class="line"><span class="string">Follow up: How old was Muhammad Ali when he died?</span></span><br><span class="line"><span class="string">Intermediate answer: Muhammad Ali was 74 years old when he died.</span></span><br><span class="line"><span class="string">Follow up: How old was Alan Turing when he died?</span></span><br><span class="line"><span class="string">Intermediate answer: Alan Turing was 41 years old when he died.</span></span><br><span class="line"><span class="string">So the final answer is: Muhammad Ali</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;question&quot;</span>: <span class="string">&quot;When was the founder of craigslist born?&quot;</span>,</span><br><span class="line">    <span class="string">&quot;answer&quot;</span>:</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Are follow up questions needed here: Yes.</span></span><br><span class="line"><span class="string">Follow up: Who was the founder of craigslist?</span></span><br><span class="line"><span class="string">Intermediate answer: Craigslist was founded by Craig Newmark.</span></span><br><span class="line"><span class="string">Follow up: When was Craig Newmark born?</span></span><br><span class="line"><span class="string">Intermediate answer: Craig Newmark was born on December 6, 1952.</span></span><br><span class="line"><span class="string">So the final answer is: December 6, 1952</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;question&quot;</span>: <span class="string">&quot;Who was the maternal grandfather of George Washington?&quot;</span>,</span><br><span class="line">    <span class="string">&quot;answer&quot;</span>:</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Are follow up questions needed here: Yes.</span></span><br><span class="line"><span class="string">Follow up: Who was the mother of George Washington?</span></span><br><span class="line"><span class="string">Intermediate answer: The mother of George Washington was Mary Ball Washington.</span></span><br><span class="line"><span class="string">Follow up: Who was the father of Mary Ball Washington?</span></span><br><span class="line"><span class="string">Intermediate answer: The father of Mary Ball Washington was Joseph Ball.</span></span><br><span class="line"><span class="string">So the final answer is: Joseph Ball</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;question&quot;</span>: <span class="string">&quot;Are both the directors of Jaws and Casino Royale from the same country?&quot;</span>,</span><br><span class="line">    <span class="string">&quot;answer&quot;</span>:</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Are follow up questions needed here: Yes.</span></span><br><span class="line"><span class="string">Follow up: Who is the director of Jaws?</span></span><br><span class="line"><span class="string">Intermediate Answer: The director of Jaws is Steven Spielberg.</span></span><br><span class="line"><span class="string">Follow up: Where is Steven Spielberg from?</span></span><br><span class="line"><span class="string">Intermediate Answer: The United States.</span></span><br><span class="line"><span class="string">Follow up: Who is the director of Casino Royale?</span></span><br><span class="line"><span class="string">Intermediate Answer: The director of Casino Royale is Martin Campbell.</span></span><br><span class="line"><span class="string">Follow up: Where is Martin Campbell from?</span></span><br><span class="line"><span class="string">Intermediate Answer: New Zealand.</span></span><br><span class="line"><span class="string">So the final answer is: No</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="使用例子选择器"><a href="#使用例子选择器" class="headerlink" title="使用例子选择器"></a>使用例子选择器</h4><p>在上面的例子中，我们使用了一个简单的例子选择器，它只是返回全部的例子。但是，我们可以使用自定义的例子选择器来选择例子。例如，我们可以使用一个例子选择器，该选择器将选择与输入最相似的例子。</p><h3 id="MessagePromptTemplate-的类型"><a href="#MessagePromptTemplate-的类型" class="headerlink" title="MessagePromptTemplate*的类型"></a>MessagePromptTemplate*<em>的类型</em></h3><p>LangChain提供不同类型的 MessagePromptTemplate .最常用的是 AIMessagePromptTemplate 和 SystemMessagePromptTemplate HumanMessagePromptTemplate ，它们分别创建 AI 消息、系统消息和人类消息。<br>但是，如果聊天模型支持使用任意角色接收聊天消息，则可以使用 ChatMessagePromptTemplate ，它允许用户指定角色名称。</p><p>LangChain 还提供了 MessagesPlaceholder ，它使您可以完全控制在格式化过程中要呈现的消息。<br>当您不确定应为邮件提示模板使用什么角色时，或者当您希望在格式化过程中插入邮件列表时，这可能很有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> MessagesPlaceholder,HumanMessagePromptTemplate,ChatPromptTemplate</span><br><span class="line"></span><br><span class="line">human_prompt = <span class="string">&quot;Summarize our conversation so far in &#123;word_count&#125; words.&quot;</span></span><br><span class="line">human_message_template = HumanMessagePromptTemplate.from_template(human_prompt)</span><br><span class="line"></span><br><span class="line">chat_prompt = ChatPromptTemplate.from_messages([MessagesPlaceholder(variable_name=<span class="string">&quot;conversation&quot;</span>), human_message_template])</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from langchain.schema import HumanMessage,AIMessage</span><br><span class="line">human_message = HumanMessage(content=&quot;What is the best way to learn programming?&quot;)</span><br><span class="line">ai_message = AIMessage(content=&quot;&quot;&quot;\</span><br><span class="line">1. Choose a programming language: Decide on a programming language that you want to learn.</span><br><span class="line"></span><br><span class="line">2. Start with the basics: Familiarize yourself with the basic programming concepts such as variables, data types and control structures.</span><br><span class="line"></span><br><span class="line">3. Practice, practice, practice: The best way to learn programming is through hands-on experience\</span><br><span class="line">&quot;&quot;&quot;)</span><br><span class="line"></span><br><span class="line">chat_prompt.format_prompt(conversation=[human_message, ai_message], word_count=&quot;10&quot;).to_messages()</span><br></pre></td></tr></table></figure><h3 id="序列化储存提示词"><a href="#序列化储存提示词" class="headerlink" title="序列化储存提示词"></a>序列化储存提示词</h3><p>通常建议将提示存储为文件，而不是 python 代码。<br> 这可以轻松共享、存储和版本提示。<br>本笔记本介绍了如何在 LangChain 中执行此操作，演练了所有不同类型的提示和不同的序列化选项。<br>所有提示都是通过<code>load_prompt</code>函数加载的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> load_prompt</span><br><span class="line">prompt = load_prompt(<span class="string">&quot;promptstore/simple_prompt.json&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(prompt.<span class="built_in">format</span>(adjective=<span class="string">&quot;funny&quot;</span>, content=<span class="string">&quot;chickens&quot;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这显示了从 JSON 加载几个镜头示例的示例。</span></span><br><span class="line">prompt = load_prompt(<span class="string">&quot;promptstore/few_shot_prompt.json&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(prompt.<span class="built_in">format</span>(adjective=<span class="string">&quot;funny&quot;</span>))</span><br></pre></td></tr></table></figure><h1 id="大语言模型"><a href="#大语言模型" class="headerlink" title="大语言模型"></a>大语言模型</h1><p>*大型语言模型（LLM）是LangChain的核心组件。LangChain不提供自己的LLM，而是提供了一个标准接口，用于与许多不同的LLM进行交互。<br><a href="https://python.langchain.com/docs/modules/model_io/models/llms/">https://python.langchain.com/docs/modules/model_io/models/llms/</a></p><h2 id="大语言模型的跟踪令牌使用情况"><a href="#大语言模型的跟踪令牌使用情况" class="headerlink" title="大语言模型的跟踪令牌使用情况"></a>大语言模型的跟踪令牌使用情况</h2><p>LangChain提供了一个方便的方法，用于跟踪LLM的令牌使用情况。这对于调试或教育目的非常有用。<br>仅适用于OpenAI API。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.callbacks <span class="keyword">import</span> get_openai_callback</span><br><span class="line">llm = OpenAI(model_name=<span class="string">&quot;text-davinci-002&quot;</span>, n=<span class="number">2</span>, best_of=<span class="number">2</span>,cache = <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> get_openai_callback() <span class="keyword">as</span> cb:</span><br><span class="line">    result = llm(<span class="string">&quot;讲个笑话&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(cb)</span><br></pre></td></tr></table></figure><h1 id="输出解析器-1"><a href="#输出解析器-1" class="headerlink" title="输出解析器"></a>输出解析器</h1><p>语言模型输出文本。但很多时候，您可能希望获得更结构化的信息，而不仅仅是文本回复。这就是输出解析器的用武之地。<br>输出分析器是帮助构建语言模型响应的类。输出分析器必须实现两种主要方法：</p><p>“获取格式指令”：返回一个字符串的方法，其中包含有关如何格式化语言模型输出的说明。</p><p>“Parse”：一种接收字符串（假设是来自语言模型的响应）并将其解析为某种结构的方法。</p><p>然后是一个可选的：</p><p>“Parse with prompt”：一种方法，它接受一个字符串（假设是来自语言模型的响应）和一个提示（假设是生成此类响应的提示）并将其解析为某种结构。提示主要在 OutputParser 想要以某种方式重试或修复输出时提供，并且需要来自提示的信息才能执行此操作。</p><h2 id="列表解析器"><a href="#列表解析器" class="headerlink" title="列表解析器"></a>列表解析器</h2><p>当您想要返回逗号分隔项的列表时，可以使用此输出分析器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入必要的模块和类</span></span><br><span class="line"><span class="keyword">from</span> langchain.output_parsers <span class="keyword">import</span> CommaSeparatedListOutputParser</span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate, ChatPromptTemplate, HumanMessagePromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化一个解析由逗号分隔的列表的解析器</span></span><br><span class="line">output_parser = CommaSeparatedListOutputParser()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取解析器的格式指令</span></span><br><span class="line">format_instructions = output_parser.get_format_instructions()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义提示模板，用于生成关于特定主题的由逗号分隔的列表</span></span><br><span class="line">prompt = PromptTemplate(</span><br><span class="line">    template=<span class="string">&quot;List five &#123;subject&#125;.\n&#123;format_instructions&#125;&quot;</span>,</span><br><span class="line">    input_variables=[<span class="string">&quot;subject&quot;</span>],</span><br><span class="line">    partial_variables=&#123;<span class="string">&quot;format_instructions&quot;</span>: format_instructions&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化OpenAI模型，温度设置为0（生成的回答将更加确定，少有随机性）</span></span><br><span class="line">model = OpenAI(temperature=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化提示，这里的主题是“ice cream flavors”（冰淇淋口味）</span></span><br><span class="line">_<span class="built_in">input</span> = prompt.<span class="built_in">format</span>(subject=<span class="string">&quot;冰淇淋口味&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用模型生成输出</span></span><br><span class="line">output = model(_<span class="built_in">input</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用解析器解析输出</span></span><br><span class="line">output_parser.parse(output)</span><br></pre></td></tr></table></figure><h2 id="日期时间解析器"><a href="#日期时间解析器" class="headerlink" title="日期时间解析器"></a>日期时间解析器</h2><p>此输出解析器显示将LLM输出解析为日期时间格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入必要的模块和类</span></span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain.output_parsers <span class="keyword">import</span> DatetimeOutputParser</span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> LLMChain</span><br><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 初始化一个日期时间输出解析器</span></span><br><span class="line">output_parser = DatetimeOutputParser()</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 定义提示模板，用于引导模型回答用户的问题</span></span><br><span class="line">template = <span class="string">&quot;&quot;&quot;回答用户的问题:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;question&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;format_instructions&#125;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">\<span class="comment"># 使用模板创建一个提示实例</span></span><br><span class="line">prompt = PromptTemplate.from_template(</span><br><span class="line">    template,</span><br><span class="line">    partial_variables=&#123;<span class="string">&quot;format_instructions&quot;</span>: output_parser.get_format_instructions()&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 初始化一个LLMChain，它结合了提示和OpenAI模型来生成输出</span></span><br><span class="line">chain = LLMChain(prompt=prompt, llm=OpenAI())</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 运行链来获取关于特定问题的答案，这里的问题是“bitcoin是什么时候成立的？”</span></span><br><span class="line">output = chain.run(<span class="string">&quot;bitcoin是什么时候成立的？用英文格式输出时间&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="枚举解析器"><a href="#枚举解析器" class="headerlink" title="枚举解析器"></a>枚举解析器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.output_parsers.enum <span class="keyword">import</span> EnumOutputParser</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Colors</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    RED = <span class="string">&quot;red&quot;</span></span><br><span class="line">    GREEN = <span class="string">&quot;green&quot;</span></span><br><span class="line">    BLUE = <span class="string">&quot;blue&quot;</span></span><br><span class="line"></span><br><span class="line">parser = EnumOutputParser(enum=Colors)</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parser.parse(<span class="string">&quot;red&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Can handle spaces</span></span><br><span class="line">parser.parse(<span class="string">&quot; green&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># And new lines</span></span><br><span class="line">parser.parse(<span class="string">&quot;blue\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># And raises errors when appropriate</span></span><br><span class="line">parser.parse(<span class="string">&quot;yellow&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="5-4-自动修复解析器"><a href="#5-4-自动修复解析器" class="headerlink" title="5.4 自动修复解析器"></a>5.4 自动修复解析器</h2><p>​        此输出解析器包装另一个输出解析器，如果第一个输出解析器失败，它会调用另一个 LLM 以修复任何错误。      </p><p>​        但是除了抛出错误之外，我们还可以做其他事情。具体来说，我们可以将格式错误的输出以及格式化的指令传递给模型，并要求它修复它。      </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入所需的库和模块</span></span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate, ChatPromptTemplate, HumanMessagePromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.output_parsers <span class="keyword">import</span> PydanticOutputParser</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field, validator</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line">\<span class="comment"># 定义一个表示演员的数据结构，包括他们的名字和他们出演的电影列表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Actor</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    name: <span class="built_in">str</span> = Field(description=<span class="string">&quot;name of an actor&quot;</span>)                   <span class="comment"># 演员的名字</span></span><br><span class="line">    film_names: <span class="type">List</span>[<span class="built_in">str</span>] = Field(description=<span class="string">&quot;list of names of films they starred in&quot;</span>)  <span class="comment"># 他们出演的电影列表</span></span><br><span class="line"></span><br><span class="line">\<span class="comment"># 定义一个查询，用于提示生成随机演员的电影作品列表</span></span><br><span class="line">actor_query = <span class="string">&quot;Generate the filmography for a random actor.&quot;</span></span><br><span class="line"></span><br><span class="line">\<span class="comment"># 使用`Actor`模型初始化解析器</span></span><br><span class="line">parser = PydanticOutputParser(pydantic_object=Actor)</span><br><span class="line"></span><br><span class="line">\<span class="comment"># 定义一个格式错误的字符串数据</span></span><br><span class="line">misformatted = <span class="string">&quot;&#123;&#x27;name&#x27;: &#x27;Tom Hanks&#x27;, &#x27;film_names&#x27;: [&#x27;Forrest Gump&#x27;]&#125;&quot;</span></span><br><span class="line"><span class="comment"># 使用解析器尝试解析上述数据</span></span><br><span class="line">parser.parse(misformatted)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要使misformatted字符串正确格式化，您需要确保它是一个有效的JSON字符串。这意味着您应该使用双引号（&quot;）而不是单引号（&#x27;）来包围键和值。以下是修改后的</span></span><br><span class="line">parser.parse(<span class="string">&#x27;&#123;&quot;name&quot;: &quot;Tom Hanks&quot;, &quot;film_names&quot;: [&quot;Forrest Gump&quot;]&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.output_parsers <span class="keyword">import</span> OutputFixingParser</span><br><span class="line"></span><br><span class="line">new_parser = OutputFixingParser.from_llm(parser=parser, llm=ChatOpenAI())</span><br><span class="line">new_parser.parse(misformatted)</span><br></pre></td></tr></table></figure><h2 id="结构化输出解析器"><a href="#结构化输出解析器" class="headerlink" title="结构化输出解析器"></a>结构化输出解析器</h2><p>当您想要返回多个字段时，可以使用此输出分析器。</p><p>虽然 Pydantic&#x2F;JSON 解析器功能更强大，但我们最初尝试使用仅包含文本字段的数据结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入必要的模块和类</span></span><br><span class="line"><span class="keyword">from</span> langchain.output_parsers <span class="keyword">import</span> StructuredOutputParser, ResponseSchema</span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate, ChatPromptTemplate, HumanMessagePromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义响应模式，用于指导模型提供特定类型的输出</span></span><br><span class="line">response_schemas = [</span><br><span class="line">    ResponseSchema(name=<span class="string">&quot;answer&quot;</span>, description=<span class="string">&quot;回答用户的问题&quot;</span>),</span><br><span class="line">    ResponseSchema(name=<span class="string">&quot;source&quot;</span>, description=<span class="string">&quot;回答用户问题的来源，应为一个网站。&quot;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用响应模式初始化一个结构化输出解析器</span></span><br><span class="line">output_parser = StructuredOutputParser.from_response_schemas(response_schemas)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取解析器的格式指令</span></span><br><span class="line">format_instructions = output_parser.get_format_instructions()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义提示模板，用于引导模型根据用户的问题提供答案及答案的来源</span></span><br><span class="line">prompt = PromptTemplate(</span><br><span class="line">    template=<span class="string">&quot;尽可能回答用户的问题。\n&#123;format_instructions&#125;\n&#123;question&#125;&quot;</span>,</span><br><span class="line">    input_variables=[<span class="string">&quot;question&quot;</span>],</span><br><span class="line">    partial_variables=&#123;<span class="string">&quot;format_instructions&quot;</span>: format_instructions&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化OpenAI模型，温度设置为0（生成的回答将更加确定，少有随机性）</span></span><br><span class="line">model = OpenAI(temperature=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化提示，这里的问题是“法国的首都是什么？”</span></span><br><span class="line">_<span class="built_in">input</span> = prompt.format_prompt(question=<span class="string">&quot;法国的首都是什么？&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用模型生成输出</span></span><br><span class="line">output = model(_<span class="built_in">input</span>.to_string())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用解析器解析输出</span></span><br><span class="line">output_parser.parse(output)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入必要的模块和类</span></span><br><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> ChatPromptTemplate, HumanMessagePromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化聊天模型，温度设置为0（生成的回答将更加确定，少有随机性）</span></span><br><span class="line">chat_model = ChatOpenAI(temperature=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义聊天提示模板，该模板包含一系列的消息对象</span></span><br><span class="line"><span class="comment"># 这里我们只定义一个消息，该消息提示模型尽可能地回答用户的问题</span></span><br><span class="line">prompt = ChatPromptTemplate(</span><br><span class="line">    messages=[</span><br><span class="line">        HumanMessagePromptTemplate.from_template(<span class="string">&quot;尽可能回答用户的问题。\n&#123;format_instructions&#125;\n&#123;question&#125;&quot;</span>)</span><br><span class="line">    ],</span><br><span class="line">    input_variables=[<span class="string">&quot;question&quot;</span>],</span><br><span class="line">    partial_variables=&#123;<span class="string">&quot;format_instructions&quot;</span>: format_instructions&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化提示，这里的问题是“法国的首都是什么？”</span></span><br><span class="line">_<span class="built_in">input</span> = prompt.format_prompt(question=<span class="string">&quot;法国的首都是什么？&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用聊天模型生成输出</span></span><br><span class="line">output = chat_model(_<span class="built_in">input</span>.to_messages())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用解析器解析输出的内容</span></span><br><span class="line">output_parser.parse(output.content)</span><br></pre></td></tr></table></figure><h1 id="文档加载器"><a href="#文档加载器" class="headerlink" title="文档加载器"></a>文档加载器</h1><p>许多LLM应用程序需要用户特定的数据，这些数据不属于模型的训练集。</p><p>实现此目的的主要方法是通过检索增强生成 （RAG）。在此过程中，检索外部数据，然后在执行生成步骤时传递给LLM。</p><p>LangChain为RAG应用程序提供了所有构建块 - 从简单到复杂。文档的这一部分涵盖了与检索步骤相关的所有内容 - 例如数据的获取。</p><p>虽然这听起来很简单，但它可能非常复杂。这包括几个关键模块。</p><p>从许多不同的来源加载文档。LangChain提供了100多种不同的文档加载器，以及与该领域其他主要提供商的集成，如AirByte和Unstructured。</p><p>我们提供集成，从所有类型的位置（私有 s3 存储桶、公共网站）加载所有类型的文档（html、PDF、代码）。</p><p>使用文档加载器以 的形式从 Document 源加载数据。</p><p>A Document 是一段文本和关联的元数据。</p><p>例如，有用于加载简单 .txt 文件、加载任何网页的文本内容甚至加载 YouTube 视频脚本的文档加载器。</p><p>文档加载程序公开一个“加载”方法，用于将数据作为文档从配置的源加载。它们还可以选择实现“延迟加载”，以便将数据延迟加载到内存中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.document_loaders <span class="keyword">import</span> TextLoader</span><br><span class="line"></span><br><span class="line">loader = TextLoader(<span class="string">&quot;documentstore/index.md&quot;</span>)</span><br></pre></td></tr></table></figure><p>加载 CSV 数据，每个文档一行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.document_loaders.csv_loader <span class="keyword">import</span> CSVLoader</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loader = CSVLoader(file_path=<span class="string">&#x27;documentstore/index.csv&#x27;</span>)</span><br><span class="line">data = loader.load()</span><br></pre></td></tr></table></figure><p>自定义 csv 解析和加载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loader = CSVLoader(file_path=<span class="string">&#x27;documentstore/index.csv&#x27;</span>, csv_args=&#123;</span><br><span class="line">    <span class="string">&#x27;delimiter&#x27;</span>: <span class="string">&#x27;,&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;quotechar&#x27;</span>: <span class="string">&#x27;&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;fieldnames&#x27;</span>: [<span class="string">&#x27;title&#x27;</span>,<span class="string">&#x27;context&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">data = loader.load()</span><br></pre></td></tr></table></figure><p>使用该 source_column 参数为从每一行创建的文档指定源。否则 file_path 将用作从 CSV 文件创建的所有文档的源。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loader = CSVLoader(file_path=<span class="string">&#x27;documentstore/index.csv&#x27;</span>, source_column=<span class="string">&quot;context&quot;</span>)</span><br><span class="line"></span><br><span class="line">data = loader.load()</span><br></pre></td></tr></table></figure><p>更改加载程序类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.document_loaders <span class="keyword">import</span> PythonLoader</span><br><span class="line">loader = DirectoryLoader(<span class="string">&#x27;E:\\pycharmproject\\LangChainStudyProject\\LangChainStudyProject&#x27;</span>, glob=<span class="string">&quot;*.py&quot;</span>, loader_cls=PythonLoader)</span><br><span class="line">docs = loader.load()</span><br></pre></td></tr></table></figure><h1 id="文档转换器"><a href="#文档转换器" class="headerlink" title="文档转换器"></a>文档转换器</h1><p>加载文档后，您通常需要转换它们以更好地适合您的应用程序。</p><p>最简单的示例是，您可能希望将长文档拆分为可以放入模型上下文窗口的较小块。</p><p>LangChain 有许多内置的文档转换器，可以轻松拆分、组合、过滤和以其他方式操作文档。<br>当您想要处理长文本时，有必要将该文本拆分为块。</p><p>听起来很简单，但这里有很多潜在的复杂性。</p><p>理想情况下，您希望将语义相关的文本片段放在一起。</p><p>“语义相关”的含义可能取决于文本的类型。本笔记本展示了实现此目的的几种方法。</p><p>默认推荐的文本拆分器是 RecursiveCharacterTextSplitter。此文本拆分器采用字符列表。它尝试基于第一个字符的拆分来创建块，但如果任何块太大，它就会移动到下一个字符，依此类推。默认情况下，它尝试拆分的字符是 [“\n\n”, “\n”, “ “, “”]</p><h3 id="text-splitter"><a href="#text-splitter" class="headerlink" title="text_splitter"></a>text_splitter</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is a long document we can split up.</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;documentstore/state_of_the_union.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    state_of_the_union = f.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> RecursiveCharacterTextSplitter</span><br><span class="line">text_splitter = RecursiveCharacterTextSplitter(</span><br><span class="line">    <span class="comment"># Set a really small chunk size, just to show.</span></span><br><span class="line">    chunk_size = <span class="number">100</span>,</span><br><span class="line">    chunk_overlap  = <span class="number">20</span>,</span><br><span class="line">    length_function = <span class="built_in">len</span>,</span><br><span class="line">    add_start_index = <span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line">texts = text_splitter.create_documents([state_of_the_union])</span><br><span class="line"><span class="built_in">print</span>(texts[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(texts[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>下面是将元数据与文档一起传递的示例，请注意，元数据与文档一起拆分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">metadatas = [&#123;<span class="string">&quot;document&quot;</span>: <span class="number">1</span>&#125;, &#123;<span class="string">&quot;document&quot;</span>: <span class="number">2</span>&#125;]</span><br><span class="line">documents = text_splitter.create_documents([state_of_the_union, state_of_the_union], metadatas=metadatas)</span><br><span class="line"><span class="built_in">print</span>(documents[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h3 id="CodeTextSplitter"><a href="#CodeTextSplitter" class="headerlink" title="CodeTextSplitter"></a>CodeTextSplitter</h3><p>CodeTextSplitter 允许您使用多种语言支持拆分代码。导入枚举 Language 并指定语言。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> (</span><br><span class="line">    RecursiveCharacterTextSplitter,</span><br><span class="line">    Language,</span><br><span class="line">)</span><br><span class="line"><span class="comment"># Full list of support languages</span></span><br><span class="line">[e.value <span class="keyword">for</span> e <span class="keyword">in</span> Language]</span><br></pre></td></tr></table></figure><h3 id="PythonTextSplitter"><a href="#PythonTextSplitter" class="headerlink" title="PythonTextSplitter"></a>PythonTextSplitter</h3><p>下面是一个使用 PythonTextSplitter 的示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PYTHON_CODE = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def hello_world():</span></span><br><span class="line"><span class="string">    print(&quot;Hello, World!&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">\# Call the function</span></span><br><span class="line"><span class="string">hello_world()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">python_splitter = RecursiveCharacterTextSplitter.from_language(</span><br><span class="line">    language=Language.PYTHON, chunk_size=<span class="number">50</span>, chunk_overlap=<span class="number">0</span></span><br><span class="line">)</span><br><span class="line">python_docs = python_splitter.create_documents([PYTHON_CODE])</span><br><span class="line">python_docs</span><br></pre></td></tr></table></figure><h3 id="js-splitter"><a href="#js-splitter" class="headerlink" title="js_splitter"></a>js_splitter</h3><p>下面是一个使用 JS 文本拆分器的示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JS_CODE = &quot;&quot;&quot;</span><br><span class="line">function helloWorld() &#123;</span><br><span class="line">  console.log(&quot;Hello, World!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Call the function</span><br><span class="line">helloWorld();</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">js_splitter = RecursiveCharacterTextSplitter.from_language(</span><br><span class="line">    language=Language.JS, chunk_size=60, chunk_overlap=0</span><br><span class="line">)</span><br><span class="line">js_docs = js_splitter.create_documents([JS_CODE])</span><br></pre></td></tr></table></figure><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">markdown_text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># 🦜️🔗 LangChain</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">⚡ Building applications with LLMs through composability ⚡</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Quick Install</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">```bash</span></span><br><span class="line"><span class="string"># Hopefully this code block isn&#x27;t split</span></span><br><span class="line"><span class="string">pip install langchain</span></span><br><span class="line"><span class="string">```</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">As an open source project in a rapidly developing field, we are extremely open to contributions.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">md_splitter = RecursiveCharacterTextSplitter.from_language(</span><br><span class="line">    language=Language.MARKDOWN, chunk_size=<span class="number">60</span>, chunk_overlap=<span class="number">0</span></span><br><span class="line">)</span><br><span class="line">md_docs = md_splitter.create_documents([markdown_text])</span><br></pre></td></tr></table></figure><h3 id="按字符递归拆分"><a href="#按字符递归拆分" class="headerlink" title="按字符递归拆分"></a>按字符递归拆分</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from langchain.text_splitter import RecursiveCharacterTextSplitter</span><br><span class="line"># This is a long document we can split up.</span><br><span class="line">with open(&#x27;documentstore/state_of_the_union.txt&#x27;) as f:</span><br><span class="line">    state_of_the_union = f.read()</span><br><span class="line">text_splitter = RecursiveCharacterTextSplitter(</span><br><span class="line">    # Set a really small chunk size, just to show.</span><br><span class="line">    chunk_size = 100,</span><br><span class="line">    chunk_overlap  = 20,</span><br><span class="line">    length_function = len,</span><br><span class="line">)</span><br><span class="line">texts = text_splitter.create_documents([state_of_the_union])</span><br><span class="line">print(texts[0])</span><br><span class="line">print(texts[1])</span><br></pre></td></tr></table></figure><h2 id="文本嵌入模型"><a href="#文本嵌入模型" class="headerlink" title="文本嵌入模型"></a>文本嵌入模型</h2><p>嵌入类是设计用于与文本嵌入模型接口的类。有很多嵌入模型提供程序（OpenAI，Cohere，Hugging Face等） - 这个类旨在为所有它们提供一个标准接口。</p><p>嵌入创建一段文本的矢量表示形式。这很有用，因为这意味着我们可以考虑向量空间中的文本，并执行诸如语义搜索之类的操作，在其中我们寻找向量空间中最相似的文本片段。</p><p>LangChain 中的基本嵌入类公开了两种方法：一种用于嵌入文档，另一种用于嵌入查询。前者将多个文本作为输入，而后者则采用单个文本。将它们作为两个独立方法的原因是，某些嵌入提供程序对文档（要搜索）和查询（搜索查询本身）具有不同的嵌入方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.embeddings <span class="keyword">import</span> OpenAIEmbeddings</span><br><span class="line"></span><br><span class="line">embeddings_model = OpenAIEmbeddings()</span><br><span class="line"></span><br><span class="line">embeddings = embeddings_model.embed_documents(</span><br><span class="line">    [</span><br><span class="line">        <span class="string">&quot;Hi there!&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Oh, hello!&quot;</span>,</span><br><span class="line">        <span class="string">&quot;What&#x27;s your name?&quot;</span>,</span><br><span class="line">        <span class="string">&quot;My friends call me World&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">len</span>(embeddings), <span class="built_in">len</span>(embeddings[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><blockquote><p>嵌入可以存储或临时缓存，以避免需要重新计算它们。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.storage <span class="keyword">import</span> InMemoryStore, LocalFileStore</span><br><span class="line"><span class="keyword">from</span> langchain.embeddings <span class="keyword">import</span> OpenAIEmbeddings, CacheBackedEmbeddings</span><br><span class="line"><span class="keyword">from</span> langchain.document_loaders <span class="keyword">import</span> TextLoader</span><br><span class="line"><span class="keyword">from</span> langchain.embeddings.openai <span class="keyword">import</span> OpenAIEmbeddings</span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> CharacterTextSplitter</span><br><span class="line"><span class="keyword">from</span> langchain.vectorstores <span class="keyword">import</span> FAISS</span><br><span class="line">underlying_embeddings = OpenAIEmbeddings()</span><br><span class="line">fs = LocalFileStore(<span class="string">&quot;./cache/&quot;</span>)</span><br><span class="line"></span><br><span class="line">cached_embedder = CacheBackedEmbeddings.from_bytes_store(</span><br><span class="line">    underlying_embeddings, fs, namespace=underlying_embeddings.model</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>加载文档，将其拆分为块，嵌入每个块并将其加载到矢量存储中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">raw_documents = TextLoader(<span class="string">&quot;documentstore/state_of_the_union.txt&quot;</span>).load()</span><br><span class="line">text_splitter = CharacterTextSplitter(chunk_size=<span class="number">1000</span>, chunk_overlap=<span class="number">0</span>)</span><br><span class="line">documents = text_splitter.split_documents(raw_documents)</span><br><span class="line"><span class="comment">#create the vectorstore 创建矢量存储</span></span><br><span class="line">db = FAISS.from_documents(documents, cached_embedder)</span><br></pre></td></tr></table></figure><p>如果我们尝试再次创建 vectostore，它会快得多，因为它不需要重新计算任何嵌入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 = FAISS.from_documents(documents, cached_embedder)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">store = InMemoryStore()</span><br><span class="line">underlying_embeddings = OpenAIEmbeddings()</span><br><span class="line">embedder = CacheBackedEmbeddings.from_bytes_store(</span><br><span class="line">    underlying_embeddings, store, namespace=underlying_embeddings.model</span><br><span class="line">)</span><br><span class="line">embeddings = embedder.embed_documents([<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>])</span><br></pre></td></tr></table></figure><h1 id="向量数据库"><a href="#向量数据库" class="headerlink" title="向量数据库"></a>向量数据库</h1><p>存储和搜索非结构化数据的最常见方法之一是嵌入它并存储生成的嵌入向量，</p><p>然后在查询时嵌入非结构化查询并检索与嵌入查询“最相似”的嵌入向量。</p><p>矢量存储负责存储嵌入数据并为您执行矢量搜索。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.embeddings.openai <span class="keyword">import</span> OpenAIEmbeddings</span><br><span class="line"><span class="keyword">from</span> langchain.vectorstores <span class="keyword">import</span> Chroma</span><br><span class="line">\<span class="comment"># 使用向量数据库chroma，利用openai的embadding对文本进行向量化</span></span><br><span class="line">db = Chroma.from_texts(list_text, OpenAIEmbeddings())</span><br></pre></td></tr></table></figure><blockquote><p>相似性搜索</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query = <span class="string">&quot;客户的身份证号是多少&quot;</span></span><br><span class="line">docs = db.similarity_search(query)</span><br><span class="line"><span class="built_in">print</span>(docs[<span class="number">0</span>].page_content)</span><br></pre></td></tr></table></figure><p>按向量搜索相似性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">embedding_vector = OpenAIEmbeddings().embed_query(query)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;embedding_vector：<span class="subst">&#123;embedding_vector&#125;</span>&#x27;</span>)</span><br><span class="line">docs = db.similarity_search_by_vector(embedding_vector)</span><br><span class="line"><span class="built_in">print</span>(docs[<span class="number">0</span>].page_content)</span><br></pre></td></tr></table></figure><p>保存和加载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.save_local(&quot;faiss_index&quot;)</span><br><span class="line">new_db = FAISS.load_local(&quot;faiss_index&quot;, OpenAIEmbeddings())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LLM </tag>
            
            <tag> Langchain </tag>
            
            <tag> 向量数据库 </tag>
            
            <tag> RAG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>向量数据库</title>
      <link href="/2024/05/28/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2024/05/28/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="向量数据库学习"><a href="#向量数据库学习" class="headerlink" title="向量数据库学习"></a>向量数据库学习</h1><h2 id="什么是向量数据库"><a href="#什么是向量数据库" class="headerlink" title="什么是向量数据库"></a>什么是向量数据库</h2><p>向量嵌入是从机器学习模型派生的数值表示，封装了非结构化数据的语义含义。这些嵌入是通过神经网络或转换器架构分析数据中的复杂相关性而生成的，从而创建一个密集的向量空间，其中每个点都对应于数据对象的“含义”，例如文档中的单词。</p><p>这个过程将文本或其他非结构化数据转换为反映语义相似性的向量——具有相关含义的单词在这个多维空间中的位置更近，从而促进了一种称为“密集向量搜索”的搜索。这与传统的关键字搜索形成鲜明对比，后者依赖于精确匹配并使用稀疏向量。向量嵌入的发展，通常源于主要科技公司广泛训练的基础模型，允许更细致的搜索，捕捉数据的本质，超越词汇或稀疏向量搜索方法的限制。</p><p><img src="https://milvus.io/images/embedding.png" alt="What are vector embeddings?"></p><p>矢量嵌入可用于各种应用，以各种方式提高效率和准确性。以下是一些最常见的用例：</p><ul><li><h4 id="查找相似的图像、视频或音频文件"><a href="#查找相似的图像、视频或音频文件" class="headerlink" title="查找相似的图像、视频或音频文件"></a>查找相似的图像、视频或音频文件</h4><p>矢量嵌入支持通过卷积神经网络 （CNN） 分析图像、视频帧或音频片段，按内容而不仅仅是关键字搜索相似的多媒体内容。这允许进行高级搜索，例如通过比较存储在矢量数据库中的嵌入式表示，根据声音提示或通过图像查询查找视频。</p></li><li><h4 id="通过语义搜索提高搜索相关性"><a href="#通过语义搜索提高搜索相关性" class="headerlink" title="通过语义搜索提高搜索相关性"></a>通过语义搜索提高搜索相关性</h4><p>通过将内部文档嵌入到向量中，组织可以利用语义搜索来提高搜索结果的相关性。这种方法使用检索增强生成 （RAG） 的概念来理解查询背后的意图，通过 ChatGPT 等 AI 模型从公司数据中提供答案，从而减少不相关的结果和 AI 幻觉。</p></li><li><h4 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h4><p>向量嵌入通过将用户和项目表示为嵌入来衡量相似性，彻底改变了推荐系统。这种方法可以根据个人喜好提供个性化推荐，从而提高用户满意度和对在线平台的参与度。</p></li></ul><p>向量数据库是一种专用系统，旨在通过向量嵌入和数值表示来管理和检索非结构化数据，这些数据项捕获图像、音频、视频和文本内容等数据项的本质。与使用精确搜索操作处理结构化数据的传统关系数据库不同，向量数据库在使用近似最近邻 （ANN） 算法等技术进行语义相似性搜索方面表现出色。此功能对于开发跨各个领域的应用程序（包括推荐系统、聊天机器人和多媒体内容搜索工具）以及解决 AI 和 ChatGPT 等大型语言模型带来的挑战至关重要，例如理解上下文和细微差别以及 AI 幻觉。</p><p>对于传统数据库，搜索功能都是基于不同的索引方式（B Tree、倒排索引等）加上精确匹配和排序算法（BM25、TF-IDF）等实现的。本质还是基于文本的精确匹配，这种索引和搜索算法对于关键字的搜索功能非常合适，但对于语义搜索功能就非常弱。</p><p>例如，如果你搜索“小狗”，那么你只能得到带有“小狗”关键字相关的结果，而无法得到“柯基”、“金毛”等结果，因为“小狗”和“金毛”是不同的词，传统数据库无法识别它们的语义关系，所以传统的应用需要人为的将“小狗”和“金毛”等词之间打上特征标签进行关联，这样才能实现语义搜索。而如何将生成和挑选特征这个过程，也被称为 Feature Engineering (特征工程)，它是将原始数据转化成更好的表达问题本质的特征的过程。</p><p>但是如果你需要处理非结构化的数据，就会发现非结构化数据的特征数量会开始快速膨胀，例如我们处理的是图像、音频、视频等数据，这个过程就变得非常困难。例如，对于图像，可以标注颜色、形状、纹理、边缘、对象、场景等特征，但是这些特征太多了，而且很难人为的进行标注，所以我们需要一种自动化的方式来提取这些特征，而这可以通过 Vector Embedding 实现。</p><p>Vector Embedding 是由 AI 模型（例如大型语言模型 LLM）生成的，它会根据不同的算法生成高维度的向量数据，代表着数据的不同特征，这些特征代表了数据的不同维度。例如，对于文本，这些特征可能包括词汇、语法、语义、情感、情绪、主题、上下文等。对于音频，这些特征可能包括音调、节奏、音高、音色、音量、语音、音乐等。</p><p>例如对于目前来说，文本向量可以通过 OpenAI 的 text-embedding-ada-002 模型生成，图像向量可以通过 clip-vit-base-patch32 模型生成，而音频向量可以通过 wav2vec2-base-960h 模型生成。这些向量都是通过 AI 模型生成的，所以它们都是具有语义信息的。</p><p>例如我们将这句话 “Your text string goes here” 用 text-embedding-ada-002 模型进行文本 Embedding，它会生成一个 1536 维的向量，得到的结果是这样：<code>“-0.006929283495992422, -0.005336422007530928, ... -4547132266452536e-05,-0.024047505110502243”</code>，它是一个长度为 1536 的数组。这个向量就包含了这句话的所有特征，这些特征包括词汇、语法，我们可以将它存入向量数据库中，以便我们后续进行语义搜索。</p><h3 id="特征和向量"><a href="#特征和向量" class="headerlink" title="特征和向量"></a>特征和向量</h3><p>虽然向量数据库的核心在于相似性搜索(Similarity Search)，但在深入了解相似性搜索前，我们需要先详细了解一下特征和向量的概念和原理。</p><p>我们先思考一个问题？为什么我们在生活中区分不同的物品和事物？</p><p>如果从理论角度出发，这是因为我们会通过识别不同事物之间不同的特征来识别种类，例如分别不同种类的小狗，就可以通过体型大小、毛发长度、鼻子长短等特征来区分。如下面这张照片按照体型排序，可以看到体型越大的狗越靠近坐标轴右边，这样就能得到一个体型特征的一维坐标和对应的数值，从 0 到 1 的数字中得到每只狗在坐标系中的位置。</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/0bbcf925cfd9af9151f83dcb002250c8.png" alt="Snipaste_2023-07-15_20-55-09"></p><p>Snipaste_2023-07-15_20-55-09</p><p>然而单靠一个体型大小的特征并不够，像照片中哈士奇、金毛和拉布拉多的体型就非常接近，我们无法区分。所以我们会继续观察其它的特征，例如毛发的长短。</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/1db05fdd891a46367ab0a3bc4a0ff2d0.png" alt="Snipaste_2023-07-15_20-59-13"></p><p>Snipaste_2023-07-15_20-59-13</p><p>这样每只狗对应一个二维坐标点，我们就能轻易的将哈士奇、金毛和拉布拉多区分开来，如果这时仍然无法很好的区分德牧和罗威纳犬。我们就可以继续再从其它的特征区分，比如鼻子的长短，这样就能得到一个三维的坐标系和每只狗在三维坐标系中的位置。</p><p>在这种情况下，只要特征足够多，就能够将所有的狗区分开来，最后就能得到一个高维的坐标系，虽然我们想象不出高维坐标系长什么样，但是在数组中，我们只需要一直向数组中追加数字就可以了。</p><p>实际上，只要维度够多，我们就能够将所有的事物区分开来，世间万物都可以用一个多维坐标系来表示，它们都在一个高维的特征空间中对应着一个坐标点。</p><p>那这和相似性搜索 (Similarity Search) 有什么关系呢？你会发现在上面的二维坐标中，德牧和罗威纳犬的坐标就非常接近，这就意味着它们的特征也非常接近。我们都知道向量是具有大小和方向的数学结构，所以可以将这些特征用向量来表示，这样就能够通过计算向量之间的距离来判断它们的相似度，这就是<strong>相似性搜索</strong>。</p><h3 id="相似性搜索-Similarity-Search"><a href="#相似性搜索-Similarity-Search" class="headerlink" title="相似性搜索 (Similarity Search)"></a>相似性搜索 (Similarity Search)</h3><p>既然我们知道了可以通过比较向量之间的距离来判断它们的相似度，那么如何将它应用到真实的场景中呢？如果想要在一个海量的数据中找到和某个向量最相似的向量，我们需要对数据库中的每个向量进行一次比较计算，但这样的计算量是非常巨大的，所以我们需要一种高效的算法来解决这个问题。</p><p>高效的搜索算法有很多，其主要思想是通过两种方式提高搜索效率：</p><ol><li>减少向量大小——通过降维或减少表示向量值的长度。</li><li>缩小搜索范围——可以通过聚类或将向量组织成基于树形、图形结构来实现，并限制搜索范围仅在最接近的簇中进行，或者通过最相似的分支进行过滤。</li></ol><p>我们首先来介绍一下大部分算法共有的核心概念，也就是聚类。</p><h4 id="K-Means-和-Faiss"><a href="#K-Means-和-Faiss" class="headerlink" title="K-Means 和 Faiss"></a>K-Means 和 Faiss</h4><p>我们可以在保存向量数据后，先对向量数据先进行聚类。例如下图在二维坐标系中，划定了 4 个聚类中心，然后将每个向量分配到最近的聚类中心，经过聚类算法不断调整聚类中心位置，这样就可以将向量数据分成 4 个簇。每次搜索时，只需要先判断搜索向量属于哪个簇，然后再在这一个簇中进行搜索，这样就从 4 个簇的搜索范围减少到了 1 个簇，大大减少了搜索的范围。</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/95c2cf9aa89ce486f3a150d9038cf02b.png" alt="kmeans"></p><p>kmeans</p><p>常见的聚类算法有 K-Means，它可以将数据分成 k 个类别，其中 k 是预先指定的。以下是 k-means 算法的基本步骤：</p><ol><li>选择 k 个初始聚类中心。</li><li>将每个数据点分配到最近的聚类中心。</li><li>计算每个聚类的新中心。</li><li>重复步骤 2 和 3，直到聚类中心不再改变或达到最大迭代次数。</li></ol><p>但是这种搜索方式也有一些缺点，例如在搜索的时候，如果搜索的内容正好处于两个分类区域的中间，就很有可能遗漏掉最相似的向量。</p><p>现实情况中，向量的分布也不会像图中一样区分的那么明显，往往区域的边界是相邻的，就像下图 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/facebookresearch/faiss&source=article&objectId=2312534">Faiss 算法</a> 一样。</p><p>我们可以将向量想象为包含在 Voronoi 单元格中 - 当引入一个新的查询向量时，首先测量其与质心 (centroids) 之间的距离，然后将搜索范围限制在该质心所在的单元格内。</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/98db10fc4d3316e139c3c7e41c81fa01.jpg" alt="WUjl5M"></p><p>WUjl5M</p><p>那么为了解决搜索时可能存在的遗漏问题，可以将搜索范围动态调整，例如当 nprobe &#x3D; 1 时，只搜索最近的一个聚类中心，当 nprobe &#x3D; 2 时，搜索最近的两个聚类中心，根据实际业务的需求调整 nprobe 的值。</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/25f8bcf16da5b7cc8a5c1d3a8ded77f6.jpg" alt="FZadSG"></p><p>FZadSG</p><p>实际上，除了暴力搜索能完美的搜索出最相邻，所有的搜索算法只能在速度和质量还有内存上做一个权衡，这些算法也被称为近似最相邻（Approximate Nearest Neighbor）。</p><h4 id="Product-Quantization-PQ"><a href="#Product-Quantization-PQ" class="headerlink" title="Product Quantization (PQ)"></a>Product Quantization (PQ)</h4><p>在大规模数据集中，聚类算法最大的问题在于内存占用太大。这主要体现在两个方面，首先因为需要保存每个向量的坐标，而每个坐标都是一个浮点数，占用的内存就已经非常大了。除此之外，还需要维护聚类中心和每个向量的聚类中心索引，这也会占用大量的内存。</p><p>对于第一个问题，可以通过量化 (Quantization) 的方式解决，也就是常见的有损压缩。例如在内存中可以将聚类中心里面每一个向量都用聚类中心的向量来表示，并维护一个所有向量到聚类中心的码本，这样就能大大减少内存的占用。</p><p>但这仍然不能解决所有问题，在前面一个例子中，在二维坐标系中划分了聚类中心，同理，在高维坐标系中，也可以划定多个聚类中心点，不断调整和迭代，直到找到多个稳定和收敛的中心点。</p><p>但是在高维坐标系中，还会遇到维度灾难问题，具体来说，随着维度的增加，数据点之间的距离会呈指数级增长，这也就意味着，在高维坐标系中，需要更多的聚类中心点将数据点分成更小的簇，才能提高分类的质量。否者，向量和自己的聚类中心距离很远，会极大的降低搜索的速度和质量。</p><p>但如果想要维持分类和搜索质量，就需要维护数量庞大的聚类中心。随之而来会带来另一个问题，那就是聚类中心点的数量会随着维度的增加而指数级增长，这样会导致我们存储码本的数量极速增加，从而极大的增加了内存的消耗。例如一个 128 维的向量，需要维护 2^64 个聚类中心才能维持不错的量化结果，但这样的码本存储大小已经超过维护原始向量的内存大小了。</p><p>解决这个问题的方法是将向量分解为多个子向量，然后对每个子向量独立进行量化，比如将 128 维的向量分为 8 个 16 维的向量，然后在 8 个 16 维的子向量上分别进行聚类，因为 16 维的子向量大概只需要 256 个聚类中心就能得到还不错的量化结果，所以就可以将码本的大小从 2^64 降低到 8 * 256 &#x3D; 2048 个聚类中心，从而降低内存开销。</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/8b6bc8c560f7c61d0ede5b0297df8200.jpg" alt="5dAeV5"></p><p>5dAeV5</p><p>而将向量进行编码后，也将得到 8 个编码值，将它们拼起来就是该向量的最终编码值。等到使用的时候，只需要将这 8 个编码值，然后分别在 8 个子码本中搜索出对应的 16 维的向量，就能将它们使用笛卡尔积的方式组合成一个 128 维的向量，从而得到最终的搜索结果。这也就是乘积量化（Product Quantization）的原理。</p><p>使用 PQ 算法，可以显著的减少内存的开销，同时加快搜索的速度，它唯一的问题是搜索的质量会有所下降，但就像我们刚才所讲，所有算法都是在内存、速度和质量上做一个权衡。</p><h4 id="Hierarchical-Navigable-Small-Worlds-HNSW"><a href="#Hierarchical-Navigable-Small-Worlds-HNSW" class="headerlink" title="Hierarchical Navigable Small Worlds (HNSW)"></a>Hierarchical Navigable Small Worlds (HNSW)</h4><p>除了聚类以外，也可以通过构建树或者构建图的方式来实现近似最近邻搜索。这种方法的基本思想是每次将向量加到数据库中的时候，就先找到与它最相邻的向量，然后将它们连接起来，这样就构成了一个图。当需要搜索的时候，就可以从图中的某个节点开始，不断的进行最相邻搜索和最短路径计算，直到找到最相似的向量。</p><p>这种算法能保证搜索的质量，但是如果图中所以的节点都以最短的路径相连，如图中最下面的一层，那么在搜索的时候，就同样需要遍历所有的节点。</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/7699b48e89f04c697cc402d27f7ed362.jpg" alt="GD7ufK"></p><p>GD7ufK</p><p>解决这个问题的思路与常见的跳表算法相似，如下图要搜索跳表，从最高层开始，沿着具有最长“跳过”的边向右移动。如果发现当前节点的值大于要搜索的值-我们知道已经超过了目标，因此我们会在下一级中向前一个节点。</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/1718c5fe65b1691ef463e102f307c737.jpg" alt="wOu6JL"></p><p>wOu6JL</p><p>HNSW 继承了相同的分层格式，最高层具有更长的边缘（用于快速搜索），而较低层具有较短的边缘（用于准确搜索）。</p><p>具体来说，可以将图分为多层，每一层都是一个小世界，图中的节点都是相互连接的。而且每一层的节点都会连接到上一层的节点，当需要搜索的时候，就可以从第一层开始，因为第一层的节点之间距离很长，可以减少搜索的时间，然后再逐层向下搜索，又因为最下层相似节点之间相互关联，所以可以保证搜索的质量，能够找到最相似的向量。</p><p>如果你对跳表和 HNSW 感兴趣，可以看看<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.youtube.com/watch?v=QvKMwLjdK-s&t=168s&ab_channel=JamesBriggs&source=article&objectId=2312534">这个视频</a>。</p><p>HNSW 算法是一种经典的空间换时间的算法，它的搜索质量和搜索速度都比较高，但是它的内存开销也比较大，因为不仅需要将所有的向量都存储在内存中。还需要维护一个图的结构，也同样需要存储。所以这类算法需要根据实际的场景来选择。</p><h4 id="Locality-Sensitive-Hashing-LSH"><a href="#Locality-Sensitive-Hashing-LSH" class="headerlink" title="Locality Sensitive Hashing (LSH)"></a>Locality Sensitive Hashing (LSH)</h4><p>局部敏感哈希（Locality Sensitive Hashing）也是一种使用近似最近邻搜索的索引技术。它的特点是快速，同时仍然提供一个近似、非穷举的结果。LSH 使用一组哈希函数将相似向量映射到“桶”中，从而使相似向量具有相同的哈希值。这样，就可以通过比较哈希值来判断向量之间的相似度。</p><p>通常，我们设计的哈希算法都是力求减少哈希碰撞的次数，因为哈希函数的搜索时间复杂度是 O(1)，但是，如果存在哈希碰撞，即两个不同的关键字被映射到同一个桶中，那么就需要使用链表等数据结构来解决冲突。在这种情况下，搜索的时间复杂度通常是 O(n)，其中n是链表的长度。所以为了提高哈希函数的搜索的效率，通常会将哈希函数的碰撞概率尽可能的小。</p><p>但是在向量搜索中，我们的目的是为了找到相似的向量，所以可以专门设计一种哈希函数，使得哈希碰撞的概率尽可能高，并且位置越近或者越相似的向量越容易碰撞，这样相似的向量就会被映射到同一个桶中。</p><p>等搜索特定向量时，为了找到给定查询向量的最近邻居，使用相同的哈希函数将类似向量“分桶”到哈希表中。查询向量被散列到特定表中，然后与该表中的其他向量进行比较以找到最接近的匹配项。这种方法比搜索整个数据集要快得多，因为每个哈希表桶中的向量远少于整个空间中的向量数。</p><p>那么这个哈希函数应该如何设计呢？为了大家更好理解，我们先从二维坐标系解释，如下所图示，在二维坐标系中可以通过随机生成一条直线，将二维坐标系划分为两个区域，这样就可以通过判断向量是否在直线的同一边来判断它们是否相似。例如下图通过随机生成 4 条直线，这样就可以通过 4 个二进制数来表示一个向量的位置，例如 A 和 B 表示向量在同一个区域。</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/093d2ed64d3240afa66a867d9d079d42.png" alt="lsh1"></p><p>lsh1</p><p>这个原理很简单，如果两个向量的距离很近，那么它们在直线的同一边的概率就会很高，例如直线穿过 AC 的概率就远大于直线穿过 AB 的概率。所以 AB 在同一侧的概率就远大于 AC 在同一侧的概率。</p><p>当搜索一个向量时，将这个向量再次进行哈希函数计算，得到相同桶中的向量，然后再通过暴力搜索的方式，找到最接近的向量。如下图如果再搜索一个向量经过了哈希函数，得到了 0110 的值，就会直接找到和它同一个桶中相似的向量 D。从而大大减少了搜索的时间。</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/8ea87cb3dfc138d5c5b939f4b2ba6a55.png" alt="lsh"></p><p>lsh</p><p>关于更多 LSH 算法的细节，可以参考<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.pinecone.io/learn/series/faiss/locality-sensitive-hashing/&source=article&objectId=2312534">这篇博客</a>。</p><h5 id="Random-Projection-for-LSH-随机投影"><a href="#Random-Projection-for-LSH-随机投影" class="headerlink" title="Random Projection for LSH 随机投影"></a>Random Projection for LSH 随机投影</h5><p>如果在二维坐标系可以通过随机生成的直线区分相似性，那么同理，在三维坐标系中，就可以通过随机生成一个平面，将三维坐标系划分为两个区域。在多维坐标系中，同样可以通过随机生成一个超平面，将多维坐标系划分为两个区域，从而区分相似性。</p><p>但是在高维空间中，数据点之间的距离往往非常稀疏，数据点之间的距离会随着维度的增加呈指数级增长。导致计算出来的桶非常多，最极端的情况是每个桶中就一个向量，并且计算速度非常慢。所以实际上在实现 LSH 算法的时候，会考虑使用随机投影的方式，将高维空间的数据点投影到低维空间，从而减少计算的时间和提高查询的质量。</p><p>随机投影背后的基本思想是使用随机投影矩阵将高维向量投影到低维空间中。创建一个由随机数构成的矩阵，其大小将是所需的目标低维值。然后，计算输入向量和矩阵之间的点积，得到一个被投影的矩阵，它比原始向量具有更少的维度但仍保留了它们之间的相似性。</p><p>当我们查询时，使用相同的投影矩阵将查询向量投影到低维空间。然后，将投影的查询向量与数据库中的投影向量进行比较，以找到最近邻居。由于数据的维数降低了，搜索过程比在整个高维空间中搜索要快得多。</p><p>其基本步骤是：</p><ol><li>从高维空间中随机选择一个超平面，将数据点投影到该超平面上。</li><li>重复步骤 1，选择多个超平面，将数据点投影到多个超平面上。</li><li>将多个超平面的投影结果组合成一个向量，作为低维空间中的表示。</li><li>使用哈希函数将低维空间中的向量映射到哈希桶中。</li></ol><p>同样，随机投影也是一种近似方法，并且投影质量取决于投影矩阵。通常情况下，随机性越大的投影矩阵，其映射质量就越好。但是生成真正随机的投影矩阵可能会计算成本很高，特别是对于大型数据集来说。关于更多 RP for LSH 算法的细节，可以参考<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.pinecone.io/learn/series/faiss/locality-sensitive-hashing-random-projection/&source=article&objectId=2312534">这篇博客</a>。</p><h3 id="相似性测量-Similarity-Measurement"><a href="#相似性测量-Similarity-Measurement" class="headerlink" title="相似性测量 (Similarity Measurement)"></a>相似性测量 (Similarity Measurement)</h3><p>上面我们讨论了向量数据库的不同搜索算法，但是还没有讨论如何衡量相似性。在相似性搜索中，需要计算两个向量之间的距离，然后根据距离来判断它们的相似度。</p><p>而如何计算向量在高维空间的距离呢？有三种常见的向量相似度算法：欧几里德距离、余弦相似度和点积相似度。</p><h4 id="欧几里得距离（Euclidean-Distance）"><a href="#欧几里得距离（Euclidean-Distance）" class="headerlink" title="欧几里得距离（Euclidean Distance）"></a>欧几里得距离（Euclidean Distance）</h4><p>欧几里得距离是指两个向量之间的距离，它的计算公式为：</p><p>$$<br>p &#x3D; \sqrt{(x_2-x_1)^2+(y_2-y_11)^2+(z_2-z_1)^2}<br>$$</p><p>$$<br>|X| &#x3D; \sqrt{x_2^2 + y_2^2 + z_2^2}<br>$$<br>欧几里得距离算法的优点是可以反映向量的绝对距离，适用于需要考虑向量长度的相似性计算。例如推荐系统中，需要根据用户的历史行为来推荐相似的商品，这时就需要考虑用户的历史行为的数量，而不仅仅是用户的历史行为的相似度。</p><h3 id="余弦相似度（Cosine-Similarity）"><a href="#余弦相似度（Cosine-Similarity）" class="headerlink" title="余弦相似度（Cosine Similarity）"></a>余弦相似度（Cosine Similarity）</h3><p>余弦相似度是指两个向量之间的夹角余弦值，它的计算公式为：<br>$$<br>\cos(\theta) &#x3D; \frac{\mathbf{A} \cdot \mathbf{B}}{|\mathbf{A}| |\mathbf{B}|}<br>$$</p><p>其中，$\mathbf{A}$ 和 $\mathbf{B}$ 分别表示两个向量，$\cdot$ 表示向量的点积，$|\mathbf{A}|$ 和 $|\mathbf{B}|$ 分别表示两个向量的模长。</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/fHLAfz.jpg" alt="fHLAfz"></p><p>余弦相似度对向量的长度不敏感，只关注向量的方向，因此适用于高维向量的相似性计算。例如语义搜索和文档分类。</p><h3 id="点积相似度-Dot-product-Similarity"><a href="#点积相似度-Dot-product-Similarity" class="headerlink" title="点积相似度 (Dot product Similarity)"></a>点积相似度 (Dot product Similarity)</h3><p>向量的点积相似度是指两个向量之间的点积值，它的计算公式为：<br>$$<br>\mathbf{A} \cdot \mathbf{B} &#x3D; \sum_{i&#x3D;1}^{n}A_i B_i<br>$$<br>其中，$\mathbf{A}$ 和 $\mathbf{B}$ 分别表示两个向量，$n$ 表示向量的维度。</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/kyA3AN.jpg" alt="kyA3AN"></p><h3 id="过滤-Filtering"><a href="#过滤-Filtering" class="headerlink" title="过滤 (Filtering)"></a>过滤 (Filtering)</h3><p>在实际的业务场景中，往往不需要在整个向量数据库中进行相似性搜索，而是通过部分的业务字段进行过滤再进行查询。所以存储在数据库的向量往往还需要包含元数据，例如用户 ID、文档 ID 等信息。这样就可以在搜索的时候，根据元数据来过滤搜索结果，从而得到最终的结果。</p><p>为此，向量数据库通常维护两个索引：一个是向量索引，另一个是元数据索引。然后，在进行相似性搜索本身之前或之后执行元数据过滤，但无论哪种情况下，都存在导致查询过程变慢的困难。</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/b0bbe54cc8f2e202bba43fa4f5c5c065.jpg" alt="VwZxFW"></p><p>VwZxFW</p><p>过滤过程可以在向量搜索本身之前或之后执行，但每种方法都有自己的挑战，可能会影响查询性能：</p><ul><li>Pre-filtering：在向量搜索之前进行元数据过滤。虽然这可以帮助减少搜索空间，但也可能导致系统忽略与元数据筛选标准不匹配的相关结果。</li><li>Post-filtering：在向量搜索完成后进行元数据过滤。这可以确保考虑所有相关结果，在搜索完成后将不相关的结果进行筛选。</li></ul><p>为了优化过滤流程，向量数据库使用各种技术，例如利用先进的索引方法来处理元数据或使用并行处理来加速过滤任务。平衡搜索性能和筛选精度之间的权衡对于提供高效且相关的向量数据库查询结果至关重要。</p><h3 id="向量数据库选型"><a href="#向量数据库选型" class="headerlink" title="向量数据库选型"></a>向量数据库选型</h3><p>笔者在本文中，花费了大量的笔墨来介绍向量数据库的相似性搜索算法的原理和实现，相似性搜索算法固然是一个向量数据库的核心和关键点，但是在实际的业务场景中，往往还需要考虑其它的因素，例如向量数据库的可用性、扩展性、安全性等，还有代码是否开源、社区是否活跃等等。</p><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>一个成熟的向量数据库，往往需要支持分布式部署，这样才能满足大规模数据的存储和查询。数据拥有的越多，需要节点就越多，出现的错误和故障也就越多，所以分布式的向量数据库需要具备高可用性和容错性。</p><p>数据库的高可用性和容错性，往往需要实现分片和复制能力，在传统的数据库中，往往通过数据的主键或者根据业务需求进行分片，但是在分布式的向量数据库中，就需要考虑根据向量的相似性进行分区，以便查询的时候能够保证结果的质量和速度。</p><p>其它类似复制节点数据的一致性、数据的安全性等等，都是分布式向量数据库需要考虑的因素。</p><h4 id="访问控制和备份"><a href="#访问控制和备份" class="headerlink" title="访问控制和备份"></a>访问控制和备份</h4><p>除此之外，访问控制设计的是否充足，例如当组织和业务快速发展时，是否能够快速的添加新的用户和权限控制，是否能够快速的添加新的节点，审计日志是否完善等等，都是需要考虑的因素。</p><p>另外，数据库的监控和备份也是一个重要的因素，当数据出现故障时，能够快速的定位问题和恢复数据，是一个成熟的向量数据库必须要考虑的因素。</p><h4 id="API-SDK"><a href="#API-SDK" class="headerlink" title="API &amp; SDK"></a>API &amp; SDK</h4><p>对比上面的因素选择，API &amp; SDK 可能是往往被忽略的因素，但是在实际的业务场景中，API &amp; SDK 往往是开发者最关心的因素。因为 API &amp; SDK 的设计直接影响了开发者的开发效率和使用体验。一个优秀良好的 API &amp; SDK 设计，往往能够适应需求的不同变化，向量数据库是一个新的领域，在如今大部分人不太清楚这方面需求的当下，这一点容易被人忽视。</p><h4 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h4><p>截至目前，汇总到目前的向量数据库有以下几种选择：</p><table><thead><tr><th align="left">向量数据库</th><th align="left">URL</th><th align="left">GitHub Star</th><th align="left">Language</th><th align="left">Cloud</th></tr></thead><tbody><tr><td align="left">chroma</td><td align="left"><a href="https://github.com/chroma-core/chroma">https://github.com/chroma-core/chroma</a></td><td align="left">7.4K</td><td align="left">Python</td><td align="left">❌</td></tr><tr><td align="left">milvus</td><td align="left"><a href="https://github.com/milvus-io/milvus">https://github.com/milvus-io/milvus</a></td><td align="left">21.5K</td><td align="left">Go&#x2F;Python&#x2F;C++</td><td align="left">✅</td></tr><tr><td align="left">pinecone</td><td align="left"><a href="https://www.pinecone.io/">https://www.pinecone.io/</a></td><td align="left">❌</td><td align="left">❌</td><td align="left">✅</td></tr><tr><td align="left">qdrant</td><td align="left"><a href="https://github.com/qdrant/qdrant">https://github.com/qdrant/qdrant</a></td><td align="left">11.8K</td><td align="left">Rust</td><td align="left">✅</td></tr><tr><td align="left">typesense</td><td align="left"><a href="https://github.com/typesense/typesense">https://github.com/typesense/typesense</a></td><td align="left">12.9K</td><td align="left">C++</td><td align="left">❌</td></tr><tr><td align="left">weaviate</td><td align="left"><a href="https://github.com/weaviate/weaviate">https://github.com/weaviate/weaviate</a></td><td align="left">6.9K</td><td align="left">Go</td><td align="left">✅</td></tr></tbody></table><h4 id="传统数据的扩展"><a href="#传统数据的扩展" class="headerlink" title="传统数据的扩展"></a>传统数据的扩展</h4><p>除了选择专业的向量数据库，使用传统数据库进行扩展也是一种方法。类似 Redis 除了传统的 Key Value 数据库用途外，Redis 还提供了 Redis Modules，这是一种通过新功能、命令和数据类型扩展 Redis 的方式。例如使用 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://redis.io/docs/interact/search-and-query/&source=article&objectId=2312534">RediSearch</a> 模块来扩展向量搜索的功能。</p><p>同理的还有 PostgreSQL 的扩展，PostgreSQL 提供使用 extension 的方式来扩展数据库的功能，例如 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/pgvector/pgvector&source=article&objectId=2312534">pgvector</a> 来开启向量搜索的功能。它不仅支持精确和相似性搜索，还支持余弦相似度等相似性测量算法。最重要的是，它是附加在 PostgreSQL 上的，因此可以利用 PostgreSQL 的所有功能，例如 ACID 事务、并发控制、备份和恢复等。还拥有所有的 PostgreSQL 客户端库，因此可以使用任何语言的 PostgreSQL 客户端来访问它。可以减少开发者的学习成本和服务的维护成本。</p><p>像笔者的开源项目 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/guangzhengli/ChatFiles&source=article&objectId=2312534">ChatFiles</a> 和 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/guangzhengli/vectorhub&source=article&objectId=2312534">VectorHub</a> 目前就暂时使用 pgvector 来实现向量搜索以实现 GPT 文档问答，基于 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://supabase.com/blog/openai-embeddings-postgres-vector&source=article&objectId=2312534">Supabase 提供的 PostgreSQL + pgvector</a> 服务完成。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 聚类 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka学习</title>
      <link href="/2024/05/21/Kafka%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/05/21/Kafka%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka学习"><a href="#Kafka学习" class="headerlink" title="Kafka学习"></a>Kafka学习</h1><hr><h2 id="一、Kafka-简介"><a href="#一、Kafka-简介" class="headerlink" title="一、Kafka 简介"></a><strong>一、Kafka 简介</strong></h2><p><strong>Kafka</strong> 是一个消息系统，原本开发自 LinkedIn，用作 LinkedIn 的活动流（Activity Stream）和运营数据处理管道（Pipeline）的基础。现在它已被<a href="https://link.zhihu.com/?target=https://cwiki.apache.org/confluence/display/KAFKA/Powered+By">多家不同类型的公司</a> 作为多种类型的数据管道和消息系统使用。</p><p>Kafka 是一种分布式的，基于发布 &#x2F; 订阅的消息系统。主要设计目标如下：</p><ul><li>以时间复杂度为 O(1) 的方式提供消息持久化能力，即使对 TB 级以上数据也能保证常数时间复杂度的访问性能。</li><li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒 100K 条以上消息的传输。</li><li>支持 Kafka Server 间的消息分区，及分布式消费，同时保证每个 Partition 内的消息顺序传输。</li><li>同时支持离线数据处理和实时数据处理。</li><li>Scale out：支持在线水平扩展。</li></ul><p>假如你是一个程序员，假设你维护了两个服务 A 和 B。<br>B 服务每秒只能处理 100 个消息，但 A 服务却每秒发出 200 个消息，B 服务哪里顶得住，分分钟被压垮。<br>那么问题就来了，有没有办法让 B 在不被压垮的同时，还能处理掉 A 的消息？<br>当然有，<strong>没有什么是加一层中间层不能解决的，如果有，那就再加一层</strong>。</p><h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p><img src="https://cdn.xiaobaidebug.top/1713671959546.jpeg" alt="消息队列在B进程里"></p><p>为了保护 B 服务，我们很容易想到可以在 B 服务的内存中加入一个<strong>队列</strong>。</p><p>其实就是个链表，链表的每一个节点就是一个消息，每个节点有一个序号，我们叫它Offset，记录消息1位置。B服务依据自己的处理能力，消费链表里面的消息，能处理多少是多少不断更新已处理 Offset 的值。但这有个问题，来不及处理的消息会堆积在内存里，如果 B 服务更新<strong>重启</strong>，这些消息就都丢了。<br>这个好解决，将队列挪出来，变成一个<strong>单独的进程</strong>。就算 B 服务重启，也不会影响到了队列里的消息。</p><p><img src="https://cdn.xiaobaidebug.top/1713671978580.jpeg" alt="消息队列单独一个进程"></p><p>这样一个简陋的队列进程，其实就是所谓的<strong>消息队列</strong>。<br>而像 A 服务这样负责发数据到消息队列的角色，就是<strong>生产者</strong>，像 B 服务这样处理消息的角色，就是<strong>消费者</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/1713672007372.jpeg" alt="生产者和消费者"></p><p>但这个消息队列属实过于简陋，像什么高性能，高扩展性，高可用，它是一个都不沾。<br>我们来看下怎么优化它。</p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><p>B 服务由于性能较差，消息队列里会不断堆积数据，为了提升性能，我们可以扩展更多的消费者, 这样消费速度就上去了，相对的我们就可以增加更多生产者，提升消息队列的吞吐量。</p><p>随着生产者和消费者都变多，我们会发现它们会同时争抢同一个消息队列，抢不到的一方就得等待，这不纯纯浪费时间吗！<br>有解决方案吗？有！</p><p><img src="https://cdn.xiaobaidebug.top/1713672075754.jpeg" alt="多个topic">首先是对消息进行分类，每一类是一个 <strong>topic</strong>，然后根据 topic 新增队列的数量，生产者将数据按 topic 投递到不同的队列中，消费者则根据需要订阅不同的 topic。这就大大降低了 topic 队列的压力。</p><p>但单个 topic 的消息还是可能过多，我们可以将单个队列，拆成好几段，每段就是一个 <strong>partition 分区</strong>，每个消费者负责一个 partition。<br>这就大大降低了争抢，提升了消息队列的性能。</p><h2 id="高扩展性"><a href="#高扩展性" class="headerlink" title="高扩展性"></a>高扩展性</h2><p>随着 partition 变多，如果 partition 都在同一台机器上的话，就会导致单机 cpu 和内存过高，影响整体系统性能。于是我们可以申请更多的机器，将 partition 分散部署在多台机器上，这每一台机器，就代表一个 <strong>broker</strong>。我们可以通过增加 broker 缓解机器 cpu 过高带来的性能问题。</p><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>到这里，其实还有个问题，如果其中一个 partition 所在的 broker 挂了，那 broker 里所有 partition 的消息就都没了。这高可用还从何谈起？<br>我们可以给 partition 多加几个副本，也就是 replicas，将它们分为 Leader 和 Follower。Leader 负责应付生产者和消费者的读写请求，而 Follower 只管同步 Leader 的消息。将 Leader 和 Follower 分散到不同的 broker 上，这样 Leader 所在的 broker 挂了，也不会影响到 Follower 所在的 broker, 并且还能从 Follower 中选举出一个新的 Leader partition 顶上。这样就保证了消息队列的高可用。</p><p>当我们讨论<strong>可靠性</strong>的时候，我们总会提到*保证**这个词语。可靠性保证是基础，我们基于这些基础之上构建我们的应用。比如关系型数据库的可靠性保证是ACID，也就是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。</p><p>Kafka 中的可靠性保证有如下四点：</p><ul><li>对于一个分区来说，它的消息是有序的。如果一个生产者向一个分区先写入消息A，然后写入消息B，那么消费者会先读取消息A再读取消息B。</li><li>当消息写入所有in-sync状态的副本后，消息才会认为<strong>已提交（committed）</strong>。这里的写入有可能只是写入到文件系统的缓存，不一定刷新到磁盘。生产者可以等待不同时机的确认，比如等待分区主副本写入即返回，后者等待所有in-sync状态副本写入才返回。</li><li>一旦消息已提交，那么只要有一个副本存活，数据不会丢失。</li><li>消费者只能读取到已提交的消息。</li></ul><p>使用这些基础保证，我们构建一个可靠的系统，这时候需要考虑一个问题：究竟我们的应用需要多大程度的可靠性？可靠性不是无偿的，它与系统可用性、吞吐量、延迟和硬件价格息息相关，得此失彼。因此，我们往往需要做权衡，一味的追求可靠性并不实际。</p><h2 id="持久化和过期策略"><a href="#持久化和过期策略" class="headerlink" title="持久化和过期策略"></a>持久化和过期策略</h2><p>刚刚提到的是几个 broker 挂掉的情况，那搞大点，假设所有 broker 都挂了，那岂不是数据全丢了？<br>为了解决这个问题，我们不能光把数据放内存里，还要持久化到磁盘中，这样哪怕全部 broker 都挂了，数据也不会全丢，重启服务后，也能从磁盘里读出数据，继续工作。</p><p>但问题又来了，磁盘总是有限的，这一直往里写数据迟早有一天得炸。<br>所以我们还可以给数据加上保留策略，也就是所谓的 <code>retention policy</code>，比如磁盘数据超过一定大小或消息放置超过一定时间就会被清理掉。</p><h2 id="consumer-group"><a href="#consumer-group" class="headerlink" title="consumer group"></a>consumer group</h2><p>到这里，这个消息队列好像就挺完美了。但其实还有个问题，按现在的消费方式，每次新增的消费者只能跟着<strong>最新的</strong>消费 Offset 接着消费。<br>如果我想让新增的消费者从某个 Offset 开始消费呢？<br>听起来这个需求很刁钻？我举个例子你就明白了。</p><p>哪怕 B 服务有多个实例，但本质上，它只有一个消费业务方，新增实例一般也是接着之前的 offset 继续消费。<br>假设现在来了个新的业务方，C 服务，它想从头开始消费消息队列里的数据，这时候就不能跟在 B 服务的 offset 后边继续消费了。</p><p>所以我们还可以给消息队列加入消费者组（consumer group）的概念，B 和 C 服务各自是一个独立的消费者组，不同消费者组维护自己的消费进度，互不打搅。</p><h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><p>相信你也发现了，组件太多了，而且每个组件都有自己的数据和状态，所以还需要有个组件去统一维护这些组件的状态信息，于是我们引入 <strong>ZooKeeper</strong> 组件。它会定期和 broker 通信，获取 整个 kafka 集群的状态，以此判断 某些 broker 是不是跪了，某些消费组消费到哪了。</p><h2 id="二、Kafka-的设计与实现"><a href="#二、Kafka-的设计与实现" class="headerlink" title="二、Kafka 的设计与实现"></a><strong>二、Kafka 的设计与实现</strong></h2><h3 id="Kafka-存储在文件系统上"><a href="#Kafka-存储在文件系统上" class="headerlink" title="Kafka 存储在文件系统上"></a><strong>Kafka 存储在文件系统上</strong></h3><p>Kafka 高度依赖文件系统来存储和缓存消息，一般的人认为 “磁盘是缓慢的”，所以对这样的设计持有怀疑态度。现代的操作系统针对磁盘的读写已经做了一些优化方案来加快磁盘的访问速度。比如，<strong>预读</strong>会提前将一个比较大的磁盘快读入内存。<strong>后写</strong>会将很多小的逻辑写操作合并起来组合成一个大的物理写操作。并且，操作系统还会将主内存剩余的所有空闲内存空间都用作<strong>磁盘缓存</strong>，所有的磁盘读写操作都会经过统一的磁盘缓存（除了直接 I&#x2F;O 会绕过磁盘缓存）。综合这几点优化特点，<strong>如果是针对磁盘的顺序访问，某些情况下它可能比随机的内存访问都要快，甚至可以和网络的速度相差无几。</strong></p><p> <strong>Topic 其实是逻辑上的概念，面相消费者和生产者，物理上存储的其实是 Partition</strong>，每一个 Partition 最终对应一个目录，里面存储所有的消息和索引文件。默认情况下，每一个 Topic 在创建时如果不指定 Partition 数量时只会创建 1 个 Partition。比如，我创建了一个 Topic 名字为 test ，没有指定 Partition 的数量，那么会默认创建一个 test-0 的文件夹，这里的命名规则是：<code>&lt;topic_name&gt;-&lt;partition_id&gt;</code>。</p><p>任何发布到 Partition 的消息都会被追加到 Partition 数据文件的尾部，这样的顺序写磁盘操作让 Kafka 的效率非常高（经验证，顺序写磁盘效率比随机写内存还要高，这是 Kafka 高吞吐率的一个很重要的保证）。</p><p>每一条消息被发送到 Broker 中，会根据 Partition 规则选择被存储到哪一个 Partition。如果 Partition 规则设置的合理，所有消息可以均匀分布到不同的 Partition中。</p><h3 id="Kafka-中的底层存储设计"><a href="#Kafka-中的底层存储设计" class="headerlink" title="Kafka 中的底层存储设计"></a><strong>Kafka 中的底层存储设计</strong></h3><p>假设我们现在 Kafka 集群只有一个 Broker，我们创建 2 个 Topic 名称分别为：「topic1」和「topic2」，Partition 数量分别为 1、2，那么我们的根目录下就会创建如下三个文件夹：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| --topic1-0</span><br><span class="line">| --topic2-0</span><br><span class="line">| --topic2-1</span><br></pre></td></tr></table></figure><p>在 Kafka 的文件存储中，同一个 Topic 下有多个不同的 Partition，每个 Partition 都为一个目录，而每一个目录又被平均分配成多个大小相等的 <strong>Segment File</strong> 中，Segment File 又由 index file 和 data file 组成，他们总是成对出现，后缀 “.index” 和 “.log” 分表表示 Segment 索引文件和数据文件。</p><p>现在假设我们设置每个 Segment 大小为 500 MB，并启动生产者向 topic1 中写入大量数据，topic1-0 文件夹中就会产生类似如下的一些文件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">| --topic1-0</span><br><span class="line">    | --00000000000000000000.index</span><br><span class="line">    | --00000000000000000000.log</span><br><span class="line">    | --00000000000000368769.index</span><br><span class="line">    | --00000000000000368769.log</span><br><span class="line">    | --00000000000000737337.index</span><br><span class="line">    | --00000000000000737337.log</span><br><span class="line">    | --00000000000001105814.index</span><br><span class="line">    | --00000000000001105814.log</span><br><span class="line">| --topic2-0</span><br><span class="line">| --topic2-1</span><br></pre></td></tr></table></figure><p><strong>Segment 是 Kafka 文件存储的最小单位。</strong>Segment 文件命名规则：Partition 全局的第一个 Segment 从 0 开始，后续每个 Segment 文件名为上一个 Segment 文件最后一条消息的 offset 值。数值最大为 64 位 long 大小，19 位数字字符长度，没有数字用0填充。如 00000000000000368769.index 和 00000000000000368769.log。</p><p>其中以索引文件中元数据 <code>&lt;3, 497&gt;</code> 为例，依次在数据文件中表示第 3 个 message（在全局 Partition 表示第 368769 + 3 &#x3D; 368772 个 message）以及该消息的物理偏移地址为 497。</p><p>注意该 index 文件并不是从0开始，也不是每次递增1的，这是因为 Kafka 采取稀疏索引存储的方式，每隔一定字节的数据建立一条索引，它减少了索引文件大小，使得能够把 index 映射到内存，降低了查询时的磁盘 IO 开销，同时也并没有给查询带来太多的时间消耗。</p><p>因为其文件名为上一个 Segment 最后一条消息的 offset ，所以当需要查找一个指定 offset 的 message 时，通过在所有 segment 的文件名中进行二分查找就能找到它归属的 segment ，再在其 index 文件中找到其对应到文件上的物理位置，就能拿出该 message 。</p><p>由于消息在 Partition 的 Segment 数据文件中是顺序读写的，且消息消费后不会删除（删除策略是针对过期的 Segment 文件），这种顺序磁盘 IO 存储设计师 Kafka 高性能很重要的原因。</p><blockquote><p>Kafka 是如何准确的知道 message 的偏移的呢？这是因为在 Kafka 定义了标准的数据存储结构，在 Partition 中的每一条 message 都包含了以下三个属性：</p></blockquote><ul><li>offset：表示 message 在当前 Partition 中的偏移量，是一个逻辑上的值，唯一确定了 Partition 中的一条 message，可以简单的认为是一个 id；</li><li>MessageSize：表示 message 内容 data 的大小；</li><li>data：message 的具体内容</li></ul><h3 id="消费组与分区重平衡"><a href="#消费组与分区重平衡" class="headerlink" title="消费组与分区重平衡"></a><strong>消费组与分区重平衡</strong></h3><p>当新的消费者加入消费组，它会消费一个或多个分区，而这些分区之前是由其他消费者负责的；另外，当消费者离开消费组（比如重启、宕机等）时，它所消费的分区会分配给其他分区。这种现象称为<strong>重平衡（rebalance）</strong>。重平衡是 Kafka 一个很重要的性质，这个性质保证了高可用和水平扩展。<strong>不过也需要注意到，在重平衡期间，所有消费者都不能消费消息，因此会造成整个消费组短暂的不可用。</strong>而且，将分区进行重平衡也会导致原来的消费者状态过期，从而导致消费者需要重新更新状态，这段期间也会降低消费性能。后面我们会讨论如何安全的进行重平衡以及如何尽可能避免。</p><p>消费者通过定期发送心跳（hearbeat）到一个作为组协调者（group coordinator）的 broker 来保持在消费组内存活。这个 broker 不是固定的，每个消费组都可能不同。当消费者拉取消息或者提交时，便会发送心跳。</p><p>如果消费者超过一定时间没有发送心跳，那么它的会话（session）就会过期，组协调者会认为该消费者已经宕机，然后触发重平衡。可以看到，从消费者宕机到会话过期是有一定时间的，这段时间内该消费者的分区都不能进行消息消费；</p><p>在 0.10.1 版本，Kafka 对心跳机制进行了修改，将发送心跳与拉取消息进行分离，这样使得发送心跳的频率不受拉取的频率影响。另外更高版本的 Kafka 支持配置一个消费者多长时间不拉取消息但仍然保持存活，这个配置可以避免活锁（livelock）。活锁，是指应用没有故障但是由于某些原因不能进一步消费。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> Kafka </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas学习</title>
      <link href="/2024/05/09/pandas%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/05/09/pandas%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="pandas学习笔记"><a href="#pandas学习笔记" class="headerlink" title="pandas学习笔记"></a>pandas学习笔记</h1><h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><h4 id="serirs的创建"><a href="#serirs的创建" class="headerlink" title="serirs的创建"></a>serirs的创建</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">pd.Series(np)</span><br><span class="line">传入一个可迭代对象</span><br><span class="line">可以指定index作为键值</span><br><span class="line"><span class="comment">#可以传入字典来创建 Series</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ser = pd.Series(data=d, index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ser</span><br><span class="line">a   <span class="number">1</span></span><br><span class="line">b   <span class="number">2</span></span><br><span class="line">c   <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="切片和索引"><a href="#切片和索引" class="headerlink" title="切片和索引"></a>切片和索引</h4><p>与字典一样 Series可以通过index来查找对应的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;xiaoming&quot;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;tel&#x27;</span>: <span class="number">1008010</span>&#125;</span><br><span class="line">t3 = pd.Series(d)</span><br><span class="line"><span class="built_in">print</span>(t3[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(t3[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output：</span></span><br><span class="line">xiaoming</span><br><span class="line">xiaoming</span><br></pre></td></tr></table></figure><p>同样的 我们可以对其进行切片以及离散的索引取值</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20230715112443039.png" alt="image-20230715112443039"></p><p>Series也有where方法但与numpy有些不同</p><hr><h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><p>DataFrame是一种二维数据</p><h4 id="DataFrame的基础属性"><a href="#DataFrame的基础属性" class="headerlink" title="DataFrame的基础属性"></a>DataFrame的基础属性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df.shape <span class="comment"># 行数 列数</span></span><br><span class="line">df.dtypes <span class="comment"># 列数据类型</span></span><br><span class="line">df.ndim <span class="comment">#数据维度</span></span><br><span class="line">df.index <span class="comment"># 行索引</span></span><br><span class="line">df.columns <span class="comment"># 列索引</span></span><br><span class="line">df.values <span class="comment"># 对象值，二维ndarray数组</span></span><br><span class="line"></span><br><span class="line">DataFrame整体情况查询</span><br><span class="line">df.head(<span class="number">3</span>) <span class="comment"># 显示头部几行，默认5行df.tal(3) # 显示未尾几行，默认5行</span></span><br><span class="line">df.info()<span class="comment"># 相关信息概览: 行数，列数，列索引，列非空值个数，列类型，列类型，内存占用 </span></span><br><span class="line">df.describe()  <span class="comment">#快速综合统计结果: 计数，均值，标准差，最大值，四分位数，最小值</span></span><br></pre></td></tr></table></figure><h4 id="DataFrame的切片索引"><a href="#DataFrame的切片索引" class="headerlink" title="DataFrame的切片索引"></a>DataFrame的切片索引</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Input：</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">Output：</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line"><span class="number">2</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br><span class="line"><span class="comment"># Dataframe既有行索引又有列索引 </span></span><br><span class="line">行索引叫index axis = <span class="number">0</span></span><br><span class="line">列索引叫 columns axis =<span class="number">1</span></span><br><span class="line"></span><br><span class="line">与之前一样我们可以指定行索引和列索引</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>),index=<span class="built_in">list</span>(<span class="string">&#x27;abc&#x27;</span>),columns=<span class="built_in">list</span>(<span class="string">&#x27;wxyz&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line">OutPut：</span><br><span class="line">   w  x   y   z</span><br><span class="line">a  <span class="number">0</span>  <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">b  <span class="number">4</span>  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span></span><br><span class="line">c  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br><span class="line"><span class="comment"># pandas取行或者列的注意点</span></span><br><span class="line"><span class="comment">#- 方括号写数组，表示取行，对行进行操作</span></span><br><span class="line"><span class="comment">#- 写字符串，表示的去列索引,对列进行操作</span></span><br><span class="line">选择某一列  df[<span class="string">&quot;CountAnimalName&quot;</span>]</span><br><span class="line">同时选择行和列 df[:<span class="number">100</span>][<span class="string">&quot;CountAkimalName&quot;</span>]</span><br><span class="line">还有更多的经过pandas优化过的选择方式</span><br><span class="line">df.loc 通过标签索引行数据</span><br><span class="line">df.iloc 通过位置获取列数据</span><br><span class="line"><span class="comment">#Input:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;z&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(df.loc[<span class="string">&quot;a&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(df.loc[:, <span class="string">&quot;y&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(df.iloc[<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(df.iloc[:,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(df.iloc[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>]])</span><br><span class="line"><span class="comment"># OutPut:</span></span><br><span class="line">****************************************************************************</span><br><span class="line"><span class="number">3</span></span><br><span class="line">w    <span class="number">0</span></span><br><span class="line">x    <span class="number">1</span></span><br><span class="line">y    <span class="number">2</span></span><br><span class="line">z    <span class="number">3</span></span><br><span class="line">Name: a, dtype: int32</span><br><span class="line">a     <span class="number">2</span></span><br><span class="line">b     <span class="number">6</span></span><br><span class="line">c    <span class="number">10</span></span><br><span class="line">Name: y, dtype: int32</span><br><span class="line">****************************************************************************</span><br><span class="line"><span class="number">1</span></span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">5</span></span><br><span class="line">c    <span class="number">9</span></span><br><span class="line">Name: x, dtype: int32</span><br><span class="line">   x  y</span><br><span class="line">a  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line">b  <span class="number">5</span>  <span class="number">6</span></span><br><span class="line"><span class="comment"># 布尔索引</span></span><br><span class="line">与之前相同也有</span><br><span class="line"> df[df[<span class="string">&quot;Count_AnimalName&quot;</span>]&gt;<span class="number">800</span>]</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="DataFrame的字符串方法"><a href="#DataFrame的字符串方法" class="headerlink" title="DataFrame的字符串方法"></a>DataFrame的字符串方法</h4><p><img src="C:\Users\sz.L\AppData\Roaming\Typora\typora-user-images\image-20230718091516640.png![image-20230718095515935](https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20230718095515935.png" alt="image-20230718091516640"></p><h4 id="DataFrame的排序"><a href="#DataFrame的排序" class="headerlink" title="DataFrame的排序"></a>DataFrame的排序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">df.sort_value()</span><br><span class="line"> <span class="keyword">def</span> <span class="title function_">sort_values</span>(<span class="params">  <span class="comment"># type: ignore[override]</span></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        by,</span></span><br><span class="line"><span class="params">        axis: Axis = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">        ascending=<span class="literal">True</span>,</span></span><br><span class="line"><span class="params">        inplace: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">        kind: <span class="built_in">str</span> = <span class="string">&quot;quicksort&quot;</span>,</span></span><br><span class="line"><span class="params">        na_position: <span class="built_in">str</span> = <span class="string">&quot;last&quot;</span>,</span></span><br><span class="line"><span class="params">        ignore_index: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">        key: ValueKeyFunc = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    </span>):</span><br></pre></td></tr></table></figure><h4 id="缺失数据的处理"><a href="#缺失数据的处理" class="headerlink" title="缺失数据的处理"></a>缺失数据的处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pd.isnull 可以帮助我们判断这个值是否为NAN</span><br><span class="line">pd.notnull 可以判断不是nan的值</span><br><span class="line"></span><br><span class="line">处理方式<span class="number">1</span>:删除NaN所在的行列</span><br><span class="line">dropna (axis=<span class="number">0</span>,how=<span class="built_in">any</span>,inplace=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">how 传入<span class="built_in">any</span>或<span class="built_in">all</span> 全部为nan就删除或者部分nan删除</span><br><span class="line">inplace 是选择是否在原地进行替换</span><br><span class="line"></span><br><span class="line">处理方式<span class="number">2</span>: 填充数据</span><br><span class="line">t.fillna(t.mean()),t.fiallna(t.median()),t.fillna(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">处理为<span class="number">0</span>的数据:</span><br><span class="line">t[t==<span class="number">0</span>] = np.nan</span><br><span class="line">当然并不是每次为<span class="number">0</span>的数据都需要处理</span><br><span class="line">计算平均值等情况，nan是不参与计算的，但是<span class="number">0</span>会</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="Pandas读取外部数据"><a href="#Pandas读取外部数据" class="headerlink" title="Pandas读取外部数据"></a>Pandas读取外部数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(path) 打开csv文件</span><br></pre></td></tr></table></figure><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20230715115714667.png" alt="image-20230715115714667"></p><p>有很多方法打开各式数据</p><h2 id="数据的合并和分类聚合"><a href="#数据的合并和分类聚合" class="headerlink" title="数据的合并和分类聚合"></a>数据的合并和分类聚合</h2><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.join 把索引相同数据合并到一起</span><br></pre></td></tr></table></figure><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20230718171931457.png" alt="image-20230718171931457"></p><p>merge按照指定的列把数据按照一定的方式合并到一起</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20230718183844190.png" alt="image-20230718183844190"></p><ul><li>如果两个集有相同的列表头那就可以用 on参数指定‘df1.merge(df3.on&#x3D;”a”，how&#x3D;”outer”)</li><li>取交集的本质是判断相同行的值是否相等 如果相等把这一行的另外的数据补到后边</li><li>默认为inner交集</li><li>outer 并集，NAN补全</li><li>left 左边为准NAN补全</li><li>right 右边为准，NAN补全</li></ul><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>在pandas中类似的分组的操作我们有很简单的方式来完成</p><p><code>df.groupby(by=&quot;columns_name&quot;)</code></p><p>grouped是一个DataFrameGroupBy对象，是可迭代的grouped中的每一个元素是一个元组元组里面是（索引(分组的值)，分组之后的DataFrame）</p><p>DataFrameGroupBy对象有很多经过优化的方法</p><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>count</td><td>分组中非NA值的数量</td></tr><tr><td>sum</td><td>非NA值的和</td></tr><tr><td>mean</td><td>非NA值的平均值</td></tr><tr><td>median</td><td>非NA值的算术平均数</td></tr><tr><td>std、var</td><td>无偏（分母为n-1）标准差和方差</td></tr><tr><td>min、max</td><td>非NA的最小值最大值</td></tr></tbody></table><p>如果我们需要对不同的列进行分组统计</p><p><code>grouped = df.groupby(by=[df[&quot;Country&quot;],df[&quot;State/Province&quot;]])</code></p><p>很多时候我们只希望对获取分组之后的某一部分数据，或者说我们只希望对某几列数据进行分组</p><p>获取分组之后的某一部分数据：</p><p> <code>df.groupby</code>(by&#x3D;[“Country”,”State&#x2F;Province”])[“Country”].count()</p><p>对某几列数据进行分组：</p><p> <code>df[&quot;Country&quot;].groupby(by=[df[&quot;Country&quot;],df[&quot;State/Province&quot;]]).count()</code></p><p>观察结果，由于只选择了一列数据，所以结果是一个Series类型</p><p><code>t1 = df[[&quot;Country&quot;]].groupby(by=[df[&quot;Country&quot;],df[&quot;State/Province&quot;]]).count()</code></p><p><code>t2 = df.groupby(by=[&quot;Country&quot;,&quot;State/Province&quot;])[[&quot;Country&quot;]].count()</code></p><p>以上的两条命令结果一样和之前的结果的区别在于当前返回的是一个DataFrame类型</p><h4 id="索引和复合索引"><a href="#索引和复合索引" class="headerlink" title="索引和复合索引"></a>索引和复合索引</h4><ul><li>简单的索引操作：获取index：df.index</li><li>指定index ：df.index &#x3D; [‘x’,’y’]</li><li>重新设置index : df.reindex(list(“abcedf”))</li><li>指定某一列作为index ：df.set_index(“Country”,drop&#x3D;False) drop为False时被指定为index的那一列不会被删除</li><li>返回index的唯一值：df.set_index(“Country”).index.unique() 因为有unique 说明index的值可以重复</li></ul><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20230718220049150.png" alt="image-20230718220049150"></p><p>当复合重复时索引会省略多余部分</p><h5 id="series复合索引"><a href="#series复合索引" class="headerlink" title="series复合索引"></a>series复合索引</h5><p><img src="/2024/05/09/pandas%E5%AD%A6%E4%B9%A0/Users\sz.L\AppData\Roaming\Typora\typora-user-images\image-20230719093334788.png" alt="image-20230719093334788"></p><p>如果要直接用level标签里的标签作为索引有：</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20230719094532204.png" alt="image-20230719094532204"></p><h5 id="DataFrame复合索引"><a href="#DataFrame复合索引" class="headerlink" title="DataFrame复合索引"></a>DataFrame复合索引</h5><p><img src="/2024/05/09/pandas%E5%AD%A6%E4%B9%A0/Users\sz.L\AppData\Roaming\Typora\typora-user-images\image-20230719095207535.png" alt="image-20230719095207535"></p><h2 id="Pandas时间序列"><a href="#Pandas时间序列" class="headerlink" title="Pandas时间序列"></a>Pandas时间序列</h2><p>不管在什么行业，时间序列都是一种非常重要的数据形式，很多统计数据以及数据的规律也都和时间序列有着非常重要的联系</p><h4 id="生成一段时间范围"><a href="#生成一段时间范围" class="headerlink" title="生成一段时间范围"></a>生成一段时间范围</h4><p><code>pd.date_range(start=None, end=None, periods=None, freq=&#39;D&#39;)</code></p><p>start和end以及freq配合能够生成start和end范围内以频率freq的一组时间索引</p><p>start和periods以及freq配合能够生成从start开始的频率为freq的periods个时间索引</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20230719154850921.png" alt="image-20230719154850921"></p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20230719115903091.png" alt="image-20230719115903091"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index=pd.date_range(<span class="string">&quot;20170101&quot;</span>,periods=<span class="number">10</span>)</span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">10</span>),index=index)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以使用pandas提供的方法把时间字符串转化为时间序列</p><p><code>df[&quot;timeStamp&quot;] = pd.to_datetime(df[&quot;timeStamp&quot;],format=&quot;&quot;)</code></p><p>format参数大部分情况下可以不用写，但是对于pandas无法格式化的时间字符串，我们可以使用该参数，比如包含中文</p><h2 id="pandas重采样"><a href="#pandas重采样" class="headerlink" title="pandas重采样"></a>pandas重采样</h2><p><strong>重采样</strong>：指的是将时间序列从<strong>一个频率转化为另一个频率进行</strong>处理的过程，将高频率数据转化为低频率数据为<strong>降采样</strong>，低频率转化为高频率为<strong>升采样</strong></p><p>pandas提供了一个resample的方法来帮助我们实现频率转化</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20230719161942707.png" alt="image-20230719161942707"></p><h2 id="PeriodIndex"><a href="#PeriodIndex" class="headerlink" title="PeriodIndex"></a>PeriodIndex</h2><p>之前所学习的DatetimeIndex可以理解为时间戳</p><p>PeriodIndex可以理解为时间段</p><p><code>periods = pd.PeriodIndex(year=data[&quot;year&quot;],month=data[&quot;month&quot;],day=data[&quot;day&quot;],hour=data[&quot;hour&quot;],freq=&quot;H&quot;)</code></p><p>如果给这个时间段降采样</p><p><code>data = df.set_index(periods).resample(&quot;10D&quot;).mean()</code></p><h2 id="pandas常用接口"><a href="#pandas常用接口" class="headerlink" title="pandas常用接口"></a>pandas常用接口</h2><h3 id="1、维度查看："><a href="#1、维度查看：" class="headerlink" title="1、维度查看："></a>1、维度查看：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.shape</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2、数据表基本信息（维度、列名称、数据格式、所占空间等）："><a href="#2、数据表基本信息（维度、列名称、数据格式、所占空间等）：" class="headerlink" title="2、数据表基本信息（维度、列名称、数据格式、所占空间等）："></a>2、数据表基本信息（维度、列名称、数据格式、所占空间等）：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.info()</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="3、每一列数据的格式："><a href="#3、每一列数据的格式：" class="headerlink" title="3、每一列数据的格式："></a>3、每一列数据的格式：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.dtypes</span><br></pre></td></tr></table></figure><h3 id="4、某一列格式："><a href="#4、某一列格式：" class="headerlink" title="4、某一列格式："></a>4、某一列格式：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;B&#x27;</span>].dtype</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="5、空值："><a href="#5、空值：" class="headerlink" title="5、空值："></a>5、空值：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.isnull()</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="6、查看某一列空值："><a href="#6、查看某一列空值：" class="headerlink" title="6、查看某一列空值："></a>6、查看某一列空值：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;B&#x27;</span>].isnull()</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="7、查看某一列的唯一值："><a href="#7、查看某一列的唯一值：" class="headerlink" title="7、查看某一列的唯一值："></a>7、查看某一列的唯一值：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;B&#x27;</span>].unique()</span><br></pre></td></tr></table></figure><h3 id="8、查看数据表的值："><a href="#8、查看数据表的值：" class="headerlink" title="8、查看数据表的值："></a>8、查看数据表的值：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.values </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="9、查看列名称："><a href="#9、查看列名称：" class="headerlink" title="9、查看列名称："></a>9、查看列名称：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.columns</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="10、查看前5行数据、后5行数据："><a href="#10、查看前5行数据、后5行数据：" class="headerlink" title="10、查看前5行数据、后5行数据："></a>10、查看前5行数据、后5行数据：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.head() <span class="comment">#默认前5行数据</span></span><br><span class="line">df.tail()    <span class="comment">#默认后5行数据</span></span><br></pre></td></tr></table></figure><h2 id="三、数据表清洗"><a href="#三、数据表清洗" class="headerlink" title="三、数据表清洗"></a>三、数据表清洗</h2><h3 id="1、用数字0填充空值："><a href="#1、用数字0填充空值：" class="headerlink" title="1、用数字0填充空值："></a>1、用数字0填充空值：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.fillna(value=<span class="number">0</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2、使用列prince的均值对NA进行填充："><a href="#2、使用列prince的均值对NA进行填充：" class="headerlink" title="2、使用列prince的均值对NA进行填充："></a>2、使用列prince的均值对NA进行填充：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;prince&#x27;</span>].fillna(df[<span class="string">&#x27;prince&#x27;</span>].mean())</span><br></pre></td></tr></table></figure><h3 id="3、清除city字段的字符空格："><a href="#3、清除city字段的字符空格：" class="headerlink" title="3、清除city字段的字符空格："></a>3、清除city字段的字符空格：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;city&#x27;</span>]=df[<span class="string">&#x27;city&#x27;</span>].<span class="built_in">map</span>(<span class="built_in">str</span>.strip)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="4、大小写转换："><a href="#4、大小写转换：" class="headerlink" title="4、大小写转换："></a>4、大小写转换：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;city&#x27;</span>]=df[<span class="string">&#x27;city&#x27;</span>].<span class="built_in">str</span>.lower()</span><br></pre></td></tr></table></figure><h3 id="5、更改数据格式："><a href="#5、更改数据格式：" class="headerlink" title="5、更改数据格式："></a>5、更改数据格式：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;price&#x27;</span>].astype(<span class="string">&#x27;int&#x27;</span>)       </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="6、更改列名称："><a href="#6、更改列名称：" class="headerlink" title="6、更改列名称："></a>6、更改列名称：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.rename(columns=&#123;<span class="string">&#x27;category&#x27;</span>: <span class="string">&#x27;category-size&#x27;</span>&#125;) </span><br></pre></td></tr></table></figure><h3 id="7、删除后出现的重复值："><a href="#7、删除后出现的重复值：" class="headerlink" title="7、删除后出现的重复值："></a>7、删除后出现的重复值：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;city&#x27;</span>].drop_duplicates()</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="8-、删除先出现的重复值："><a href="#8-、删除先出现的重复值：" class="headerlink" title="8 、删除先出现的重复值："></a>8 、删除先出现的重复值：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;city&#x27;</span>].drop_duplicates(keep=<span class="string">&#x27;last&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="9、数据替换："><a href="#9、数据替换：" class="headerlink" title="9、数据替换："></a>9、数据替换：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;city&#x27;</span>].replace(<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;shanghai&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="四、数据预处理"><a href="#四、数据预处理" class="headerlink" title="四、数据预处理"></a>四、数据预处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df1=pd.DataFrame(&#123;<span class="string">&quot;id&quot;</span>:[<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>,<span class="number">1005</span>,<span class="number">1006</span>,<span class="number">1007</span>,<span class="number">1008</span>], </span><br><span class="line"><span class="string">&quot;gender&quot;</span>:[<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;female&#x27;</span>],</span><br><span class="line"><span class="string">&quot;pay&quot;</span>:[<span class="string">&#x27;Y&#x27;</span>,<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>,<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>,<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>,],</span><br><span class="line"><span class="string">&quot;m-point&quot;</span>:[<span class="number">10</span>,<span class="number">12</span>,<span class="number">20</span>,<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>]&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1、数据表合并"><a href="#1、数据表合并" class="headerlink" title="1、数据表合并"></a>1、数据表合并</h3><h4 id="1-1-merge"><a href="#1-1-merge" class="headerlink" title="1.1 merge"></a>1.1 merge</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df_inner=pd.merge(df,df1,how=<span class="string">&#x27;inner&#x27;</span>)  <span class="comment"># 匹配合并，交集</span></span><br><span class="line">df_left=pd.merge(df,df1,how=<span class="string">&#x27;left&#x27;</span>)        <span class="comment">#</span></span><br><span class="line">df_right=pd.merge(df,df1,how=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">df_outer=pd.merge(df,df1,how=<span class="string">&#x27;outer&#x27;</span>)  <span class="comment">#并集</span></span><br></pre></td></tr></table></figure><h4 id="1-2-append"><a href="#1-2-append" class="headerlink" title="1.2 append"></a>1.2 append</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = df1.append(df2)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180611091024579?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpeWVsZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h4 id="1-3-join"><a href="#1-3-join" class="headerlink" title="1.3 join"></a>1.3 join</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = left.join(right, on=<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180611091253685?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpeWVsZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h4 id="1-4-concat"><a href="#1-4-concat" class="headerlink" title="1.4 concat"></a>1.4 concat</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pd.concat(objs, axis=<span class="number">0</span>, join=<span class="string">&#x27;outer&#x27;</span>, join_axes=<span class="literal">None</span>, ignore_index=<span class="literal">False</span>,</span><br><span class="line">          keys=<span class="literal">None</span>, levels=<span class="literal">None</span>, names=<span class="literal">None</span>, verify_integrity=<span class="literal">False</span>,</span><br><span class="line">          copy=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li>objs︰ 一个序列或系列、 综合或面板对象的映射。如果字典中传递，将作为键参数，使用排序的键，除非它传递，在这种情况下的值将会选择</li><li>（见下文）。任何没有任何反对将默默地被丢弃，除非他们都没有在这种情况下将引发 ValueError。</li><li>axis: {0，1，…}，默认值为 0。要连接沿轴。</li><li>join: {‘内部’、 ‘外’}，默认 ‘外’。如何处理其他 axis(es) 上的索引。联盟内、 外的交叉口。</li><li>ignore_index︰ 布尔值、 默认 False。如果为 True，则不要串联轴上使用的索引值。由此产生的轴将标记</li><li>0，…，n-1。这是有用的如果你串联串联轴没有有意义的索引信息的对象。请注意在联接中仍然受到尊重的其他轴上的索引值。</li><li>join_axes︰ 索引对象的列表。具体的指标，用于其他 n-1 轴而不是执行内部&#x2F;外部设置逻辑。 keys︰</li><li>序列，默认为无。构建分层索引使用通过的键作为最外面的级别。如果多个级别获得通过，应包含元组。</li><li>levels︰ 列表的序列，默认为无。具体水平 （唯一值） 用于构建多重。否则，他们将推断钥匙。</li><li>names︰ 列表中，默认为无。由此产生的分层索引中的级的名称。</li><li>verify_integrity︰ 布尔值、 默认 False。检查是否新的串联的轴包含重复项。这可以是相对于实际数据串联非常昂贵。</li><li>副本︰ 布尔值、 默认 True。如果为 False，请不要，不必要地复制数据。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例子：<span class="number">1.</span>frames = [df1, df2, df3]</span><br><span class="line">          <span class="number">2.</span>result = pd.concat(frames)</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180611091426153?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpeWVsZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h3 id="2、设置索引列"><a href="#2、设置索引列" class="headerlink" title="2、设置索引列"></a>2、设置索引列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_inner.set_index(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="3、按照特定列的值排序："><a href="#3、按照特定列的值排序：" class="headerlink" title="3、按照特定列的值排序："></a>3、按照特定列的值排序：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.sort_values(by=[<span class="string">&#x27;age&#x27;</span>])</span><br></pre></td></tr></table></figure><h3 id="4、按照索引列排序："><a href="#4、按照索引列排序：" class="headerlink" title="4、按照索引列排序："></a>4、按照索引列排序：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.sort_index()</span><br></pre></td></tr></table></figure><h3 id="5、如果prince列的值-3000，group列显示high，否则显示low："><a href="#5、如果prince列的值-3000，group列显示high，否则显示low：" class="headerlink" title="5、如果prince列的值&gt;3000，group列显示high，否则显示low："></a>5、如果prince列的值&gt;3000，group列显示high，否则显示low：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner[<span class="string">&#x27;group&#x27;</span>] = np.where(df_inner[<span class="string">&#x27;price&#x27;</span>] &gt; <span class="number">3000</span>,<span class="string">&#x27;high&#x27;</span>,<span class="string">&#x27;low&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="6、对复合多个条件的数据进行分组标记"><a href="#6、对复合多个条件的数据进行分组标记" class="headerlink" title="6、对复合多个条件的数据进行分组标记"></a>6、对复合多个条件的数据进行分组标记</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.loc[(df_inner[<span class="string">&#x27;city&#x27;</span>] == <span class="string">&#x27;beijing&#x27;</span>) &amp; (df_inner[<span class="string">&#x27;price&#x27;</span>] &gt;= <span class="number">4000</span></span><br></pre></td></tr></table></figure><h3 id="7、对category字段的值依次进行分列，并创建数据表，索引值为df-inner的索引列，列名称为category和size"><a href="#7、对category字段的值依次进行分列，并创建数据表，索引值为df-inner的索引列，列名称为category和size" class="headerlink" title="7、对category字段的值依次进行分列，并创建数据表，索引值为df_inner的索引列，列名称为category和size"></a>7、对category字段的值依次进行分列，并创建数据表，索引值为df_inner的索引列，列名称为category和size</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame((x.split(<span class="string">&#x27;-&#x27;</span>) <span class="keyword">for</span> x <span class="keyword">in</span> df_inner[<span class="string">&#x27;category&#x27;</span>]),index=df_inner.index</span><br></pre></td></tr></table></figure><h3 id="8、将完成分裂后的数据表和原df-inner数据表进行匹配"><a href="#8、将完成分裂后的数据表和原df-inner数据表进行匹配" class="headerlink" title="8、将完成分裂后的数据表和原df_inner数据表进行匹配"></a>8、将完成分裂后的数据表和原df_inner数据表进行匹配</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner=pd.merge(df_inner,split,right_index=<span class="literal">True</span>, left_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="五、数据提取"><a href="#五、数据提取" class="headerlink" title="五、数据提取"></a>五、数据提取</h2><p>主要用到的三个函数：loc,iloc和ix，loc函数按标签值进行提取，iloc按位置进行提取，ix可以同时按标签和位置进行提取。</p><h3 id="1、按索引提取单行的数值"><a href="#1、按索引提取单行的数值" class="headerlink" title="1、按索引提取单行的数值"></a>1、按索引提取单行的数值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.loc[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="2、按索引提取区域行数值"><a href="#2、按索引提取区域行数值" class="headerlink" title="2、按索引提取区域行数值"></a>2、按索引提取区域行数值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.iloc[<span class="number">0</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h3 id="3、重设索引"><a href="#3、重设索引" class="headerlink" title="3、重设索引"></a>3、重设索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.reset_index()</span><br></pre></td></tr></table></figure><h3 id="4、设置日期为索引"><a href="#4、设置日期为索引" class="headerlink" title="4、设置日期为索引"></a>4、设置日期为索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner=df_inner.set_index(<span class="string">&#x27;date&#x27;</span>) </span><br></pre></td></tr></table></figure><h3 id="5、提取4日之前的所有数据"><a href="#5、提取4日之前的所有数据" class="headerlink" title="5、提取4日之前的所有数据"></a>5、提取4日之前的所有数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner[:<span class="string">&#x27;2013-01-04&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="6、使用iloc按位置区域提取数据"><a href="#6、使用iloc按位置区域提取数据" class="headerlink" title="6、使用iloc按位置区域提取数据"></a>6、使用iloc按位置区域提取数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.iloc[:<span class="number">3</span>,:<span class="number">2</span>] <span class="comment">#冒号前后的数字不再是索引的标签名称，而是数据所在的位置，从0开始，前三行，</span></span><br></pre></td></tr></table></figure><h3 id="7、适应iloc按位置单独提起数据"><a href="#7、适应iloc按位置单独提起数据" class="headerlink" title="7、适应iloc按位置单独提起数据"></a>7、适应iloc按位置单独提起数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.iloc[[<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>]] <span class="comment">#提取第0、2、5行，4、5列</span></span><br></pre></td></tr></table></figure><h3 id="8、使用ix按索引标签和位置混合提取数据"><a href="#8、使用ix按索引标签和位置混合提取数据" class="headerlink" title="8、使用ix按索引标签和位置混合提取数据"></a>8、使用ix按索引标签和位置混合提取数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.ix[:<span class="string">&#x27;2013-01-03&#x27;</span>,:<span class="number">4</span>] <span class="comment">#2013-01-03号之前，前四列数据</span></span><br></pre></td></tr></table></figure><h3 id="9、判断city列的值是否为北京"><a href="#9、判断city列的值是否为北京" class="headerlink" title="9、判断city列的值是否为北京"></a>9、判断city列的值是否为北京</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner[<span class="string">&#x27;city&#x27;</span>].isin([<span class="string">&#x27;beijing&#x27;</span>])</span><br></pre></td></tr></table></figure><h3 id="10、判断city列里是否包含beijing和shanghai，然后将符合条件的数据提取出来"><a href="#10、判断city列里是否包含beijing和shanghai，然后将符合条件的数据提取出来" class="headerlink" title="10、判断city列里是否包含beijing和shanghai，然后将符合条件的数据提取出来"></a>10、判断city列里是否包含beijing和shanghai，然后将符合条件的数据提取出来</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.loc[df_inner[<span class="string">&#x27;city&#x27;</span>].isin([<span class="string">&#x27;beijing&#x27;</span>,<span class="string">&#x27;shanghai&#x27;</span>])] </span><br></pre></td></tr></table></figure><h3 id="11、提取前三个字符，并生成数据表"><a href="#11、提取前三个字符，并生成数据表" class="headerlink" title="11、提取前三个字符，并生成数据表"></a>11、提取前三个字符，并生成数据表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(df_inner[<span class="string">&#x27;category&#x27;</span>].<span class="built_in">str</span>[:<span class="number">3</span>])</span><br></pre></td></tr></table></figure><h2 id="六、数据筛选"><a href="#六、数据筛选" class="headerlink" title="六、数据筛选"></a>六、数据筛选</h2><p>使用与、或、非三个条件配合大于、小于、等于对数据进行筛选，并进行计数和求和。</p><h3 id="1、使用“与”进行筛选"><a href="#1、使用“与”进行筛选" class="headerlink" title="1、使用“与”进行筛选"></a>1、使用“与”进行筛选</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.loc[(df_inner[<span class="string">&#x27;age&#x27;</span>] &gt; <span class="number">25</span>) &amp; (df_inner[<span class="string">&#x27;city&#x27;</span>] == <span class="string">&#x27;beijing&#x27;</span>),  [<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;city&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;category&#x27;</span>,<span class="string">&#x27;gender&#x27;</span>]]</span><br></pre></td></tr></table></figure><h3 id="2、使用“或”进行筛选"><a href="#2、使用“或”进行筛选" class="headerlink" title="2、使用“或”进行筛选"></a>2、使用“或”进行筛选</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.loc[(df_inner[<span class="string">&#x27;age&#x27;</span>] &gt; <span class="number">25</span>) | (df_inner[<span class="string">&#x27;city&#x27;</span>] == <span class="string">&#x27;beijing&#x27;</span>)[<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;city&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;category&#x27;</span>,<span class="string">&#x27;gender&#x27;</span>]].sort([<span class="string">&#x27;age&#x27;</span>]) </span><br></pre></td></tr></table></figure><h3 id="3、使用“非”条件进行筛选"><a href="#3、使用“非”条件进行筛选" class="headerlink" title="3、使用“非”条件进行筛选"></a>3、使用“非”条件进行筛选</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.loc[(df_inner[<span class="string">&#x27;city&#x27;</span>] != <span class="string">&#x27;beijing&#x27;</span>), [<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;city&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;category&#x27;</span>,<span class="string">&#x27;gender&#x27;</span>]].sort([<span class="string">&#x27;id&#x27;</span>]) </span><br></pre></td></tr></table></figure><h3 id="4、对筛选后的数据按city列进行计数"><a href="#4、对筛选后的数据按city列进行计数" class="headerlink" title="4、对筛选后的数据按city列进行计数"></a>4、对筛选后的数据按city列进行计数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.loc[(df_inner[<span class="string">&#x27;city&#x27;</span>] != <span class="string">&#x27;beijing&#x27;</span>), [<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;city&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;category&#x27;</span>,<span class="string">&#x27;gender&#x27;</span>]].sort([<span class="string">&#x27;id&#x27;</span>]).city.count()</span><br></pre></td></tr></table></figure><h3 id="5、使用query函数进行筛选"><a href="#5、使用query函数进行筛选" class="headerlink" title="5、使用query函数进行筛选"></a>5、使用query函数进行筛选</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.query(<span class="string">&#x27;city == [&quot;beijing&quot;, &quot;shanghai&quot;]&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="6、对筛选后的结果按prince进行求和"><a href="#6、对筛选后的结果按prince进行求和" class="headerlink" title="6、对筛选后的结果按prince进行求和"></a>6、对筛选后的结果按prince进行求和</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.query(<span class="string">&#x27;city == [&quot;beijing&quot;, &quot;shanghai&quot;]&#x27;</span>).price.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><h2 id="七、数据汇总"><a href="#七、数据汇总" class="headerlink" title="七、数据汇总"></a>七、数据汇总</h2><p>主要函数是groupby和pivote_table</p><h3 id="1、对所有的列进行计数汇总"><a href="#1、对所有的列进行计数汇总" class="headerlink" title="1、对所有的列进行计数汇总"></a>1、对所有的列进行计数汇总</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.groupby(<span class="string">&#x27;city&#x27;</span>).count()</span><br></pre></td></tr></table></figure><h3 id="2、按城市对id字段进行计数"><a href="#2、按城市对id字段进行计数" class="headerlink" title="2、按城市对id字段进行计数"></a>2、按城市对id字段进行计数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.groupby(<span class="string">&#x27;city&#x27;</span>)[<span class="string">&#x27;id&#x27;</span>].count()</span><br></pre></td></tr></table></figure><h3 id="3、对两个字段进行汇总计数"><a href="#3、对两个字段进行汇总计数" class="headerlink" title="3、对两个字段进行汇总计数"></a>3、对两个字段进行汇总计数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.groupby([<span class="string">&#x27;city&#x27;</span>,<span class="string">&#x27;size&#x27;</span>])[<span class="string">&#x27;id&#x27;</span>].count()</span><br></pre></td></tr></table></figure><h3 id="4、对city字段进行汇总，并分别计算prince的合计和均值"><a href="#4、对city字段进行汇总，并分别计算prince的合计和均值" class="headerlink" title="4、对city字段进行汇总，并分别计算prince的合计和均值"></a>4、对city字段进行汇总，并分别计算prince的合计和均值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.groupby(<span class="string">&#x27;city&#x27;</span>)[<span class="string">&#x27;price&#x27;</span>].agg([<span class="built_in">len</span>,np.<span class="built_in">sum</span>, np.mean]) </span><br></pre></td></tr></table></figure><h2 id="八、数据统计"><a href="#八、数据统计" class="headerlink" title="八、数据统计"></a>八、数据统计</h2><p>数据采样，计算标准差，协方差和相关系数</p><h3 id="1、简单的数据采样"><a href="#1、简单的数据采样" class="headerlink" title="1、简单的数据采样"></a>1、简单的数据采样</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.sample(n=<span class="number">3</span>) </span><br></pre></td></tr></table></figure><h3 id="2、手动设置采样权重"><a href="#2、手动设置采样权重" class="headerlink" title="2、手动设置采样权重"></a>2、手动设置采样权重</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weights = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0.5</span>]</span><br><span class="line">df_inner.sample(n=<span class="number">2</span>, weights=weights) </span><br></pre></td></tr></table></figure><h3 id="3、采样后不放回"><a href="#3、采样后不放回" class="headerlink" title="3、采样后不放回"></a>3、采样后不放回</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_inner.sample(n=<span class="number">6</span>, replace=<span class="literal">False</span>) </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="4、采样后放回"><a href="#4、采样后放回" class="headerlink" title="4、采样后放回"></a>4、采样后放回</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.sample(n=<span class="number">6</span>, replace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="5、-数据表描述性统计"><a href="#5、-数据表描述性统计" class="headerlink" title="5、 数据表描述性统计"></a>5、 数据表描述性统计</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_inner.describe().<span class="built_in">round</span>(<span class="number">2</span>).T <span class="comment">#round函数设置显示小数位，T表示转置</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="6、计算列的标准差"><a href="#6、计算列的标准差" class="headerlink" title="6、计算列的标准差"></a>6、计算列的标准差</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner[<span class="string">&#x27;price&#x27;</span>].std()</span><br></pre></td></tr></table></figure><h3 id="7、计算两个字段间的协方差"><a href="#7、计算两个字段间的协方差" class="headerlink" title="7、计算两个字段间的协方差"></a>7、计算两个字段间的协方差</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_inner[<span class="string">&#x27;price&#x27;</span>].cov(df_inner[<span class="string">&#x27;m-point&#x27;</span>]) </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="8、数据表中所有字段间的协方差"><a href="#8、数据表中所有字段间的协方差" class="headerlink" title="8、数据表中所有字段间的协方差"></a>8、数据表中所有字段间的协方差</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.cov()</span><br></pre></td></tr></table></figure><h3 id="9、两个字段的相关性分析"><a href="#9、两个字段的相关性分析" class="headerlink" title="9、两个字段的相关性分析"></a>9、两个字段的相关性分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_inner[<span class="string">&#x27;price&#x27;</span>].corr(df_inner[<span class="string">&#x27;m-point&#x27;</span>]) <span class="comment">#相关系数在-1到1之间，接近1为正相关，接近-1为负相关，0为不相关</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="10、数据表的相关性分析"><a href="#10、数据表的相关性分析" class="headerlink" title="10、数据表的相关性分析"></a>10、数据表的相关性分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.corr()</span><br></pre></td></tr></table></figure><h2 id="九、数据输出"><a href="#九、数据输出" class="headerlink" title="九、数据输出"></a>九、数据输出</h2><p>分析后的数据可以输出为xlsx格式和csv格式</p><h3 id="1、写入Excel"><a href="#1、写入Excel" class="headerlink" title="1、写入Excel"></a>1、写入Excel</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_inner.to_excel(<span class="string">&#x27;excel_to_python.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;bluewhale_cc&#x27;</span>) </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2、写入到CSV"><a href="#2、写入到CSV" class="headerlink" title="2、写入到CSV"></a>2、写入到CSV</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.to_csv(<span class="string">&#x27;excel_to_python.csv&#x27;</span>) </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib学习</title>
      <link href="/2024/05/09/matplotlib%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/05/09/matplotlib%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="matplotlib重新学习"><a href="#matplotlib重新学习" class="headerlink" title="matplotlib重新学习"></a>matplotlib重新学习</h1><h2 id="基本要点"><a href="#基本要点" class="headerlink" title="基本要点"></a>基本要点</h2><h4 id="设置图片大小"><a href="#设置图片大小" class="headerlink" title="设置图片大小"></a>设置图片大小</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig = plt.figure(figsize=(<span class="number">20</span>,<span class="number">8</span>),dpi=<span class="number">80</span>)</span><br><span class="line">--&gt;figure图形图标的意思，在这里指的就是我们画的图</span><br><span class="line">--&gt;通过实例化一个fgure并且传递参数,能够在后台自动使用该fgure实例</span><br><span class="line">---&gt;在图像模糊的时候可以传入dpi参数,让图片更加清晰</span><br><span class="line">x = <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">26</span>,<span class="number">2</span>)</span><br><span class="line">y = [<span class="number">15</span> ,<span class="number">13</span>, <span class="number">14.5</span>,<span class="number">17</span>,<span class="number">20</span>, <span class="number">25</span> , <span class="number">26</span>,<span class="number">26</span> ,<span class="number">24</span>,<span class="number">22</span>, <span class="number">18</span> ,<span class="number">15</span>]</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.savefig(<span class="string">&quot;./sig_size.png&quot;</span>)-&gt;保存图片</span><br><span class="line">---&gt;可以保存为svg这种矢量图格式,放大不会有锯齿</span><br></pre></td></tr></table></figure><h4 id="调整X或者Y轴上的刻度"><a href="#调整X或者Y轴上的刻度" class="headerlink" title="调整X或者Y轴上的刻度"></a>调整X或者Y轴上的刻度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig = plt.figure(figsize=(<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line">x = <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">26</span>,<span class="number">2</span>)</span><br><span class="line">y = [<span class="number">15</span> , <span class="number">13</span> , <span class="number">14</span> ,<span class="number">5</span> , <span class="number">17</span> , <span class="number">20</span> , <span class="number">25</span> , <span class="number">26</span> ,<span class="number">26</span> , <span class="number">24</span>, <span class="number">22</span>, <span class="number">18</span> , <span class="number">15</span>]</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.xticks(x)</span><br><span class="line">-&gt;设置x的刻度</span><br><span class="line"><span class="comment">#plt.xticks(x[::27)</span></span><br><span class="line">-&gt;当刻度太密集时候使用列表的步长(间隔取值)来解决,matplotlib会自动帮我们对应</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">8</span>))</span><br><span class="line">x = <span class="built_in">range</span>(<span class="number">120</span>)</span><br><span class="line">random.seed(<span class="number">10</span>) <span class="comment">#设置随机种子，让不同时候随机的得到的结果都一样y = [random.uniform(20,35) for i in range(120)]</span></span><br><span class="line">plt.plot(x,y)</span><br><span class="line">x_ticks = [<span class="string">&quot;10点[&#125;分&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> x <span class="keyword">if</span> i&lt;<span class="number">60</span>]</span><br><span class="line">x_ticks += [<span class="string">&quot;11点[]分&quot;</span>,<span class="built_in">format</span>(i-<span class="number">60</span>) <span class="keyword">for</span> i <span class="keyword">in</span> x <span class="keyword">if</span> i&gt;<span class="number">60</span>]</span><br><span class="line">-&gt;设置x轴上的字符串的刻度</span><br><span class="line">plt.xticks(x[::<span class="number">5</span>],_x_ticks[::<span class="number">5</span>],rotation=<span class="number">90</span>)</span><br><span class="line">-&gt;让列表x中的数据和_x_tcks上的数据都传入,最终会在x轴上一一对应的显示出来</span><br><span class="line">&gt;两组数据的长度必须一样,否则不能完全覆盖整个轴</span><br><span class="line">&gt;使用列表的切片,每隔<span class="number">5</span>个选一个数据进行展示</span><br><span class="line">&gt;为了让字符串不会覆盖,使用rotation选项,让字符串旋转<span class="number">90</span>°显示</span><br></pre></td></tr></table></figure><p>matplotlib默认不支持中文字符，因为默认的英文字体无法显示汉字</p><p>查看linux&#x2F;mac下面支持的字体:</p><p>fc-list   查看支持的字体fc-list :lang&#x3D;zh 查看支持的中文(冒号前面有空格)</p><p>通过matplotlib.rc可以修改默认字体,具体方法参见源码(windows&#x2F;linux)</p><p>通过matplotlib 下的font_manager可以解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">impart matplotlib</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> font_manager</span><br><span class="line"><span class="comment">#这个字体设置为全局设置，只用在该处修改即可(windows和linux下有效</span></span><br><span class="line"><span class="comment"># fant = &#123;&#125;&#x27; family&#x27;:&#x27;microsoft Yahei&quot;</span></span><br><span class="line"><span class="comment">#&#x27;size&#x27;:&#x27;10&#x27;&#125;</span></span><br><span class="line"><span class="comment"># matplotlib.rc(&quot;font&quot;,**font)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置中文字体(指定具体的字体文件路径,然后在需要显示中文的地方添加fontproperties参数)</span></span><br><span class="line">my font = font manager,FontProperties(fname=<span class="string">&quot;/Svstem/Library/Fonts/pingFang,ttc</span></span><br><span class="line"><span class="string">plt.xticks(x[::5],x ticks[::5],rotation=90,fontproperties=my_font)</span></span><br></pre></td></tr></table></figure><h4 id="给图像添加描述信息"><a href="#给图像添加描述信息" class="headerlink" title="给图像添加描述信息"></a>给图像添加描述信息</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置中文字体my_font = font_manager,FontProperties(fname=&quot;/System/Library/Fonts/PingFang.ttc&quot;!</span></span><br><span class="line">plt.xticks(x[::<span class="number">5</span>],_x_ticks[::<span class="number">5</span>],rotation=<span class="number">90</span>,fontproperties=my_font)</span><br><span class="line">plt.xlabel(<span class="string">&quot;时间”,fontproperties=my_font) #设置x轴的label</span></span><br><span class="line"><span class="string">plt.ylabel(&quot;</span>温度(()<span class="string">&quot;,fontproperties=my_font) #设置y轴的label</span></span><br><span class="line"><span class="string">plt.title(&quot;</span><span class="number">10</span>点到<span class="number">12</span>点每分钟的时间变化情况<span class="string">&quot;,fontproperties=my_font) 设置title</span></span><br></pre></td></tr></table></figure><h2 id="matplotlib的简单使用"><a href="#matplotlib的简单使用" class="headerlink" title="matplotlib的简单使用"></a>matplotlib的简单使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(-1,1,50)</span><br><span class="line">y = 2**x</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.show</span><br></pre></td></tr></table></figure><h4 id="plt-figure"><a href="#plt-figure" class="headerlink" title="plt.figure"></a>plt.figure</h4><p>规定一个一个窗口 下面的所有的步骤都会在这个窗口进行显示</p><p>figure(num&#x3D;None, figsize&#x3D;None, dpi&#x3D;None, facecolor&#x3D;None, edgecolor&#x3D;None, frameon&#x3D;True)<br>num:图像编号或名称，数字为编号 ，字符串为名称<br>figsize:指定figure的宽和高，单位为英寸；<br>dpi参数指定绘图对象的分辨率，即每英寸多少个像素，缺省值为80 1英寸等于2.5cm,A4纸是 21*30cm的纸张<br>facecolor:背景颜色<br>edgecolor:边框颜色<br>frameon:是否显示边框</p><h3 id="坐标轴"><a href="#坐标轴" class="headerlink" title="坐标轴"></a>坐标轴</h3><h4 id="plt-xlim-left-right"><a href="#plt-xlim-left-right" class="headerlink" title="plt.xlim((left,right))"></a>plt.xlim((left,right))</h4><p>更换坐标轴的左右端</p><h4 id="plt-ytick-LIST-LIST"><a href="#plt-ytick-LIST-LIST" class="headerlink" title="plt.ytick(LIST,LIST)"></a>plt.ytick(LIST,LIST)</h4><p>在刻度上替换为对应范围的文字，第一个是刻度位置 第二个list是文字</p><p>如果需要插入一些数学符号需要r“$$”在此类编写 具体语法参考LaTeX</p><h4 id="ax-plt-gca"><a href="#ax-plt-gca" class="headerlink" title="ax &#x3D; plt.gca()"></a>ax &#x3D; plt.gca()</h4><p>gcs &#x3D; get current axis 获取轴，用来操作轴的属性和位置。</p><h4 id="ax-spines-“right”-set-color-“none”-设置边框颜色"><a href="#ax-spines-“right”-set-color-“none”-设置边框颜色" class="headerlink" title="ax.spines[“right”].set_color(“none”)#设置边框颜色"></a>ax.spines[“right”].set_color(“none”)#设置边框颜色</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ax = plt.gca()</span><br><span class="line">ax.spines[&quot;right&quot;].set_color(&quot;none&quot;)#设置边框颜色</span><br><span class="line"># ax.spines[&quot;left&quot;].set_color(&quot;none&quot;)</span><br><span class="line">ax.spines[&quot;top&quot;].set_color(&quot;none&quot;)</span><br><span class="line"># ax.spines[&quot;bottom&quot;].set_color(&quot;none&quot;)</span><br><span class="line">ax.xaxis.set_ticks_position(&quot;bottom&quot;)# 用哪一个坐标轴来代替xaxis</span><br><span class="line">ax.yaxis.set_ticks_position(&quot;left&quot;)</span><br><span class="line">ax.spines[&quot;left&quot;].set_position((&#x27;data&#x27;,250)) # 设置y坐标轴的位置</span><br><span class="line">ax.spines[&quot;bottom&quot;].set_position((&#x27;data&#x27;,8))# 设置x 坐标在轴的位置</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.plot(x**2,y)</span><br></pre></td></tr></table></figure><h3 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h3><p>在plt.plot的时候在可以添加label的的参数</p><p>之后plt.legend的时候会自动调用这个label生成图例</p><p>当然有时候我们不想要全部的图例这个时候可以给这个图例的添加返回值对象，达到对特定的线段显示图例的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l1, = plt.plot(x, y,label =&quot;asd&quot;)</span><br><span class="line">l2, = plt.plot(x**2,y,color=&quot;red&quot;,linewidth=1.0,linestyle=&quot;--&quot;,label =&quot;down&quot;)</span><br><span class="line">plt.legend(handles=[l1,l2,],loc=&quot;lower left&quot;) #显示图例</span><br></pre></td></tr></table></figure><p>需要注意的是如果要传入特定的线段对象的话返回值命名需要在后面加一个，用于解包</p><h4 id="plt-legend"><a href="#plt-legend" class="headerlink" title="plt.legend"></a>plt.legend</h4><p><em>plt.legend( )<em>中有</em>handles</em>、<em>labels</em>和<em>loc</em>三个参数，其中：</p><p><strong>handles</strong>需要传入你所画线条的<strong>实例对象</strong>，</p><p><strong>labels</strong>是图例的名称（能够覆盖在plt.plot( )中label参数值）</p><p><strong>loc</strong>代表了图例在整个坐标轴平面中的位置（一般选取’best’这个参数值）</p><p><em>loc &#x3D; ‘XXX’</em></p><p>这里的’XXX’代表了坐标面中的九个位置，例如loc &#x3D; ‘center’表示坐标平面中心位置，九种参数值及所对应位置如下图所示</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/v2-ebb05194b09240342c53b6590f3a43a5_1440w.webp" alt="img"></p><p><em><strong>loc &#x3D; (x, y)</strong></em></p><p>（x, y）表示图例左下角的位置，这是最灵活的一种放置图例的方法，慢慢调整，总会找到你想要的放置图例的位置</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="plt-scatter-x-y"><a href="#plt-scatter-x-y" class="headerlink" title="plt.scatter(x,y)"></a>plt.scatter(x,y)</h4><p>标注一个点</p><h4 id="plt-annotate"><a href="#plt-annotate" class="headerlink" title="plt.annotate()"></a>plt.annotate()</h4><p>plt.annotate()用于标注文字</p><h5 id="weight-设置字体线型"><a href="#weight-设置字体线型" class="headerlink" title="weight 设置字体线型"></a>weight 设置字体线型</h5><p>{‘ultralight’, ‘light’, ‘normal’, ‘regular’, ‘book’, ‘medium’, ‘roman’, ‘semibold’, ‘demibold’, ‘demi’, ‘bold’, ‘heavy’, ‘extra bold’, ‘black’}</p><h5 id="color-设置字体颜色"><a href="#color-设置字体颜色" class="headerlink" title="color 设置字体颜色"></a>color 设置字体颜色</h5><ul><li>{‘b’, ‘g’, ‘r’, ‘c’, ‘m’, ‘y’, ‘k’, ‘w’}</li><li>‘black’,’red’等</li><li>[0,1]之间的浮点型数据</li><li>RGB或者RGBA, 如: (0.1, 0.2, 0.5)、(0.1, 0.2, 0.5, 0.3)等</li></ul><h5 id="arrowprops-箭头参数-参数类型为字典dict"><a href="#arrowprops-箭头参数-参数类型为字典dict" class="headerlink" title="arrowprops 箭头参数,参数类型为字典dict"></a>arrowprops 箭头参数,参数类型为字典dict</h5><ul><li>width：箭头的宽度(以点为单位)</li><li>headwidth：箭头底部以点为单位的宽度</li><li>headlength：箭头的长度(以点为单位)</li><li>shrink：总长度的一部分，从两端“收缩”</li><li>facecolor：箭头颜色</li></ul><h5 id="bbox给标题增加外框："><a href="#bbox给标题增加外框：" class="headerlink" title="bbox给标题增加外框："></a>bbox给标题增加外框：</h5><ul><li>boxstyle：方框外形</li><li>facecolor：(简写fc)背景颜色</li><li>edgecolor：(简写ec)边框线条颜色</li><li>edgewidth：边框线条大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">11</span>,<span class="number">17</span>,<span class="number">16</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">21</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">22</span>,<span class="number">22</span>,<span class="number">23</span>]</span><br><span class="line">b = [<span class="number">26</span>,<span class="number">26</span>,<span class="number">28</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">17</span>,<span class="number">16</span>,<span class="number">19</span>,<span class="number">18</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">19</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">6</span>]</span><br><span class="line">plt.scatter(x,y)</span><br></pre></td></tr></table></figure><h2 id="绘制条形图"><a href="#绘制条形图" class="headerlink" title="绘制条形图"></a>绘制条形图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&quot;战狼2&quot;</span>,<span class="string">&quot;速度与激情8&quot;</span>,<span class="string">&quot;功夫瑜伽&quot;</span>,<span class="string">&quot;西游伏妖篇&quot;</span>,<span class="string">&quot;变形金刚5：最后的骑士&quot;</span>,<span class="string">&quot;摔跤吧！爸爸&quot;</span>,<span class="string">&quot;加勒比海盗5：死无对证&quot;</span>,<span class="string">&quot;金刚：骷髅岛&quot;</span>,<span class="string">&quot;极限特工：终极回归&quot;</span>,<span class="string">&quot;生化危机6：终章&quot;</span>,<span class="string">&quot;乘风破浪&quot;</span>,<span class="string">&quot;神偷奶爸3&quot;</span>,<span class="string">&quot;智取威虎山&quot;</span>,<span class="string">&quot;大闹天竺&quot;</span>,<span class="string">&quot;金刚狼3：殊死一战&quot;</span>,<span class="string">&quot;蜘蛛侠：英雄归来&quot;</span>,<span class="string">&quot;悟空传&quot;</span>,<span class="string">&quot;银河护卫队2&quot;</span>,<span class="string">&quot;情圣&quot;</span>,<span class="string">&quot;新木乃伊&quot;</span>,]</span><br><span class="line"></span><br><span class="line">b=[<span class="number">56.01</span>,<span class="number">26.94</span>,<span class="number">17.53</span>,<span class="number">16.49</span>,<span class="number">15.45</span>,<span class="number">12.96</span>,<span class="number">11.8</span>,<span class="number">11.61</span>,<span class="number">11.28</span>,<span class="number">11.12</span>,<span class="number">10.49</span>,<span class="number">10.3</span>,<span class="number">8.75</span>,<span class="number">7.55</span>,<span class="number">7.32</span>,<span class="number">6.99</span>,<span class="number">6.88</span>,<span class="number">6.86</span>,<span class="number">6.58</span>,<span class="number">6.23</span>] 单位:亿</span><br><span class="line">_x = <span class="built_in">range</span>(<span class="built_in">len</span>(a)</span><br><span class="line">_y = b</span><br><span class="line">plt.bar(_x,b,width=<span class="number">.2</span>,color=<span class="string">&quot;orange&quot;</span>)</span><br><span class="line">           -&gt;bar绘制条形图，只能接受含数字的可迭代对象</span><br><span class="line">           -&gt;width表示长条的宽度,默认<span class="number">0.8</span></span><br><span class="line">plt.xticks(_x,a,fontproperties=my_font,rotation=<span class="number">90</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20230720113446447.png" alt="image-20230720113446447"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">列表a中电影分别在2017-09-14(b_14), 2017-09-15(b_15), 2017-09-16(b_16)三天的票房,展示列表中电影本身的票房以及同其他电影的数据对比情况</span><br><span class="line"></span><br><span class="line">a = [&quot;猩球崛起3：终极之战&quot;,&quot;敦刻尔克&quot;,&quot;蜘蛛侠：英雄归来&quot;,&quot;战狼2&quot;]</span><br><span class="line">b_16 = [15746,312,4497,319]</span><br><span class="line">b_15 = [12357,156,2045,168]</span><br><span class="line">b_14 = [2358,399,2358,362]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.bar(_x，b_14，width=_bar_width,label=&quot;9月14&quot;)</span><br><span class="line">plt.bar([i + _bar_width for i in _x], b_15, width=_bar_width,label=&quot;g月15&quot;)</span><br><span class="line">plt.bar([i +bar_width * 2 for i in _x], b_16, width=_bar_width,label=&quot;9月16&quot;-&gt;为什么要这样做呢</span><br><span class="line">x_ticks = [i + _bar_width for i in _x]</span><br><span class="line">-&gt;为什么xticks要这样设置呢</span><br><span class="line">plt.xticks(_x ticks, a, fontproperties=my_font)</span><br></pre></td></tr></table></figure><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20230720113631209.png" alt="绘制直方图"></p><h2 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">131</span>,  <span class="number">98</span>, <span class="number">125</span>, <span class="number">131</span>, <span class="number">124</span>, <span class="number">139</span>, <span class="number">131</span>, <span class="number">117</span>, <span class="number">128</span>, <span class="number">108</span>, <span class="number">135</span>, <span class="number">138</span>, <span class="number">131</span>, <span class="number">102</span>, <span class="number">107</span>, <span class="number">114</span>, <span class="number">119</span>, <span class="number">128</span>, <span class="number">121</span>, <span class="number">142</span>, <span class="number">127</span>, <span class="number">130</span>, <span class="number">124</span>, <span class="number">101</span>, <span class="number">110</span>, <span class="number">116</span>, <span class="number">117</span>, <span class="number">110</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">115</span>,  <span class="number">99</span>, <span class="number">136</span>, <span class="number">126</span>, <span class="number">134</span>,  <span class="number">95</span>, <span class="number">138</span>, <span class="number">117</span>, <span class="number">111</span>,<span class="number">78</span>, <span class="number">132</span>, <span class="number">124</span>, <span class="number">113</span>, <span class="number">150</span>, <span class="number">110</span>, <span class="number">117</span>,  <span class="number">86</span>,  <span class="number">95</span>, <span class="number">144</span>, <span class="number">105</span>, <span class="number">126</span>, <span class="number">130</span>,<span class="number">126</span>, <span class="number">130</span>, <span class="number">126</span>, <span class="number">116</span>, <span class="number">123</span>, <span class="number">106</span>, <span class="number">112</span>, <span class="number">138</span>, <span class="number">123</span>,  <span class="number">86</span>, <span class="number">101</span>,  <span class="number">99</span>, <span class="number">136</span>,<span class="number">123</span>, <span class="number">117</span>, <span class="number">119</span>, <span class="number">105</span>, <span class="number">137</span>, <span class="number">123</span>, <span class="number">128</span>, <span class="number">125</span>, <span class="number">104</span>, <span class="number">109</span>, <span class="number">134</span>, <span class="number">125</span>, <span class="number">127</span>,<span class="number">105</span>, <span class="number">120</span>, <span class="number">107</span>, <span class="number">129</span>, <span class="number">116</span>, <span class="number">108</span>, <span class="number">132</span>, <span class="number">103</span>, <span class="number">136</span>, <span class="number">118</span>, <span class="number">102</span>, <span class="number">120</span>, <span class="number">114</span>,<span class="number">105</span>, <span class="number">115</span>, <span class="number">132</span>, <span class="number">145</span>, <span class="number">119</span>, <span class="number">121</span>, <span class="number">112</span>, <span class="number">139</span>, <span class="number">125</span>, <span class="number">138</span>, <span class="number">109</span>, <span class="number">132</span>, <span class="number">134</span>,<span class="number">156</span>, <span class="number">106</span>, <span class="number">117</span>, <span class="number">127</span>, <span class="number">144</span>, <span class="number">139</span>, <span class="number">139</span>, <span class="number">119</span>, <span class="number">140</span>,  <span class="number">83</span>, <span class="number">110</span>, <span class="number">102</span>,<span class="number">123</span>,<span class="number">107</span>, <span class="number">143</span>, <span class="number">115</span>, <span class="number">136</span>, <span class="number">118</span>, <span class="number">139</span>, <span class="number">123</span>, <span class="number">112</span>, <span class="number">118</span>, <span class="number">125</span>, <span class="number">109</span>, <span class="number">119</span>, <span class="number">133</span>,<span class="number">112</span>, <span class="number">114</span>, <span class="number">122</span>, <span class="number">109</span>, <span class="number">106</span>, <span class="number">123</span>, <span class="number">116</span>, <span class="number">131</span>, <span class="number">127</span>, <span class="number">115</span>, <span class="number">118</span>, <span class="number">112</span>, <span class="number">135</span>,<span class="number">115</span>, <span class="number">146</span>, <span class="number">137</span>, <span class="number">116</span>, <span class="number">103</span>, <span class="number">144</span>,  <span class="number">83</span>, <span class="number">123</span>, <span class="number">111</span>, <span class="number">110</span>, <span class="number">111</span>, <span class="number">100</span>, <span class="number">154</span>,<span class="number">136</span>, <span class="number">100</span>, <span class="number">118</span>, <span class="number">119</span>, <span class="number">133</span>, <span class="number">134</span>, <span class="number">106</span>, <span class="number">129</span>, <span class="number">126</span>, <span class="number">110</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">141</span>,<span class="number">120</span>, <span class="number">117</span>, <span class="number">106</span>, <span class="number">149</span>, <span class="number">122</span>, <span class="number">122</span>, <span class="number">110</span>, <span class="number">118</span>, <span class="number">127</span>, <span class="number">121</span>, <span class="number">114</span>, <span class="number">125</span>, <span class="number">126</span>,<span class="number">114</span>, <span class="number">140</span>, <span class="number">103</span>, <span class="number">130</span>, <span class="number">141</span>, <span class="number">117</span>, <span class="number">106</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">114</span>, <span class="number">133</span>, <span class="number">137</span>,  <span class="number">92</span>,<span class="number">121</span>, <span class="number">112</span>, <span class="number">146</span>,  <span class="number">97</span>, <span class="number">137</span>, <span class="number">105</span>,  <span class="number">98</span>, <span class="number">117</span>, <span class="number">112</span>,  <span class="number">81</span>,  <span class="number">97</span>, <span class="number">139</span>, <span class="number">113</span>,<span class="number">134</span>, <span class="number">106</span>, <span class="number">144</span>, <span class="number">110</span>, <span class="number">137</span>, <span class="number">137</span>, <span class="number">111</span>, <span class="number">104</span>, <span class="number">117</span>, <span class="number">100</span>, <span class="number">111</span>, <span class="number">101</span>, <span class="number">110</span>,<span class="number">105</span>, <span class="number">129</span>, <span class="number">137</span>, <span class="number">112</span>, <span class="number">120</span>, <span class="number">113</span>, <span class="number">133</span>, <span class="number">112</span>,  <span class="number">83</span>,  <span class="number">94</span>, <span class="number">146</span>, <span class="number">133</span>, <span class="number">101</span>,<span class="number">131</span>, <span class="number">116</span>, <span class="number">111</span>,  <span class="number">84</span>, <span class="number">137</span>, <span class="number">115</span>, <span class="number">122</span>, <span class="number">106</span>, <span class="number">144</span>, <span class="number">109</span>, <span class="number">123</span>, <span class="number">116</span>, <span class="number">111</span>,<span class="number">111</span>, <span class="number">133</span>, <span class="number">150</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>组数要适当,太少会有较大的统计误差,大多规律不明显</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20230720113900073.png" alt="image-20230720113900073"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin_width = <span class="number">3</span> <span class="comment">#设置组距为3num_bins = int((max(a)-min(a))/bin_width) #分为多少组</span></span><br><span class="line">plt.hist(a, num_bins)-&gt;传入需要统计的数据，以及组数即可<span class="comment">#plt.hist(a,[min(a)+ixbin_widthforin range(num bins)-&gt;可以传入一个列表,长度为组数,值为分组依据,当组距不均匀的时候使用</span></span><br><span class="line"><span class="comment"># plt.hist(a, num_bins,normed=1</span></span><br><span class="line">-&gt;normed:<span class="built_in">bool</span> 是否绘制频率分布直方图,默认为频数直方图plt.xticks(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">min</span>(a),<span class="built_in">max</span>(a)[::bin_width],rotation=<span class="number">45</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>，linestyle =<span class="string">&quot;-.&quot;</span>,alpha=<span class="number">0.5</span>) <span class="comment">#显示网格,alpha为透明度</span></span><br></pre></td></tr></table></figure><h2 id="更多图像样式"><a href="#更多图像样式" class="headerlink" title="更多图像样式"></a><a href="http://matplotlib.org/gallery/index.html">更多图像样式</a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> matplotlib </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uWSGI学习</title>
      <link href="/2024/05/08/uWsig%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/05/08/uWsig%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="uWSGI学习"><a href="#uWSGI学习" class="headerlink" title="uWSGI学习"></a>uWSGI学习</h1><h2 id="什么是uwsgi"><a href="#什么是uwsgi" class="headerlink" title="什么是uwsgi"></a>什么是uwsgi</h2><p>uWSGI是一个Python Web服务器,它实现了WSGI协议、uwsgi、http等协议，常在部署Django或Flask开发的Python Web项目时使用，作为连接Nginx与应用程序之间的桥梁。</p><h2 id="为什么需要uWSGI"><a href="#为什么需要uWSGI" class="headerlink" title="为什么需要uWSGI?"></a>为什么需要uWSGI?</h2><p>在生产环境中部署Python Web项目时，uWSGI负责处理Nginx转发的动态请求，并与我们的Python应用程序沟通，同时将应用程序返回的响应数据传递给Nginx。</p><p>这个时候你要问了，Nginx本身就是Web服务器，我们为什么还需要uWSGI这个Web服务器呢? Django不是自带runserver服务器?Flask不是自带Werkzeug吗? 答案是Nginx处理静态文件非常优秀，却不能直接与我们的Python Web应用程序进行交互。Django和Flask本身是Web框架，并不是Web服务器，它们自带的runserver和Werkzeug也仅仅用于开发测试环境，生产环境中处理并发的能力太弱。</p><h4 id="django"><a href="#django" class="headerlink" title="django"></a>django</h4><p>用原生django的server做处理的表现是最烂的，在10000次请求的情况下brokenpipe的几率极高，只有1400次请求被处理，成功率只有14%。</p><h4 id="django-nginx"><a href="#django-nginx" class="headerlink" title="django + nginx"></a><strong>django + nginx</strong></h4><p>搭上了nginx做反向代理，也使的脆弱的django服务器的情况有所缓解，但成功率仍然不高（10000次请求中有3684个请求被处理）。</p><p><strong>uwsgi + nginx</strong></p><p>uwsgi是性能极高的一个由C编写的服务器，它使用uwsgi协议，这次让它配合nginx处理django的request，参数为4进程+2线程，性能立即直线上升，处理请求的成功率也基本在90%左右，不过我在测试时遇到了一个坑，就是uwsgi在处理请求的时候发送了队列溢出的问题，因为当前测试设置的并发数为每秒1000次并发，而uwsgi的处理队列容量默认为100，导致处理请求的时间加长，而这个问题则可以通过修改somaxcon的大小解决，总的来说，使用uwsgi+nginx是一个理想的选择。</p><p><strong>请求数-QPS</strong>（Query Per Second）&#x2F;RPS（Request Per Second）</p><p>请求数有2个缩写，可以叫QPS也可以叫RPS。<strong>单位是每秒多少请求</strong>。Query&#x3D;查询，也相当于请求。请求数指的是客户端在建立完连接后，向http服务发出<strong>GET&#x2F;POST&#x2F;HEAD</strong>数据包，服务器返回了请求结果后有两种情况：</p><p>为了解决Web 服务器与应用程序之间的交互问题，就出现了Web 服务器与应用程序之间交互的规范。最早出现的是CGI,后来又出现了改进 CGI 性能的FasgCGI，Java 专用的 Servlet 规范。在Python领域，最知名的就是WSGI规范了。</p><p>WSGI 全称是 Web Server Gateway Interface，也就是 Web 服务器网关接口，是一个web服务器（如uWSGI服务器）与web应用（如用Django或Flask框架写的程序）通信的一种规范。WSGI包含了很多自有协议，其中一个是uwsgi，它用于定义传输信息的类型。</p><p>现在你清楚uWSGI, WSGI和uwsgi的区别了吗?</p><ul><li>uWSGI是Python Web服务器，实现了WSGI通信规范和uwsgi协议；</li><li>WSGI全名Web Server Gateway Interface，是一个Web服务器（如uWSGI服务器）与web应用（如用Django或Flask框架写的程序）通信的一种规范；</li><li>uwsgi是WSGI通信规范中的一种自有协议。</li></ul><p>如果你已经有了一个现成的Django项目，你可以使用如下命令启动Web服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ uwsgi --http :8000 --module myproject.wsgi</span><br></pre></td></tr></table></figure><p>在生产环境中我们通常不会使用命令行启动Python Web项目，而是通常编辑好uWSGI配置文件<code>uwsgi.ini</code>, 然后使用如下命令启动Python Web项目。</p><h2 id="配置uwsgi"><a href="#配置uwsgi" class="headerlink" title="配置uwsgi"></a>配置uwsgi</h2><h3 id="检查是否安装uwsgi"><a href="#检查是否安装uwsgi" class="headerlink" title="检查是否安装uwsgi"></a><strong>检查是否安装uwsgi</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PYTHON</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">已安装会显示版本号</span></span><br><span class="line">uwsgi --version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">未安装使用 pip 安装一下</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意要在虚拟环境中安装</span></span><br><span class="line">pip install uwsgi</span><br></pre></td></tr></table></figure><h2 id="uWSGI-常用命令"><a href="#uWSGI-常用命令" class="headerlink" title="uWSGI 常用命令"></a>uWSGI 常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动uWSGI服务器</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">uwsgi --ini uwsgi.ini</span></span><br><span class="line">  uwsgi -d --ini uwsgi.ini</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台运行服务器</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启uWSGI服务器</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo service uwsgi restart</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有uWSGI进程</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps aux | grep uwsgi</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止所有uWSGI进程</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo pkill -f uwsgi -9</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动： ini 为uwsgi配置文件</span></span><br><span class="line">uwsgi --ini uwsgi.ini</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启： pid 为uwsgi启动后保存uwsgi启动进程的文件</span></span><br><span class="line">uwsgi --reload uwsgi.pid</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止：</span> </span><br><span class="line">uwsgi --stop uwsgi.pid</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看uwsgi是否正常启动</span></span><br><span class="line">ps aux | grep uwsgi</span><br></pre></td></tr></table></figure><h2 id="uWSGI常用配置"><a href="#uWSGI常用配置" class="headerlink" title="uWSGI常用配置"></a>uWSGI常用配置</h2><p>uWSGI常用配置选项如下所示，稍加修改(项目名，项目根目录)即可部署大部分Python Web项目。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">uid=www-data # Ubuntu系统下默认用户名</span><br><span class="line">gid=www-data # Ubuntu系统下默认用户组</span><br><span class="line">project=mysite1  # 项目名</span><br><span class="line">base = /home/user1 # 项目根目录</span><br><span class="line"></span><br><span class="line">home = %(base)/Env/%(project) # 设置项目虚拟环境,Docker部署时不需要</span><br><span class="line">chdir=%(base)/%(project) # 设置工作目录</span><br><span class="line">module=%(project).wsgi:application # wsgi文件位置</span><br><span class="line"></span><br><span class="line">master=True # 主进程</span><br><span class="line">processes=2 # 同时进行的进程数，一般</span><br><span class="line"></span><br><span class="line"># 选项1, 使用unix socket与nginx通信，仅限于uwsgi和nginx在同一主机上情形</span><br><span class="line"># Nginx配置中uwsgi_pass应指向同一socket文件</span><br><span class="line">socket=/run/uwsgi/%(project).sock</span><br><span class="line"></span><br><span class="line"># 选项2，使用TCP socket与nginx通信</span><br><span class="line"># Nginx配置中uwsgi_pass应指向uWSGI服务器IP和端口</span><br><span class="line"># socket=0.0.0.0:8000 或则 socket=:8000</span><br><span class="line"></span><br><span class="line"># 选项3，使用http协议与nginx通信</span><br><span class="line"># Nginx配置中proxy_pass应指向uWSGI服务器一IP和端口</span><br><span class="line"># http=0.0.0.0:8000 </span><br><span class="line"></span><br><span class="line"># socket权限设置</span><br><span class="line">chown-socket=%(uid):www-data</span><br><span class="line">chmod-socket=664</span><br><span class="line"></span><br><span class="line"># 进程文件</span><br><span class="line">pidfile=/tmp/%(project)-master.pid</span><br><span class="line"></span><br><span class="line"># 以后台守护进程运行，并将log日志存于temp文件夹。</span><br><span class="line">daemonize=/var/log/uwsgi/%(project).log </span><br><span class="line"></span><br><span class="line"># 服务停止时，自动移除unix socket和pid文件</span><br><span class="line">vacuum=True</span><br><span class="line"></span><br><span class="line"># 为每个工作进程设置请求数的上限。当处理的请求总数超过这个量，进程回收重启。</span><br><span class="line">max-requests=5000</span><br><span class="line"></span><br><span class="line"># 当一个请求花费的时间超过这个时间，那么这个请求都会被丢弃。</span><br><span class="line">harakiri=60</span><br><span class="line"></span><br><span class="line">#当一个请求被harakiri杀掉会，会输出一条日志</span><br><span class="line">harakiri-verbose=true</span><br><span class="line"></span><br><span class="line"># uWsgi默认的buffersize为4096，如果请求数据超过这个量会报错。这里设置为64k</span><br><span class="line">buffer-size=65536</span><br><span class="line"></span><br><span class="line"># 如果http请求体的大小超过指定的限制，打开http body缓冲，这里为64k</span><br><span class="line">post-buffering=65536</span><br><span class="line"></span><br><span class="line">#开启内存使用情况报告</span><br><span class="line">memory-report=true</span><br><span class="line"></span><br><span class="line">#设置平滑的重启（直到处理完接收到的请求）的长等待时间(秒)</span><br><span class="line">reload-mercy=10</span><br><span class="line"></span><br><span class="line">#设置工作进程使用虚拟内存超过多少MB就回收重启</span><br><span class="line">reload-on-as=1024</span><br></pre></td></tr></table></figure><p>注意：uWSGI和Nginx之间有多种通信方式, unix socket，http-socket和http。Nginx的配置必需与uwsgi配置保持一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 选项1, 使用unix socket与nginx通信</span><br><span class="line"># 仅限于uwsgi和nginx在同一主机上情形</span><br><span class="line"># Nginx配置中uwsgi_pass应指向同一socket文件地址</span><br><span class="line">socket=/run/uwsgi/%(project).sock</span><br><span class="line"></span><br><span class="line"># 选项2，使用TCP socket与nginx通信</span><br><span class="line"># Nginx配置中uwsgi_pass应指向uWSGI服务器IP和端口</span><br><span class="line">socket==0.0.0.0:8000 或则 socket=:8000</span><br><span class="line"></span><br><span class="line"># 选项3，使用http协议与nginx通信</span><br><span class="line"># Nginx配置中proxy_pass应指向uWSGI服务器IP和端口</span><br><span class="line">http==0.0.0.0:8000 </span><br></pre></td></tr></table></figure><p>如果你的nginx与uwsgi在同一台服务器上，优先使用本地机器的unix socket进行通信，这样速度更快。此时nginx的配置文件如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;     </span><br><span class="line">    include /etc/nginx/uwsgi_params;</span><br><span class="line">    uwsgi_pass unix:/run/uwsgi/django_test1.sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果nginx与uwsgi不在同一台服务器上，两者使用TCP socket通信，nginx可以使用如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;     </span><br><span class="line">    include /etc/nginx/uwsgi_params;</span><br><span class="line">    uwsgi_pass uWSGI_SERVER_IP:8000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果nginx与uwsgi不在同一台服务器上，两者使用http协议进行通信，nginx配置应修改如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;     </span><br><span class="line">    # 注意：proxy_pass后面http必不可少哦！</span><br><span class="line">    proxy_pass http://uWSGI_SERVER_IP:8000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 运维 </tag>
            
            <tag> uWSGI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter_Notebook使用技巧</title>
      <link href="/2024/05/08/Jupyter-Notebook%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2024/05/08/Jupyter-Notebook%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了更加方便快捷的使用Jupyter Notebook，本文将会介绍一些相关的使用技巧。</p><h2 id="相关技巧"><a href="#相关技巧" class="headerlink" title="相关技巧"></a>相关技巧</h2><h3 id="使用问号查看对象的相关信息"><a href="#使用问号查看对象的相关信息" class="headerlink" title="使用问号查看对象的相关信息"></a>使用问号查看对象的相关信息</h3><p>对于代码中的所有对象，包括：变量、函数、方法、模块、等等，可以在某个对象的前面或后面添加一个?，以查看该对象的相关信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">aaa</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?aaa</span><br></pre></td></tr></table></figure><p>效果如下图：</p><p><img src="https://gcore.jsdelivr.net/gh/CNhuazhu/Image/%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A11.png" alt="img"></p><p>对于我们自定义的函数，可以在函数名的前面或后面添加两个?，这样，在显示出来的相关信息中会包含函数的源代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">aaa</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaa??</span><br></pre></td></tr></table></figure><p>效果如下图：</p><p><img src="https://gcore.jsdelivr.net/gh/CNhuazhu/Image/%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A12.png" alt="img"></p><h3 id="使用叹号执行Shell命令"><a href="#使用叹号执行Shell命令" class="headerlink" title="使用叹号执行Shell命令"></a>使用叹号执行Shell命令</h3><p>在使用Jupyter Notebook编写代码时，只需要在Shell命令前添加一个!，就可以在notebook中执行Shell命令，完全不用来回切换。</p><p>举例：查看当前本机网络状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!ipconfig</span><br></pre></td></tr></table></figure><p>效果如下图：</p><p><img src="https://gcore.jsdelivr.net/gh/CNhuazhu/Image/shell%E5%91%BD%E4%BB%A4.png" alt="img"></p><p>除了执行Shell命令之外，还可以将执行结果赋值给Python变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = !ipconfig</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br></pre></td></tr></table></figure><h3 id="关于输出"><a href="#关于输出" class="headerlink" title="关于输出"></a>关于输出</h3><p>在notebook中运行单元格中的代码时，在默认情况下，单元格中最后一行的值会被自动输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def aaa():</span><br><span class="line">print(&#x27;Hello World&#x27;)</span><br><span class="line">18</span><br></pre></td></tr></table></figure><p>输出效果如下图：</p><p><img src="https://gcore.jsdelivr.net/gh/CNhuazhu/Image/%E8%BE%93%E5%87%BA1.png" alt="img"></p><p>如果不想自动输出单元格中最后一行的值，可以在最后一行的行尾添加一个分号;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">aaa</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line"><span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>输出效果如下图：</p><p><img src="https://gcore.jsdelivr.net/gh/CNhuazhu/Image/%E8%BE%93%E5%87%BA1.png" alt="img"></p><p>在当前notebook中，如果希望单元格中每一行的值都被自动输出,可添加以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">&#x27;all&#x27;</span></span><br></pre></td></tr></table></figure><p>输出效果如下图：</p><p><img src="https://gcore.jsdelivr.net/gh/CNhuazhu/Image/%E8%BE%93%E5%87%BA3.png" alt="img"></p><p>如果希望在所有的notebook中都自动输出单元格中每一行的值，可以修改或创建ipython_config.py配置文件。</p><p>文件路径：</p><ul><li><p>Windows：C:\Users\用户名.ipython&#x2F;profile_default&#x2F;ipython_config.py</p></li><li><p>MacOS：&#x2F;Users&#x2F;用户名&#x2F;.ipython&#x2F;profile_default&#x2F;ipython_config.py</p></li><li><p>Linux：&#x2F;home&#x2F;用户名&#x2F;.ipython&#x2F;profile_default&#x2F;ipython_config.py</p></li></ul><p>打开配置文件添加以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = get_config()</span><br><span class="line">c.InteractiveShell.ast_node_interactivity = &quot;all&quot;</span><br></pre></td></tr></table></figure><h2 id="跨单元格编码"><a href="#跨单元格编码" class="headerlink" title="跨单元格编码"></a>跨单元格编码</h2><p>需要注意的是，在notebook中：</p><ul><li><p>前面运行的单元格会将相关变量保存到内存中，从而后面运行的单元格可以继续使用这些变量</p></li><li><p>关闭notebook的页面后，内存中保存的变量不会丢失</p></li><li><p>如果当前notebookShutdown或Restart了，那么内存中保存的所有变量都会丢失</p></li></ul><p>建议：按照单元格从上到下的顺序编写代码并依次运行代码，否则，不仅可读性不好，而且容易出错。</p><h2 id="支持Markdown语法"><a href="#支持Markdown语法" class="headerlink" title="支持Markdown语法"></a>支持Markdown语法</h2><p>Jupyter Notebook支持Markdown语法，在工具栏的下拉选项中将单元格调整为Markdown即可。</p><p>关于Markdown的相关介绍可以查看文章《Markdown语法》</p><p>这里提醒一点，在插入图片时，可以直接点击菜单栏中的Edit，在打开的选项中点击Insert Image，这种操作方式优点是：将图片和notebook绑定在一起，在对notebook进行移动或其他操作时不用单独对图片进行处理；缺点是：notebook文件会变大，不能控制图片尺寸。</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>在notebook中有两种单元格，分别为：</p><p>Code单元格：用来编写代码<br>Markdown单元格：用来将纯文本格式化为富文本<br>每种单元格都有两种模式，分别为：</p><p>编辑模式：按Esc键或者点击单元格的外部，都可以切换到命令模式<br>命令模式：按Enter键或者点击单元格的内部，都可以切换到编辑模式（对于运行之后的Markdown单元格，要双击单元格的内部，才能切换到编辑模式）<br>编辑模式下的快捷键：</p><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Tab</td><td>增加缩进（4个空格）、代码自动补全</td></tr><tr><td>Shift+Tab</td><td>减少缩进（4个空格）、查看对象的相关信息</td></tr><tr><td>Ctrl+A</td><td>全选</td></tr><tr><td>Ctrl+Z</td><td>撤销</td></tr><tr><td>Ctrl+Y</td><td>恢复</td></tr><tr><td>Ctrl+&#x2F;</td><td>注释、取消注释</td></tr><tr><td>Ctrl+D</td><td>删除行</td></tr><tr><td>Ctrl+Home</td><td>跳转到单元格的开始处</td></tr><tr><td>Ctrl+End</td><td>退出编辑模式并进入命令模式</td></tr><tr><td>Esc</td><td>保存并更新记录点文件</td></tr><tr><td>Ctrl+S</td><td>向上移动光标</td></tr><tr><td>↑</td><td>向下移动光标</td></tr><tr><td>↓</td><td>运行当前单元格</td></tr><tr><td>Ctrl+Enter</td><td>运行当前单元格，并选中下方的单元格（如果下方没有单元格，则在下方自动插入一个单元格并选中）</td></tr><tr><td>Shift+Enter</td><td>运行当前单元格，并选中下方的单元格（如果下方没有单元格，则在下方自动插入一个单元格并选中）</td></tr><tr><td>Alt+Enter</td><td>运行当前单元格，在下方自动插入一个单元格并选中</td></tr><tr><td></td><td></td></tr></tbody></table><p>命令模式下的快捷键：</p><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>↑</td><td>选中上方的单元格</td></tr><tr><td>↓</td><td>选中下方的单元格</td></tr><tr><td>Shift+↑</td><td>扩展选中上方的单元格</td></tr><tr><td>Shift+↓</td><td>扩展选中下方的单元格</td></tr><tr><td>A</td><td>在上方插入一个单元格</td></tr><tr><td>B</td><td>在下方插入一个单元格</td></tr><tr><td>M</td><td>将Code单元格转换为Markdown单元格</td></tr><tr><td>Y</td><td>将Markdown单元格转换为Code单元格</td></tr><tr><td>S</td><td>保存并更新记录点文件</td></tr><tr><td>D</td><td>连按两次D删除选中的单元格</td></tr><tr><td>Z</td><td>撤销对单元格的删除</td></tr><tr><td>X</td><td>剪切选中的单元格</td></tr><tr><td>C</td><td>拷贝选中的单元格</td></tr><tr><td>F</td><td>查找并替换</td></tr><tr><td>V</td><td>在下方粘贴单元格</td></tr><tr><td>Shift+V</td><td>在上方粘贴单元格</td></tr><tr><td>Enter</td><td>退出命令模式并进入编辑模式</td></tr><tr><td>Ctrl+Enter</td><td>运行选中的单元格</td></tr><tr><td>Shift+Enter</td><td>运行选中的单元格，并选中下方的单元格（如果下方没有单元格，则在下方自动插入一个单元格并选中）</td></tr><tr><td>Alt+Enter</td><td>运行选中的单元格，在下方自动插入一个单元格并选中</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> jupyterNotebook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用于讲话者视听追踪，基于自监督学习的多模态感知注意力网络——论文阅读</title>
      <link href="/2024/05/08/%E7%94%A8%E4%BA%8E%E8%AE%B2%E8%AF%9D%E8%80%85%E8%A7%86%E5%90%AC%E8%BF%BD%E8%B8%AA%EF%BC%8C%E5%9F%BA%E4%BA%8E%E8%87%AA%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%A4%9A%E6%A8%A1%E6%80%81%E6%84%9F%E7%9F%A5%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
      <url>/2024/05/08/%E7%94%A8%E4%BA%8E%E8%AE%B2%E8%AF%9D%E8%80%85%E8%A7%86%E5%90%AC%E8%BF%BD%E8%B8%AA%EF%BC%8C%E5%9F%BA%E4%BA%8E%E8%87%AA%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%A4%9A%E6%A8%A1%E6%80%81%E6%84%9F%E7%9F%A5%E6%B3%A8%E6%84%8F%E5%8A%9B%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1.摘要"></a>1.摘要</h2><h3 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h3><p>端到端模型：输入和输出之间没有中间步骤或阶段。端到端模型直接从原始输入数据映射到最终输出结果，没有人为设计的特征提取，中间表示或者预处理步骤。</p><p>异构信号：在某一信号环境中具有不同特性和属性的信号，这些信号可以是不同来源、不同类型，不同模态的信号，它们具有不同的物理特性，频谱特性，时域特性等。在图像处理或音频处理中，可能需要处理来自不同来源或不同类型的信号，例如同时处理彩色图像的RGB通道，或者处理来自不同麦克风的音频信号。</p><p>多模态信息互补性：多模态研究是指研究不同类型的数据融合的问题。模型从多种信息源获取多种模态的数据（例如语音，文字，图片等）之间的互相补充和增强关系，从而提高整体信息的丰富程度，准确性，鲁棒性。</p><p>时空全局相关域：是一种用于分析时间序列数据的空间-时间全局相干场。用于描述数据中的空间和时间相关性的方法，常用于cv等领域。可理解为对时间序列数据进行空间域和时间域的联合分析，获得数据的时序结构以及时序变化规律。通过计算坐标系中各点的空间相干性和时间相干性，获得全局的时空相干性。在本文中涉及到对视频的分析，使用stGCF推测主要目的是通过分析不同时间点和空间位置上的像素关系，提取位置信息，实现对声源位置的分析和估计。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>作者团队提出了一个用于讲话者的视听追踪，基于自监督学习的多模态感知注意力网络。它基于时空全局相关域(stGCF)，采用相机模型将声学线索映射到与视觉线索一致的定位空间。接着使用了一个多模态感知注意力网络来推算出感知衡量，感知权重适用于衡量受到噪声干扰的间歇性和视频流的可靠性和有效性。通过利用多模态信息的互补性和一致性，作者团队还提出了一种独特的跨模态自监督学习机制来对声音和视觉观察的置信度进行建模。上述的多模态感知追踪模型在不利条件下实现了追踪的鲁棒性，且优于最先进的前沿算法。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="概念解释-1"><a href="#概念解释-1" class="headerlink" title="概念解释"></a>概念解释</h3><p>似然函数：似然函数表示在已知观测数据的情况下， 一个概率分布模型函数的参数取值可能性。</p><p>似然计算：计算给定参数值下观测数据的可能性，也就是计算似然函数值。</p><p>概率生成模型：是一种机器学习模型，用于对数据生成的概率分布进行建模。它们被设计用于描述观测数据与潜在变量之间的关系，常用于生成新的数据样本，或者用于推断潜在变量的值。</p><p>高斯系统：以高斯分布(正态分布)为基础的系统或模型。高斯分布是统计学中一种常见的概率分布。在信号处理领域，许多信号和噪声的分布都可以近似为高斯分布，因此高斯系统常用于信号滤波、降噪和特征提取等任务。</p><p>粒子：粒子滤波中使用的一组随机样本，系统的状态被表示为一组粒子，每个粒子代表了系统可能的状态。</p><p>生成算法：一类用于生成复合某种规则或者约束条件的数据、图像、文本或其他类型的信息。这些算法通常是基于概率模型或规则系统设计，旨在模拟或生成复合特定分布或结构的数据。</p><p>多模态的冗余性：不同模态的数据可能包含相似的信息，即冗余信息。虽然冗余信息可能会增加计算成本，但也可以提高系统的鲁棒性。当一个模态的数据不完整或不可靠时，其他模态的信息可以弥补其不足，从而提高整个系统的性能。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>声源识别问题是智能系统进行行为分析和人际交互的基础任务。通过对人对声源的多模态感知可知，视听线索的整合更有利于从其中获得补充性线索。与单模态相比，视听信号的互补性对提高追踪准确性和鲁棒性是有贡献的，特别是当处理目标遮挡，摄像机视觉受限，光照变化以及房间混响等复杂情景。除此之外多模态融合相较于单模态线索缺失或两种模态都无法单独提供可靠观测时，多模态融合显示出明显的优势。所以提出一种可以融合异构信号并且可以处理间歇性噪声试听数据的多模态追踪方法是至关重要的。</p><p>现如今主要的追踪方法就是概率生成模型，因为它们处理多模态信息的能力。最具代表性的方法是粒子滤波(PF)。无论是传统的粒子滤波方法还是其变形，都倾向于使用单一模态的检测结果来辅助其他模态以获得更准确的观测值，忽略了充分利用视听结合的互补性和冗余性。目前存在的视听追踪算法都适用生成模型，但是其很难适应目标外表的随机性，复杂性变化。基于色彩直方图和欧式距离的似然计算容易受到观测噪声干扰，限制了信息融合的似然性能。</p><p>作者团队使用注意力机制来测量多模态的置信度，该置信度决定了融合算法的有效性。引入注意力机制不仅整合了数据，而且通过估计多种信号来源的可靠性并基于可靠性对各个信息员获取的证据进行加权（较可靠的信息源提供的证据通常会被赋予更高的权重）。</p><p>本篇文章主要有三个突出贡献：</p><ol><li>提出一种具有创新性的跟踪体系——多模态感知跟踪器，以及一种用来估计多模态数据观测结果的置信度和实用性。</li><li>一个创新性的声学图，stGCF，通过相机模型在升学和视觉定位之间建立起关系映射。由于多模态数据的互补性和一致性，提出了一种新的跨模态自监督学习机制。</li><li>在基本数据集和遮挡数据集上取得了优异的结果证明了该方法的鲁棒性和优异性。</li></ol><h2 id="提出方法"><a href="#提出方法" class="headerlink" title="提出方法"></a>提出方法</h2><p>MPT的总体框架组成为：视听测量，多模态感知注意网络，跨模态自监督学习和基于PF的多模式跟踪器。</p><p><img src="https://typorazkr------------image.oss-cn-beijing.aliyuncs.com/test/20240421204506.jpg" alt="20240421204506"></p><h3 id="视听测量"><a href="#视听测量" class="headerlink" title="视听测量"></a>视听测量</h3><h4 id="听觉测量"><a href="#听觉测量" class="headerlink" title="听觉测量"></a>听觉测量</h4><p>通过视听测量可以从视觉帧和听觉信号中获得相应的线索。将听觉线索映射到与视觉线索相同的定位空间，以在相同的空间集成多模态线索。<br>$$<br>r_{\omiga}^{GCF}(t,p) &#x3D; \frac{M}_{1}<br>$$<br><img src="https://typorazkr------------image.oss-cn-beijing.aliyuncs.com/test/%E6%88%AA%E5%B1%8F2024-04-08%2013.04.06.png" alt="截屏2024-04-08 13.04.06"></p><ul><li>𝑟Ω𝑃𝐻𝐴𝑇是麦克风对(i,k)的GCC-PHAT结果，它显示了一个突出的峰值，𝜏代表了实际的TDOA</li><li>𝜏𝑖𝑘(𝑝)指的是从既定点p到麦克风对(i,k)的理论时延。</li><li>对于一个由M个麦克风对组成的集合Ω，GCF值被定义为属于Ω的每个麦克风对的GCC-PHAT值的平均值.</li></ul><p>给定一个带有潜在声源位置的空间网格，GCF值代表了在每一点存在声源的可能性。</p><p>构建空间网格：</p><ul><li>利用针孔相机模型将2D图片平面上的点映射到3D世界坐标系中一系列不同深度的3D点，这里的深度指的是从3D点到相机光学中心的不同垂直距离。</li></ul><p>假设具有d个深度的集合D&#x3D;{Dk, k&#x3D;1,…,d}，给定一个深度Dk，图片到3D投影过程公式化为：</p><ul><li>𝑝𝑖𝑗𝑘3𝑑&#x3D;Φ(𝑝𝑖𝑗2𝑑;𝐷𝑘)</li><li>Φ代表投影运算符，i和j是点的垂直坐标和水平坐标。P2d被投影到不同深度的多重平面上，</li><li><img src="https://typorazkr------------image.oss-cn-beijing.aliyuncs.com/test/2024-04-08%2020.50.33.png" alt="2024-04-08 20.50.33"></li><li>P3dk是深度为Dk的平面。</li></ul><p>从P3dk导出的GCF功率图是</p><ul><li><img src="https://typorazkr------------image.oss-cn-beijing.aliyuncs.com/test/20240420213700.jpg" alt="20240420213700"></li></ul><p>𝑟(𝑝..𝑘)是𝑟Ω𝐺𝐶𝐹(𝑡,𝑝..𝑘3𝑑)的简写。假设GCF功率图的峰值在第𝑘𝑚𝑎𝑥个深度上，那么时刻t时的空间GCF图可以表示为：</p><ul><li><img src="https://typorazkr------------image.oss-cn-beijing.aliyuncs.com/test/20240420214343.jpg" alt="20240420214343"></li></ul><p>在时间段[t-m1, t]内，从共计m1+1帧中寻找带有最大sGCF峰值的帧集合m2。在时刻t的stGCF被定义为：</p><ul><li><img src="https://typorazkr------------image.oss-cn-beijing.aliyuncs.com/test/20240420215436.jpg" alt="20240420215436"></li></ul><p>其中T代表帧集合m2对应的时间集。</p><h4 id="视觉测量"><a href="#视觉测量" class="headerlink" title="视觉测量"></a>视觉测量</h4><p>在视觉测量阶段，为了更好的对搜索空间和已知目标进行相似度分析，引入了深度度量学习（是一种基于距离度量，通过将原始数据转换到含有距离信息的新空间，通过增加不同对象之间的距离，减少相同对象之间距离，建立对象之间相似性的方法）。在此模块中，作者还引入了一个预训练的孪生神经网络，该模块使用互相关作为卷积操作完成以后的度量函数。输出的相应图含有视觉线索，可以表示为:</p><ul><li><img src="https://typorazkr------------image.oss-cn-beijing.aliyuncs.com/test/20240421134107.jpg" alt="20240421134107"></li></ul><p>𝐼𝑡代表当前视频帧；𝐼𝑟𝑒𝑓是参考帧，是在第一帧中用户定义的追踪对象；𝐼是不同尺度的参考帧的集合。𝑓(·)指的是用于输出代表性分数图的度量函数。𝑆(𝐼𝑡)反映了追踪对象出现在每张图像的任意位置上的置信度。</p><h3 id="多模态感知注意力网络"><a href="#多模态感知注意力网络" class="headerlink" title="多模态感知注意力网络"></a>多模态感知注意力网络</h3><p>多模态感知注意力网络通过给定的音频和视频线索，生成一个置信度分数图来表示说话者的位置。人脑的注意力机制可以让人从丰富信息中获得更关键的特定信息。在该模块中，作者也使用了人脑的这种机制。</p><p>为了整合视觉和音频线索，将stGCF图和视觉响应图都归一化并且重塑为3D矩阵形式。</p><ul><li><img src="https://typorazkr------------image.oss-cn-beijing.aliyuncs.com/test/20240421143949.jpg" alt="20240421143949"></li></ul><p>𝑈代表了每个视频输入帧𝑈&#x3D;𝐻∗𝑊。𝐷𝑎是声学线索的维度，它取决于集合m2，指代的是时序线索。𝐷𝑣是𝐼𝑟𝑒𝑓的数量。整合的视听线索，𝑉&#x3D;[𝑅1,…,𝑅𝐷𝑎,𝑆1,…,𝑆𝐷𝑣]，都输入到一个基础网络中进行处理。该网络借鉴了通道注意模块的架构，通道对应了从视觉或者听觉模态中提取的观察结果。通道数共计𝐷𝑎+𝐷𝑣个，注意力机制𝐺𝑎𝑡𝑡生成了一个正分数𝑎𝑖去测量在第i个通道上观察结果的置信度：</p><ul><li><img src="https://typorazkr------------image.oss-cn-beijing.aliyuncs.com/test/20240421145218.jpg" alt="20240421145218"></li></ul><p>𝑎𝑖被称为感知权重，反映了通过之前获得的整合多模态线索的置信度。𝑎𝑖在可信赖的观察结果上表现更高，在模糊不清的观察结果（如背景噪音，房间混响，视觉遮挡，）上表现低水平。这都得益于神经网络从观察图谱中学习到的统计特征。通过这点，神经网络展示出了多模态观察的感知能力，为上述模型提供了可解释性。</p><h3 id="跨模态自监督学习"><a href="#跨模态自监督学习" class="headerlink" title="跨模态自监督学习"></a>跨模态自监督学习</h3><p><img src="https://typorazkr------------image.oss-cn-beijing.aliyuncs.com/test/20240421204444.jpg" alt="20240421204444"></p><p>由于网络获得感知力是一个抽象的过程，所以这使得难以对数据进行人为标记。作者提出了一种自监督学习策略去训练网络。自监督包括时间因素和空间因素，考虑了运动目标的时间连续性，以及多模态数据中的位置一致性。对于第i个通道，假设点𝑝𝑡,𝑖𝑚𝑎𝑥是在时间t的特征图峰值位置，其对应的在通道i上的空间因子是跨模态平均算子。跨模态空间因素被定义为：</p><ul><li><img src="https://typorazkr------------image.oss-cn-beijing.aliyuncs.com/test/20240421153201.jpg" alt="20240421153201"></li></ul><p>𝑆𝑡,𝑘(𝑝)指的是在点p的归一化视觉响应，𝑅𝑡,𝑗(𝑝)是在点p的归一化sGCF值，j代表深度索引。</p><p>时间因子是通过对以时刻t为中心的时间间隔执行平均操作来导出的，时间因素和自监督标签可以表示为：</p><ul><li><img src="https://typorazkr------------image.oss-cn-beijing.aliyuncs.com/test/20240421155423.jpg" alt="20240421155423"></li></ul><p>V指代的是视觉图或声学图，自监督标签集成了一个时间间隔内不同模式的估计结果。当目标在一个观察上发生偏移时，由于模态数据之间的互补性和目标移动的连续性，另一个提供更准确观察的通道提供的值会更低，偏移导致了数据干扰，当一个通道上的值越小时，它产生的偏移和影响就越小，所以就会更加准确。除此之外，当所有观察的峰值都集中在一个区域时，这表明不同观察之间存在一致性和一致的目标位置。这种一致性可以被视为对目标位置的更高置信度，因此值会相应增加，以反映观察的一致性。</p><h3 id="多模态追踪"><a href="#多模态追踪" class="headerlink" title="多模态追踪"></a>多模态追踪</h3><p>注意力网络通过在PF算法上替身从而获得了多模态追踪能力。网络输出的注意力被用于对视听线索𝑉进行加权，相较于传统的加性似然和乘性似然相比，基于注意力机制的加权方法更接近人的感官选择。通过平均加权获得的融合图可以表示为：</p><ul><li><img src="https://typorazkr------------image.oss-cn-beijing.aliyuncs.com/test/20240421181137.jpg" alt="20240421181137"></li></ul><p>𝑎𝑖代表在第i通道上观察的置信度。</p><p>将不同模态的感知注意值融合到融合图中，并且在PF的更新步骤对例子进行加权，之后将粒子位置融合图的值设置为新的例子权重。为了利用融合图的全局信息，在每一次迭代开始时，将一组粒子重置在融合图的峰值位置。</p><p>通过对峰值的矫正，避免了因某些帧存在观察噪声而造成的追踪漂移问题。当环境存在严重噪声干扰时，该方法表现出色。</p><h2 id="实验和讨论"><a href="#实验和讨论" class="headerlink" title="实验和讨论"></a>实验和讨论</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>作者使用了AV16.3语料库，该语料库提供从校准相机派生的真实 3D 嘴位置和各种图像上的 2D 测量以进行系统评估。实验在 seq08、11 和 12 上进行了测试，其中单个参与者绕、快速移动和间歇性说话。每组实验使用来自两个麦克风阵列和单个相机的信号。</p><h3 id="实施细节"><a href="#实施细节" class="headerlink" title="实施细节"></a>实施细节</h3><p>视觉线索是基于AlexNet的预训练孪生模型生成。参考图像集1包含尺度为1，1.25的两个目标矩形，由第一帧中的用户定义。对于音频测量，垂直和水平方向的2D采样点数为w&#x3D;20，h&#x3D;16。桌子高度0.8m，房间规格为3.6x8.2x2.4，去除了桌子下方和房间外的采样带你，避免了圆形麦克风阵列对称性带来的歧义。3D点的深度数为6。计算stGCF的参数设置为M &#x3D; 120,m1 &#x3D; 15, m2 &#x3D; 5。注意力机制网络的主干是MobileNetv3-large ，该网络在seq01，02，03上进行训练，包含超过4500个样本。生成自监督训练标签的参数设置为Da &#x3D; 5, Dv &#x3D; 2, n &#x3D; 6。所有模型都训练了20个epoch，批大小为16，学习率为0.01。定位方法和比较方法都基于采样重要性重采样(SIR)-PF，粒子数为100。</p><h3 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h3><p>使用平均绝对误差和准确度来评估跟踪方法的性能。MAE计算预测声源位置和地面实况像素级别的欧几里得距离，除以帧数。ACC测量城阙估计的百分比，其在像素中的误差距离不超过GT边界框对角线的1&#x2F;2。</p><h3 id="比较结果"><a href="#比较结果" class="headerlink" title="比较结果"></a>比较结果</h3><p><img src="https://typorazkr------------image.oss-cn-beijing.aliyuncs.com/test/20240421202614.jpg" alt="20240421202614"></p><p>将所提出的MPT与基于PF架构的单模态方法和最先进的视听方法进行了比较。AO 和 VO 方法是根据上一节中提出的音频线索和视觉线索实现的。此外，为了验证跟踪器在干扰条件下的鲁棒性，作者对遮挡数据进行了对比实验。遮挡区域被人为地覆盖在图像的中间(帧的1&#x2F;3)，用于模拟视场有限或相机探视器被遮挡的情况。在序列中，说话者走在遮挡区域后面，然后再次出现在屏幕上。为了更好地评估，我们计算每个序列中目标被遮挡的帧的比例。比较结果如表1所示。首先，音频和视觉模式的组合对说话人跟踪有很大的好处。在标准数据集上，所提出的MPT的MAE像素为4.34，优于最先进的算法。2LPF 通过在音频和视觉空间中分别使用额外的粒子滤波器实现了准确的估计。然而，2LPF中融合似然的计算依赖于稳定的观测，当视觉观测不可用时，导致迅速下降。</p><p>相比之下，MPT 在平均遮挡率为 51.08% 的序列上实现了 78.34% 的更好跟踪精度。图 4 显示了两个典型序列的 MAE 和错误数，其中阴影框表示目标被遮挡的帧。VO和2LPF受到遮挡的严重影响，这可以从阴影区域曲线的显著上升看出。 MPT 也受到遮挡的影响，但影响相对较小。</p><p><img src="https://typorazkr------------image.oss-cn-beijing.aliyuncs.com/test/20240421202704.jpg" alt="20240421202704"></p><h3 id="消融研究和分析"><a href="#消融研究和分析" class="headerlink" title="消融研究和分析"></a>消融研究和分析</h3><p>表2对MPT主要创新组建的有效性进行了评估。</p><p><img src="https://typorazkr------------image.oss-cn-beijing.aliyuncs.com/test/20240421202951.jpg" alt="20240421202951"></p><p>普通的GCF计算给定房间所有可能源位置的特定坐标下活动声源的存在合理性，如果没有先验信息，那么很难在有限的计算资源下寻找到准确的坐标。stGCF方法中将搜索范围通过投影关系缩小到不同深度的平面上，这是此前从未有人研究过的。</p><p>stGCF收到相机和麦克风阵列等几何配置的影响，特别是当扬声器位于相机和阵列的连线上时。由于声音信号的方向性，峰值通常出现在 stGCF 图中的大突出显示区域，这提供了模棱两可的搜索结果。作者使用两个麦克风阵列计算的结果优于传统方法，MAE 从 80.15 下降到 28.40。请注意，结果不会因视觉遮挡而改变。</p><h3 id="可视化分析"><a href="#可视化分析" class="headerlink" title="可视化分析"></a>可视化分析</h3><p>试听线索和融合图被用来生成热力图来可视化所提出方法的子过程。受益于网络感知每个模态状态的能力，该模型可以通过使用视听线索之间互补性来学习相应的感知权重（图5）。</p><p><img src="https://typorazkr------------image.oss-cn-beijing.aliyuncs.com/test/20240421204212.jpg" alt="20240421204212"></p><p>当视觉场有限时，可以实现连续跟踪。由于听觉感觉不受到视觉分心的干扰，音频线索在此种情景中具有优势，当说话者走到遮挡区域时，追踪器可以粗略估计说话者位置，这有利于当目标再次可见时重新追踪（图6）。</p><p><img src="https://typorazkr------------image.oss-cn-beijing.aliyuncs.com/test/20240421204231.jpg" alt="20240421204231"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在本文中，作者提出了一种新的多模态感知跟踪器，用于具有挑战性的视听说话人跟踪任务。以及一种新的多模态感知注意网络和一种新的声学图谱提取方法。所提出的跟踪器利用多种模式的互补性和一致性以自监督的方式学习不同模态之间观察的可用性和可靠性。大量实验表明，所提出的跟踪器优于当前最先进的跟踪器，尤其是在不利条件下显示出足够的鲁棒性。使用可视化中间过程以证明所提出的跟踪器网络的可解释性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 声源定位 </tag>
            
            <tag> 论文阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Torch学习</title>
      <link href="/2024/05/07/Torch%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/05/07/Torch%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="一-、数据操作"><a href="#一-、数据操作" class="headerlink" title="一 、数据操作"></a><a href="https://zh-v2.d2l.ai/chapter_preliminaries/ndarray.html">一 、数据操作</a></h2><h3 id="1-基础操作"><a href="#1-基础操作" class="headerlink" title="1.基础操作"></a>1.基础操作</h3><p>为了能够完成各种数据操作，我们需要某种方法来存储和操作数据。 通常，我们需要做两件重要的事：（1）获取数据；（2）将数据读入计算机后对其进行处理。 如果没有某种方法来存储数据，那么获取数据是没有意义的。</p><p>首先，我们导入<code>torch</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br></pre></td></tr></table></figure><p>张量表示一个由数值组成的数组，这个数组可能有多个维度。 具有一个轴的张量对应数学上的<em>向量</em>（vector）； 具有两个轴的张量对应数学上的<em>矩阵</em>（matrix）； 具有两个轴以上的张量没有特殊的数学名称。</p><p>我们可以使用 <code>arange</code> 创建一个行向量 <code>x</code>。这个行向量包含以0开始的前12个整数，它们默认创建为整数。也可指定创建类型为浮点数。张量中的每个值都称为张量的 <em>元素</em>（element）。例如，张量 <code>x</code> 中有 12 个元素。除非额外指定，新的张量将存储在内存中，并采用基于CPU的计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(12)</span><br><span class="line">x</span><br><span class="line">tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span><br></pre></td></tr></table></figure><p>可以通过shape属性访问张量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.shape</span><br></pre></td></tr></table></figure><p>要想改变一个张量的形状而不改变元素数量和元素值，可以调用<code>reshape</code>函数。 例如，可以把张量<code>x</code>从形状为（12,）的行向量转换为形状为（3,4）的矩阵。 这个新的张量包含与转换前相同的值，但是它被看成一个3行4列的矩阵。 要重点说明一下，虽然张量的形状发生了改变，但其元素值并没有变。 注意，通过改变张量的形状，张量的大小不会改变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">X = x.reshape(3, 4)</span><br><span class="line">X</span><br><span class="line">tensor([[ 0,  1,  2,  3],</span><br><span class="line">        [ 4,  5,  6,  7],</span><br><span class="line">        [ 8,  9, 10, 11]])</span><br><span class="line">torch.zeros((2, 3, 4))#创建零矩阵</span><br><span class="line">torch.ones((2, 3, 4))#创建一个全为1的矩阵</span><br><span class="line">torch.randn(3, 4)#创建一个符合正态分布的矩阵</span><br><span class="line">x = torch.tensor([1.0, 2, 4, 8])</span><br><span class="line">y = torch.tensor([2, 2, 2, 2])</span><br><span class="line">x + y, x - y, x * y, x / y, x ** y #对矩阵中各个元素进行对应运算</span><br></pre></td></tr></table></figure><h3 id="2-广播"><a href="#2-广播" class="headerlink" title="2.广播"></a>2.广播</h3><p>在上面的部分中，我们看到了如何在相同形状的两个张量上执行按元素操作。 在某些情况下，即使形状不同，我们仍然可以通过调用 <em>广播机制</em>（broadcasting mechanism）来执行按元素操作。 这种机制的工作方式如下：</p><ol><li><p>通过适当复制元素来扩展一个或两个数组，以便在转换之后，两个张量具有相同的形状；</p></li><li><p>对生成的数组执行按元素操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = torch.arange(3).reshape((3, 1))</span><br><span class="line">b = torch.arange(2).reshape((1, 2))</span><br><span class="line">a, b</span><br><span class="line">a+b</span><br><span class="line">tensor([[0, 1],</span><br><span class="line">        [1, 2],</span><br><span class="line">        [2, 3]])</span><br></pre></td></tr></table></figure><h2 id="二、数据预处理"><a href="#二、数据预处理" class="headerlink" title="二、数据预处理"></a><a href="https://zh-v2.d2l.ai/chapter_preliminaries/pandas.html">二、数据预处理</a></h2><p>为了能用深度学习来解决现实世界的问题，我们经常从预处理原始数据开始， 而不是从那些准备好的张量格式数据开始。 在Python中常用的数据分析工具中，我们通常使用<code>pandas</code>软件包。</p><h3 id="1-读取数据集"><a href="#1-读取数据集" class="headerlink" title="1.读取数据集"></a>1.读取数据集</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">os.makedirs(os.path.join(&#x27;..&#x27;, &#x27;data&#x27;), exist_ok=True)</span><br><span class="line">data_file = os.path.join(&#x27;..&#x27;, &#x27;data&#x27;, &#x27;house_tiny.csv&#x27;)</span><br><span class="line">with open(data_file, &#x27;w&#x27;) as f:</span><br><span class="line">    f.write(&#x27;NumRooms,Alley,Price\n&#x27;)  # 列名</span><br><span class="line">    f.write(&#x27;NA,Pave,127500\n&#x27;)  # 每行表示一个数据样本</span><br><span class="line">    f.write(&#x27;2,NA,106000\n&#x27;)</span><br><span class="line">    f.write(&#x27;4,NA,178100\n&#x27;)</span><br><span class="line">    f.write(&#x27;NA,NA,140000\n&#x27;)</span><br></pre></td></tr></table></figure><p>要从创建的CSV文件中加载原始数据集，我们导入<code>pandas</code>包并调用<code>read_csv</code>函数。该数据集有四行三列。其中每行描述了房间数量（“NumRooms”）、巷子类型（“Alley”）和房屋价格（“Price”）。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(data_file)</span><br><span class="line">print(data)</span><br><span class="line">   NumRooms Alley   Price</span><br><span class="line">0       NaN  Pave  127500</span><br><span class="line">1       2.0   NaN  106000</span><br><span class="line">2       4.0   NaN  178100</span><br><span class="line">3       NaN   NaN  140000</span><br></pre></td></tr></table></figure><h3 id="2-处理缺失值"><a href="#2-处理缺失值" class="headerlink" title="2.处理缺失值"></a>2.处理缺失值</h3><p>Na N ”项代表缺失值。 为了处理缺失的数据，典型的方法包括<em>插值法</em>和<em>删除法</em>， 其中插值法用一个替代值弥补缺失值，而删除法则直接忽略缺失值。</p><p>通过位置索引<code>iloc</code>，我们将<code>data</code>分成<code>inputs</code>和<code>outputs</code>， 其中前者为<code>data</code>的前两列，而后者为<code>data</code>的最后一列。 对于<code>inputs</code>中缺少的数值，我们用同一列的均值替换“Na N”项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inputs, outputs = data.iloc[:, 0:2], data.iloc[:, 2]</span><br><span class="line">inputs = inputs.fillna(inputs.mean())</span><br><span class="line">print(inputs)</span><br></pre></td></tr></table></figure><p>对于<code>inputs</code>中的类别值或离散值，我们将“NaN”视为一个类别。 由于“巷子类型”（“Alley”）列只接受两种类型的类别值“Pave”和“NaN”， <code>pandas</code>可以自动将此列转换为两列“Alley_Pave”和“Alley_nan”。 巷子类型为“Pave”的行会将“Alley_Pave”的值设置为1，“Alley_nan”的值设置为0。 缺少巷子类型的行会将“Alley_Pave”和“Alley_nan”分别设置为0和1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   NumRooms  Alley_Pave  Alley_nan</span><br><span class="line">0       3.0           1          0</span><br><span class="line">1       2.0           0          1</span><br><span class="line">2       4.0           0          1</span><br><span class="line">3       3.0           0          1</span><br></pre></td></tr></table></figure><h6 id="1-3转换为张量格式"><a href="#1-3转换为张量格式" class="headerlink" title="1.3转换为张量格式"></a>1.3转换为张量格式</h6><p>现在<code>inputs</code>和<code>outputs</code>中的所有条目都是数值类型，它们可以转换为张量格式。 当数据采用张量格式后，可以通过引入的那些张量函数来进一步操作。</p><h2 id="三、线性代数"><a href="#三、线性代数" class="headerlink" title="三、线性代数"></a><a href="https://zh-v2.d2l.ai/chapter_preliminaries/linear-algebra.html">三、线性代数</a></h2><p>从按元素操作的定义中可以注意到，任何按元素的一元运算都不会改变其操作数的形状。 同样，给定具有相同形状的任意两个张量，任何按元素二元运算的结果都将是相同形状的张量。 例如，将两个相同形状的矩阵相加，会在这两个矩阵上执行元素加法。</p><ul><li><h5 id="矩阵转置"><a href="#矩阵转置" class="headerlink" title="矩阵转置"></a>矩阵转置</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.T</span><br></pre></td></tr></table></figure></li><li><h5 id="求和原理：对哪个维度求和，哪个维度就会消失"><a href="#求和原理：对哪个维度求和，哪个维度就会消失" class="headerlink" title="求和原理：对哪个维度求和，哪个维度就会消失"></a>求和原理：对哪个维度求和，哪个维度就会消失</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.sum(axis=0)   #对于第一个轴求和</span><br><span class="line">#如果想保持轴数不变</span><br><span class="line">A.sum(axis=0， keepdims=True)  #用于广播机制，要求必须维度相同</span><br></pre></td></tr></table></figure></li><li><h5 id="按轴计算元素的累积总和：维度不会消失"><a href="#按轴计算元素的累积总和：维度不会消失" class="headerlink" title="按轴计算元素的累积总和：维度不会消失"></a>按轴计算元素的累积总和：维度不会消失</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.cumsum(axis=0)</span><br></pre></td></tr></table></figure></li><li><h5 id="L-2范数：向量元素的平方和的平方根-F范数与之类似（矩阵元素平方和的平方根）"><a href="#L-2范数：向量元素的平方和的平方根-F范数与之类似（矩阵元素平方和的平方根）" class="headerlink" title="L 2范数：向量元素的平方和的平方根 ||F范数与之类似（矩阵元素平方和的平方根）"></a>L 2范数：向量元素的平方和的平方根 ||F范数与之类似（矩阵元素平方和的平方根）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.noem(x)   #||x||2</span><br></pre></td></tr></table></figure></li><li><h5 id="L-1范数：每个元素的绝对值求和"><a href="#L-1范数：每个元素的绝对值求和" class="headerlink" title="L 1范数：每个元素的绝对值求和"></a>L 1范数：每个元素的绝对值求和</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.abs(x).sum()  #||x||1</span><br></pre></td></tr></table></figure></li></ul><p>矩阵乘法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">torch.dot() # 向量·向量</span><br><span class="line">torch.mv() # 矩阵·向量</span><br><span class="line">torch.mm() # 矩阵·矩阵</span><br><span class="line">torch.norm() # 求范数，默认为2</span><br></pre></td></tr></table></figure><h2 id="四、微积分："><a href="#四、微积分：" class="headerlink" title="四、微积分："></a>四、<a href="https://zh-v2.d2l.ai/chapter_preliminaries/calculus.html">微积分</a>：</h2><p><em>微积分，导数和微分，偏导数，梯度，链式法则</em></p><p>小结：</p><p>1.微分和积分是微积分的两个分支，前者可以应用于深度学习中的优化问题。</p><p>2.导数可以被解释为函数相对于其变量的瞬时变化率，它也是函数曲线的切线的斜率。</p><p>3.梯度是一个向量，其分量是多变量函数相对于其所有变量的偏导数。</p><p>4.链式法则可以用来微分复合函数。</p><h2 id="五、自动微分"><a href="#五、自动微分" class="headerlink" title="五、自动微分"></a><a href="https://zh-v2.d2l.ai/chapter_preliminaries/autograd.html">五、自动微分</a></h2><p>求导是几乎所有深度学习优化算法的关键步骤。 虽然求导的计算很简单，只需要一些基本的微积分。 但对于复杂的模型，手工进行更新是一件很痛苦的事情（而且经常容易出错）。</p><p>深度学习框架通过自动计算导数，即<em>自动微分</em>（automatic differentiation）来加快求导。 实际中，根据设计好的模型，系统会构建一个<em>计算图</em>（computational graph）， 来跟踪计算是哪些数据通过哪些操作组合起来产生输出。 自动微分使系统能够随后反向传播梯度。 这里，<em>反向传播</em>（backpropagate）意味着跟踪整个计算图，填充关于每个参数的偏导数。</p><p>实际中，根据设计好的模型，系统会构建一个计算图（computational graph）， 来跟踪计算是哪些数据通过哪些操作组合起来产生输出。 自动微分使系统能够随后反向传播梯度</p><h4 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h4><p>优点：局部计算，从而简化问题；将中间的计算结果全部保存起来；可以通过反向传播高效计算导数</p><h4 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h4><p>原理：如果某个函数由复合函数表示，则该复合函数的导数可以用构成复合函数的各个函数的导数的乘积表示</p><h4 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h4><h5 id="加法节点"><a href="#加法节点" class="headerlink" title="加法节点"></a>加法节点</h5><p>加法节点存在于某个最后输出的计算的一部分中。反向传播时，从最右边的输出出发，局部导数从节点向节点反方向传播</p><h5 id="乘法节点"><a href="#乘法节点" class="headerlink" title="乘法节点"></a>乘法节点</h5><p>乘法的反向传播会将上游的值乘以正向传播时的输入信号的“翻转值”后传递给下游</p><p>实现乘法节点的反向传播时，要保存正向传播的输入信号</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> python </tag>
            
            <tag> torch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>帮舍友做了点小工作，又是有成就感的一天</title>
      <link href="/2024/05/07/%E5%B8%AE%E8%88%8D%E5%8F%8B%E5%81%9A%E4%BA%86%E7%82%B9%E5%B0%8F%E5%B7%A5%E4%BD%9C%EF%BC%8C%E5%8F%88%E6%98%AF%E6%9C%89%E6%88%90%E5%B0%B1%E6%84%9F%E7%9A%84%E4%B8%80%E5%A4%A9/"/>
      <url>/2024/05/07/%E5%B8%AE%E8%88%8D%E5%8F%8B%E5%81%9A%E4%BA%86%E7%82%B9%E5%B0%8F%E5%B7%A5%E4%BD%9C%EF%BC%8C%E5%8F%88%E6%98%AF%E6%9C%89%E6%88%90%E5%B0%B1%E6%84%9F%E7%9A%84%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="一、起因"><a href="#一、起因" class="headerlink" title="一、起因"></a>一、起因</h2><p>舍友谈了女朋友，女朋友好像是学医的。然后她们有一个非常扯淡的工作，作为班干部要把word给弄成excal</p><p>像这样（舍友手搓的）：</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/6d4b05b8-0dd0-4626-9473-8f03de3787b8.png" alt="image.png"></p><p>而这玩意有足足900+道题，如果说手动写入那简直是苦难深重（而我的舍友因为爱情的力量还是坚持搞了大概五分之一，爱情太强大了，强大到能够冲昏头脑~~）</p><p><img src="https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/eb53b234-a839-4535-86a1-645258ce0f07.png" alt="image.png"></p><p>于是在一天下午舍友向我询问能不能自动转换，我想了想寒假学的数据处理和写数据库用的一些方法 拿正则套一下就行了 我说应该没问题来吧，然后就把这件事接了下来，之后他给我发了word文件我看了看，格式非常整洁很容易把正则套上去。那么 理论存在实践开始！</p><h2 id="二、学习准备"><a href="#二、学习准备" class="headerlink" title="二、学习准备"></a>二、学习准备</h2><p>之前没有操作过docx文件，所以去查了一下如何去操作docx文件。需要下载一个叫python-docx的库那么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-docx</span><br></pre></td></tr></table></figure><p>然后导入库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from docx import Document</span><br></pre></td></tr></table></figure><p>这里我用pycharm 结果装了给docx的库 和python-docx 不是一个库请注意！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc = Document(&quot;D:\垃圾项目\儿科.docx&quot;)</span><br></pre></td></tr></table></figure><p>Document（docx文件路径）</p><p>会创建一个Document的对象打开文件</p><p>这时候我们</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">doc = Document(&quot;D:\垃圾项目\儿科.docx&quot;)</span><br><span class="line">for i, paragraph in enumerate(doc.paragraphs[:55]):</span><br><span class="line">    print(i, paragraph.text)</span><br><span class="line">0 第一章:绪论</span><br><span class="line">1 一、单项选择题</span><br><span class="line">2 1. 儿科护士的心理素质不包括</span><br><span class="line">3 A．良好的记忆能力</span><br><span class="line">4 B．良好的观察能</span><br><span class="line">5 C．良好的思维能力</span><br><span class="line">6 D．良好的模仿能力</span><br><span class="line">7 E．良好的人际沟通能力</span><br><span class="line">8 2. 婴儿对某些传染病有一定的抵抗能力，主要是通过胎盘从母体中获得</span><br><span class="line">9 A．IgA</span><br><span class="line">10 B．SIgA</span><br><span class="line">11 C．IgE</span><br><span class="line">12 D．IgG</span><br><span class="line">13 E．IgM</span><br><span class="line">14 3. 小儿从母体获得的抗体从何时起日渐消失</span><br><span class="line">15 A．生后1～2个月</span><br><span class="line">16 B．生后3～4个月</span><br><span class="line">17 C．生后5～6个月</span><br><span class="line">18 D．生后7～8个月</span><br><span class="line">19 E．生后10～12个月</span><br><span class="line">20 4 .婴幼儿护理技术要求不包括下列哪项</span><br><span class="line">21 A．按婴幼儿疾病特点给予治疗及护理</span><br><span class="line">22 B．掌握婴幼儿各种生理特点和疾病特点</span><br><span class="line">23 C．练就一手过硬的静脉穿刺技术</span><br><span class="line">24 D．掌握各项辅助检查正常值</span><br><span class="line">25 E．小婴儿应予配奶、喂奶、喂药</span><br><span class="line">26 5.儿科护理学的范围不包括下列哪项： A．儿科临床护理工作</span><br><span class="line">27 B．儿童时期卫生保健工作</span><br><span class="line">28 C．儿科护理科学研究</span><br><span class="line">29 D．熟练掌握护理操作技能</span><br><span class="line">30 E．儿童的早期教育</span><br><span class="line">31 6.造成婴幼儿易患呼吸道感染的原因是</span><br><span class="line">32 A．血清中IgA缺乏</span><br><span class="line">33 B．分泌型IgA缺乏</span><br><span class="line">34 C．血清中IgG缺乏</span><br><span class="line">35 D．血清中IgM缺乏</span><br><span class="line">36 E．细胞免疫功能低下</span><br><span class="line">37 7. 婴儿期是指</span><br><span class="line">38 A．生后脐带结扎至1周岁</span><br><span class="line">39 B．出生后至1周岁</span><br><span class="line">40 C．生后1个月至1周岁前</span><br><span class="line">41 D．生后2周岁以内</span><br><span class="line">42 E．1～3周岁</span><br><span class="line">43 8.幼儿期是指</span><br><span class="line">44 A．生后29天至1周岁</span><br><span class="line">45 B．1～3周岁前</span><br><span class="line">46 C．2～5周岁</span><br><span class="line">47 D．3～5周岁</span><br><span class="line">48 E．4～6周岁</span><br><span class="line">49 9.根据小儿年龄不同，将小儿时期分为</span><br><span class="line">50 A．7个时期</span><br><span class="line">51 B．6个时期</span><br><span class="line">52 C．5个时期</span><br><span class="line">53 D．4个时期</span><br><span class="line">54 E．8个时期</span><br></pre></td></tr></table></figure><p>非常顺利的拿到了前五十行的信息</p><h2 id="实际操作："><a href="#实际操作：" class="headerlink" title="实际操作："></a>实际操作：</h2><p>能够拿到数据那么接下来就非常简单了去匹配格式，然后去进行处理</p><p>这时候就要用到正则表达式了</p><p>观察文档发现：</p><ol><li>题型以大写数字开头</li><li>题目以普通数字+.开头</li><li>选项以字母.开头</li></ol><p>整理好思路开始写正则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">black_char = re.compile(&quot;[\s\u3000\xa0]+&quot;)</span><br><span class="line"></span><br><span class="line">chinese_nums_rule = re.compile(&quot;[一二三四]、(.+)&quot;)</span><br><span class="line">title_rule = re.compile(&quot;\d+.&quot;)</span><br><span class="line">option_rule = re.compile(&quot;[ABCDEF]&quot;)</span><br><span class="line">option_rule_search = re.compile(&quot;^.+?$&quot;)</span><br></pre></td></tr></table></figure><p>好让我们把正则匹配输出一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for paragraph in doc.paragraphs[0:55]:</span><br><span class="line">    #  去除空白字符,将全角字符转半角字符，并给括号之间调整为中间二个空格</span><br><span class="line">    line = black_char.sub(&quot;&quot;, paragraph.text).replace(</span><br><span class="line">        &quot;（&quot;, &quot;(&quot;).replace(&quot;）&quot;, &quot;)&quot;).replace(&quot;．&quot;, &quot;.&quot;).replace(&quot;()&quot;, &quot;(  )&quot;)</span><br><span class="line">    # 对于空白行就直接跳过</span><br><span class="line">    if not line:</span><br><span class="line">        continue</span><br><span class="line">    if title_rule.match(line):</span><br><span class="line">        print(&quot;题目&quot;, line)</span><br><span class="line">    elif option_rule.match(line):</span><br><span class="line">        print(&quot;选项&quot;, option_rule_search.findall(line))</span><br><span class="line">    else:</span><br><span class="line">        chinese_nums_match = chinese_nums_rule.match(line)</span><br><span class="line">        if chinese_nums_match:</span><br><span class="line">            print(&quot;题型&quot;, chinese_nums_match.group(1))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">题型 单项选择题</span><br><span class="line">题目 1.儿科护士的心理素质不包括</span><br><span class="line">选项 [&#x27;A.良好的记忆能力&#x27;]</span><br><span class="line">选项 [&#x27;B.良好的观察能&#x27;]</span><br><span class="line">选项 [&#x27;C.良好的思维能力&#x27;]</span><br><span class="line">选项 [&#x27;D.良好的模仿能力&#x27;]</span><br><span class="line">选项 [&#x27;E.良好的人际沟通能力&#x27;]</span><br><span class="line">题目 2.婴儿对某些传染病有一定的抵抗能力，主要是通过胎盘从母体中获得</span><br><span class="line">选项 [&#x27;A.IgA&#x27;]</span><br><span class="line">选项 [&#x27;B.SIgA&#x27;]</span><br><span class="line">选项 [&#x27;C.IgE&#x27;]</span><br><span class="line">选项 [&#x27;D.IgG&#x27;]</span><br><span class="line">选项 [&#x27;E.IgM&#x27;]</span><br><span class="line">题目 3.小儿从母体获得的抗体从何时起日渐消失</span><br><span class="line">选项 [&#x27;A.生后1～2个月&#x27;]</span><br><span class="line">选项 [&#x27;B.生后3～4个月&#x27;]</span><br><span class="line">选项 [&#x27;C.生后5～6个月&#x27;]</span><br><span class="line">选项 [&#x27;D.生后7～8个月&#x27;]</span><br><span class="line">选项 [&#x27;E.生后10～12个月&#x27;]</span><br><span class="line">题目 4.婴幼儿护理技术要求不包括下列哪项</span><br><span class="line">选项 [&#x27;A.按婴幼儿疾病特点给予治疗及护理&#x27;]</span><br><span class="line">选项 [&#x27;B.掌握婴幼儿各种生理特点和疾病特点&#x27;]</span><br><span class="line">选项 [&#x27;C.练就一手过硬的静脉穿刺技术&#x27;]</span><br><span class="line">选项 [&#x27;D.掌握各项辅助检查正常值&#x27;]</span><br><span class="line">选项 [&#x27;E.小婴儿应予配奶、喂奶、喂药&#x27;]</span><br><span class="line">题目 5.儿科护理学的范围不包括下列哪项：A.儿科临床护理工作</span><br><span class="line">选项 [&#x27;B.儿童时期卫生保健工作&#x27;]</span><br><span class="line">选项 [&#x27;C.儿科护理科学研究&#x27;]</span><br><span class="line">选项 [&#x27;D.熟练掌握护理操作技能&#x27;]</span><br><span class="line">选项 [&#x27;E.儿童的早期教育&#x27;]</span><br><span class="line">题目 6.造成婴幼儿易患呼吸道感染的原因是</span><br><span class="line">选项 [&#x27;A.血清中IgA缺乏&#x27;]</span><br><span class="line">选项 [&#x27;B.分泌型IgA缺乏&#x27;]</span><br><span class="line">选项 [&#x27;C.血清中IgG缺乏&#x27;]</span><br><span class="line">选项 [&#x27;D.血清中IgM缺乏&#x27;]</span><br><span class="line">选项 [&#x27;E.细胞免疫功能低下&#x27;]</span><br><span class="line">题目 7.婴儿期是指</span><br><span class="line">选项 [&#x27;A.生后脐带结扎至1周岁&#x27;]</span><br><span class="line">选项 [&#x27;B.出生后至1周岁&#x27;]</span><br><span class="line">选项 [&#x27;C.生后1个月至1周岁前&#x27;]</span><br><span class="line">选项 [&#x27;D.生后2周岁以内&#x27;]</span><br><span class="line">选项 [&#x27;E.1～3周岁&#x27;]</span><br><span class="line">题目 8.幼儿期是指</span><br><span class="line">选项 [&#x27;A.生后29天至1周岁&#x27;]</span><br><span class="line">选项 [&#x27;B.1～3周岁前&#x27;]</span><br><span class="line">选项 [&#x27;C.2～5周岁&#x27;]</span><br><span class="line">选项 [&#x27;D.3～5周岁&#x27;]</span><br><span class="line">选项 [&#x27;E.4～6周岁&#x27;]</span><br><span class="line">题目 9.根据小儿年龄不同，将小儿时期分为</span><br><span class="line">选项 [&#x27;A.7个时期&#x27;]</span><br><span class="line">选项 [&#x27;B.6个时期&#x27;]</span><br><span class="line">选项 [&#x27;C.5个时期&#x27;]</span><br><span class="line">选项 [&#x27;D.4个时期&#x27;]</span><br><span class="line">选项 [&#x27;E.8个时期&#x27;]</span><br></pre></td></tr></table></figure><p>看起来没有问题</p><p>现在我打算将当前匹配出来的文本<a href="https://cloud.tencent.com/product/cdcs?from=20065&from_column=20065">数据存储</a>成字典形式的结构化数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 保存最终的结构化数据</span><br><span class="line">question_type2data = OrderedDict()</span><br><span class="line"># 从word文档的“一、单项选择题”开始遍历数据</span><br><span class="line">title2options = &#123;&#125;</span><br><span class="line">options = []</span><br><span class="line">for paragraph in doc.paragraphs[0:]:</span><br><span class="line"></span><br><span class="line">    #  去除空白字符,将全角字符转半角字符，并给括号之间调整为中间一个空格</span><br><span class="line">    line = black_char.sub(&quot;&quot;, paragraph.text).replace(</span><br><span class="line">        &quot;（&quot;, &quot;(&quot;).replace(&quot;）&quot;, &quot;)&quot;).replace(&quot;．&quot;, &quot;.&quot;).replace(&quot;()&quot;, &quot;(  )&quot;)</span><br><span class="line">    # 对于空白行就直接跳过</span><br><span class="line">    if not line:</span><br><span class="line">        continue</span><br><span class="line">    if title_rule.match(line):</span><br><span class="line">        options = title2options.setdefault(line, [])</span><br><span class="line">    elif option_rule.match(line):</span><br><span class="line">        options.extend(option_rule_search.findall(line))</span><br><span class="line">    else:</span><br><span class="line">        chinese_nums_match = chinese_nums_rule.match(line)</span><br><span class="line">        if chinese_nums_match:</span><br><span class="line">            question_type = chinese_nums_match.group(1)</span><br><span class="line">            title2options = question_type2data.setdefault(question_type, OrderedDict())</span><br></pre></td></tr></table></figure><h2 id="遍历结构化字典储存"><a href="#遍历结构化字典储存" class="headerlink" title="遍历结构化字典储存"></a>遍历结构化字典储存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">max_options_len = 0</span><br><span class="line">for question_type, title2options in question_type2data.items():</span><br><span class="line">    for title, options in title2options.items():</span><br><span class="line">        result.append([question_type, title, *options])</span><br><span class="line">        options_len = len(options)</span><br><span class="line">        if options_len &gt; max_options_len:</span><br><span class="line">            max_options_len = options_len</span><br><span class="line">df = pd.DataFrame(result, columns=[&quot;题型&quot;, &quot;题目&quot;]+[f&quot;选项&#123;i&#125;&quot; for i in range(1, max_options_len+1)])</span><br><span class="line"># 题型可以简化下，去掉选择两个字</span><br><span class="line"></span><br><span class="line">df[&#x27;题型&#x27;] = df[&#x27;题型&#x27;].str.replace(&quot;&quot;, &quot;&quot;)</span><br><span class="line">df.head()</span><br><span class="line">print(df)</span><br><span class="line">try:</span><br><span class="line">    df.to_excel(r&#x27;D:\垃圾项目\test.xlsx&#x27;, sheet_name=&#x27;Sheet1&#x27;, index=False, header=True)</span><br><span class="line">except:</span><br><span class="line">    print(&quot;写入成功！&quot;)</span><br></pre></td></tr></table></figure><p>全部代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import re</span><br><span class="line">from docx import Document</span><br><span class="line">from collections import OrderedDict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">doc = Document(&quot;D:\垃圾项目\儿科.docx&quot;)</span><br><span class="line"># for i, paragraph in enumerate(doc.paragraphs[:55]):</span><br><span class="line">#     print(i, paragraph.text)</span><br><span class="line"></span><br><span class="line">black_char = re.compile(&quot;[\s\u3000\xa0]+&quot;)</span><br><span class="line"></span><br><span class="line">chinese_nums_rule = re.compile(&quot;[一二三四]、(.+)&quot;)</span><br><span class="line">title_rule = re.compile(&quot;\d+.&quot;)</span><br><span class="line">option_rule = re.compile(&quot;[ABCDEF]&quot;)</span><br><span class="line">option_rule_search = re.compile(&quot;^.+?$&quot;)</span><br><span class="line"></span><br><span class="line"># 保存最终的结构化数据</span><br><span class="line">question_type2data = OrderedDict()</span><br><span class="line"># 从word文档的“一、单项选择题”开始遍历数据</span><br><span class="line">title2options = &#123;&#125;</span><br><span class="line">options = []</span><br><span class="line">for paragraph in doc.paragraphs[0:]:</span><br><span class="line"></span><br><span class="line">    #  去除空白字符,将全角字符转半角字符，并给括号之间调整为中间一个空格</span><br><span class="line">    line = black_char.sub(&quot;&quot;, paragraph.text).replace(</span><br><span class="line">        &quot;（&quot;, &quot;(&quot;).replace(&quot;）&quot;, &quot;)&quot;).replace(&quot;．&quot;, &quot;.&quot;).replace(&quot;()&quot;, &quot;(  )&quot;)</span><br><span class="line">    # 对于空白行就直接跳过</span><br><span class="line">    if not line:</span><br><span class="line">        continue</span><br><span class="line">    if title_rule.match(line):</span><br><span class="line">        options = title2options.setdefault(line, [])</span><br><span class="line">    elif option_rule.match(line):</span><br><span class="line">        options.extend(option_rule_search.findall(line))</span><br><span class="line">    else:</span><br><span class="line">        chinese_nums_match = chinese_nums_rule.match(line)</span><br><span class="line">        if chinese_nums_match:</span><br><span class="line">            question_type = chinese_nums_match.group(1)</span><br><span class="line">            title2options = question_type2data.setdefault(question_type, OrderedDict())</span><br><span class="line">result = []</span><br><span class="line">max_options_len = 0</span><br><span class="line">for question_type, title2options in question_type2data.items():</span><br><span class="line">    for title, options in title2options.items():</span><br><span class="line">        result.append([question_type, title, *options])</span><br><span class="line">        options_len = len(options)</span><br><span class="line">        if options_len &gt; max_options_len:</span><br><span class="line">            max_options_len = options_len</span><br><span class="line">df = pd.DataFrame(result, columns=[&quot;题型&quot;, &quot;题目&quot;]+[f&quot;选项&#123;i&#125;&quot; for i in range(1, max_options_len+1)])</span><br><span class="line"></span><br><span class="line">df.head()</span><br><span class="line">print(df)</span><br><span class="line">#打印出来看看处理的结果是否正确</span><br><span class="line">try:</span><br><span class="line">    df.to_excel(r&#x27;D:\垃圾项目\test.xlsx&#x27;, sheet_name=&#x27;Sheet1&#x27;, index=False, header=True)</span><br><span class="line">except:</span><br><span class="line">    print(&quot;写入成功！&quot;)</span><br></pre></td></tr></table></figure><p>最终效果</p><p><img src="https://beyondclouds.oss-cn-beijing.aliyuncs.com/blog/images/836624b8-666c-429f-b6b4-78216d19d960.png" alt="image.png"></p><p>有一些格式不规范套不上正则 但是并不多大概十几道题 总的来说解决的大部分的工作量</p><p>稍微调整一下excal</p><p><img src="https://beyondclouds.oss-cn-beijing.aliyuncs.com/blog/images/6748f8a3-6a50-4817-9f3e-e4ced35321d1.png" alt="image.png"></p><p><img src="https://beyondclouds.oss-cn-beijing.aliyuncs.com/blog/images/fa14a117-ecf0-412c-b3a7-886627039309.png" alt="image.png"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这个工作连学习带调试大概花费了三个小时时间，一个晚自习加第二天研学的一半时间。时间花费并不算多，但是通过写代码解决了一件生活中常见的问题，把技术转换成了生产力 我还是很高兴的。帮舍友解决了问题，自己也得到了锻炼和成就感，最近学习任务又多又重，前一段时间看了赵文凯的博客感触颇深，其实我也很迷茫，因为学习本身艰难且短期看没有什么收益 。我能够做到这件事情，虽然这是一件微不足道的小事，但也能说明我日以继日做的努力没有白白的浪费，更加坚定了我继续学习下去的信心。用那个相传甚广的交大学生生存法则的话来说，能够支持你学习下去的<strong>一定是你对科学技术的好奇心。</strong>也希望各位也能够保持初心砥砺前行。</p><p>最后让我再说一句“<strong>振翅云顶之上，汲目星辰大海！</strong>”</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx学习</title>
      <link href="/2024/05/03/Nginx%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/05/03/Nginx%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx学习"><a href="#nginx学习" class="headerlink" title="nginx学习"></a>nginx学习</h1><h3 id="1-nginx-和可以做什么事情"><a href="#1-nginx-和可以做什么事情" class="headerlink" title="1.nginx 和可以做什么事情"></a>1.nginx 和可以做什么事情</h3><p>2.Nginx 作为 web 服务器</p><ul><li><p>Nginx 是高性能的 HTTP 和<a href="https://so.csdn.net/so/search?q=%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86&spm=1001.2101.3001.7020">反向代理</a>的web服务器，处理高并发能力是十分强大的，能经受高负 载的考验,有报告表明能支持高达 50,000 个并发连接数。</p></li><li><p>Nginx 可以作为静态页面的 web 服务器，同时还支持 CGI 协议的动态语言，比如 perl、php 等。但是不支持 java。Java 程序只能通过与 tomcat 配合完成。Nginx 专为性能优化而开发， 性能是其最重要的考量,实现上非常注重效率 ，能经受高负载的考验,有报告表明能支持高 达 50,000 个并发连接数。</p></li></ul><ol start="3"><li>正向代理<br>Nginx 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。 正向代理：如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访 问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。</li></ol><p>简单一点：通过代理服务器来访问服务器的过程 就叫 正向代理。<br>需要在客户端配置代理服务器进行指定网站访问</p><ol start="4"><li><p>反向代理<br>反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问。<br>我们只 需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返 回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器 地址，隐藏了真实服务器 IP 地址。</p></li><li><p>负载均衡<br>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的 情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负 载均衡</p></li></ol><p>  客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服 务器处理完毕后，再将结果返回给客户端。</p><pre><code>这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成 本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂 度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易 造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情 况呢？ 我们首先想到的可能是升级服务器的配置，比如提高 CPU 执行频率，加大内存等提高机 器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能 满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量 是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能 够满足需求的。那么怎么办呢？上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题 的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解 决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们 所说的负载均衡</code></pre><h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><p>  第一部分：全局块<br>  从配置文件开始到 events 块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令，主要包括配 置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等。<br>  比如上面第一行配置的：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>  这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是 会受到硬件、软件等设备的制约。</p><h4 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h4><p>  比如上面的配置：</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  events 块涉及的指令<strong>主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否 允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。</strong><br>  上述例子就表示每个 work process 支持的最大连接数为 1024.<br>  这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。</p><p>  第三部分：</p><p>  这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。</p><p>  需要注意的是：http 块也可以包括 http全局块、server 块。</p><h4 id="http全局块"><a href="#http全局块" class="headerlink" title="http全局块"></a>http全局块</h4><p>  http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</p><h4 id="server-块"><a href="#server-块" class="headerlink" title="server 块"></a>server 块</h4><p>  这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了 节省互联网服务器硬件成本。<br>  每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。<br>  而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。<br>  全局 server 块<br>  最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。</p><h4 id="location-块"><a href="#location-块" class="headerlink" title="location 块"></a>location 块</h4><p>  一个 server 块可以配置多个 location 块。<br>  这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name&#x2F;uri-string），对虚拟主机名称 （也可以是IP 别名）之外的字符串（例如 前面的 &#x2F;uri-stringinx 配置文件有三部分组成</p><p>location 指令说明<br>该指令用于匹配 URL。<br>语法如下：</p><p>1、&#x3D; ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配 成功，就停止继续向下搜索并立即处理该请求。<br>2、<del>：用于表示 uri 包含正则表达式，并且区分大小写。<br>3、</del>*：用于表示 uri 包含正则表达式，并且不区分大小写。<br>4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字 符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。</p><p>注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~*标识。</p><h2 id="Nginx-动静分离"><a href="#Nginx-动静分离" class="headerlink" title="Nginx 动静分离"></a>Nginx 动静分离</h2><p>Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和 静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用 Nginx 处理静态页面，Tomcat 处理动态页面。动静分离从目前实现角度来讲大致分为两种：</p><p>一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；</p><p>另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。</p><p>通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使 浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资 源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可， 所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件， 不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送 一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。</p><h2 id="Nginx-的原理"><a href="#Nginx-的原理" class="headerlink" title="Nginx 的原理"></a>Nginx 的原理</h2><ul><li>nginx 启动后，是由两个进程组成的。master（管理者）和worker（工作者）。</li><li>一个nginx 只有一个master。但可以有多个worker+</li></ul><p><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/03/Nginx%E5%AD%A6%E4%B9%A0/06ba3f0629beb1d84681fd17e2796df.png?raw=true" alt="img"></p><p>master-workers 的机制的好处<br>首先，对于每个 worker 进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销， 同时在编程以及问题查找时，也会方便很多。<br>可以使用 nginx –s reload 热部署，利用 nginx 进行热部署操作<br>其次，采用独立的进程，可以让互相之间不会 影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的 worker 进程。当然，worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当 前 worker 上的所有请求失败，不过不会影响到所有请求，所以降低了风险。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记</title>
      <link href="/2024/05/03/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/05/03/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言学习笔记"><a href="#C语言学习笔记" class="headerlink" title="C语言学习笔记"></a>C语言学习笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>适应期最后一周马上就要结束了，回顾这一周的学习生活，只能用痛并快乐来形容。刚开始上手学习C语言感觉还是比较简单易懂的前面的声明 习惯 数据类型都非常好理解 学习进度一日千里，当时我对自己充满了自信。然后三天后 第一周作业出现了，看到作业的时候我是拒绝的，因为上面写的很多东西我是想不到该去怎么实现的。 三天的学习 ，很多知识在脑海里只是走马观花的过了一遍， 没有留下什么深刻的记忆。 但是摆烂是没有用的 ，只能硬着头皮做了。于是第一周的痛苦生活就开始了，反复翻阅慕课网 去思考怎么去实现每一个需求，晚上也是辗转反侧去思考BUG是怎么出来的。也是功夫不负有心人，我也顺利的完成了大多数要求，还受到了学姐的表扬（划重点）。</p><p>这篇笔记是我自己整理而来 主题部分是慕课上的教学 ，和其他网站上的内容 再加上我自己所理解的一些心得，才疏学浅 ，如有错误请纠正指出。</p><h2 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h2><p>写代码应该有一个良好的习惯 使你的代码具有良好的可读性 我总结有以下几点</p><p>1.一个说明或一个语句占一行。</p><p>2.函数体内的语句要有明显<strong>缩进</strong>，<strong>通常以按一下Tab键为一个缩进</strong>。</p><p>3.括号要<strong>成对写</strong>，如果需要删除的话也要<strong>成对删除</strong>。</p><p>4.<strong>多写注释</strong>，一方面可以让别人知道程序怎样实现的功能，另一方面也让你以后能了解当时自己是怎么想的（不写注释的话 这代码恐怕只有上帝能看懂）</p><p>5.要有<strong>多使用函数、养成模块化编程的习惯</strong>，用函数来封装一个个代码块 使得功能模块能够复用 可以有效缩小代码体积 移植性强 main函数上的代码更加直观。</p><p>6.命名方式很重要，要让人看到这个变量就能直观的明白要表达什么意思 尽量使用有具体意义的名词去命名。</p><h2 id="C语言的特点"><a href="#C语言的特点" class="headerlink" title="C语言的特点"></a>C语言的特点</h2><p>C 语言是一种通用的<strong>高级语言</strong></p><p><strong>特点：</strong></p><ul><li>易于学习。</li><li>面向过程编程</li><li>产生高效率的程序。</li><li>可以处理底层的活动。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;哦天哪 这不是Hello world么&quot;);</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C程序结构"><a href="#C程序结构" class="headerlink" title="C程序结构"></a>C程序结构</h2><p><strong>一个C程序就是由若干头文件和函数组成。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; //头文件</span><br><span class="line"></span><br><span class="line">int main()//主函数</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;哦天哪 这不是Hello world么&quot;);//格式化输出语句</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#include &lt;stdio.h&gt;是一条预处理命令，它的作用是通知C语言编译系统在对C程序进行正式编译之前需做一些预处理工作。</p><p>函数是实现代码逻辑的一个小的单元。</p><p>C程序就是执行主函数里的代码，也可以说这个<strong>主函数</strong>就是C语言中的<strong>唯一入口</strong>。并且C程序一定是从主函数开始执行的。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>编程时给<strong>变量或者函数起的名字就是标识符</strong></p><p>C 语言规定，<strong>标识符</strong>可以是**字母(A～Z，a～z)<strong>、</strong>数字(0～9)<strong>、</strong>下划线_**组成的字符串，并且**第一个字符必须是字母或下划线**。在使用标识符时还有注意以下几点：</p><p>(1)标识符的长度最好<strong>不要超过8位</strong>，因为在某些版本的C中规定标识符前8位有效，当两个标识符前8位相同时，则被认为是同一个标识符。</p><p>(2)标识符是<strong>严格区分大小写</strong>的。例如Imooc和imooc 是两个不同的标识符。</p><p>(3)标识符最好选择<strong>有意义的英文单词</strong>组成做到”见名知意”，不要使用中文。</p><p>(4)标识符<strong>不能是C语言的关键字</strong>。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p><table><thead><tr><th align="left">关键字</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">auto</td><td align="left">声明自动变量</td></tr><tr><td align="left">break</td><td align="left">跳出当前循环</td></tr><tr><td align="left">case</td><td align="left">开关语句分支</td></tr><tr><td align="left">char</td><td align="left">声明字符型变量或函数返回值类型</td></tr><tr><td align="left">const</td><td align="left">定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变</td></tr><tr><td align="left">continue</td><td align="left">结束当前循环，开始下一轮循环</td></tr><tr><td align="left">default</td><td align="left">开关语句中的”其它”分支</td></tr><tr><td align="left">do</td><td align="left">循环语句的循环体</td></tr><tr><td align="left">double</td><td align="left">声明双精度浮点型变量或函数返回值类型</td></tr><tr><td align="left">else</td><td align="left">条件语句否定分支（与 if 连用）</td></tr><tr><td align="left">enum</td><td align="left">声明枚举类型</td></tr><tr><td align="left">extern</td><td align="left">声明变量或函数是在其它文件或本文件的其他位置定义</td></tr><tr><td align="left">float</td><td align="left">声明浮点型变量或函数返回值类型</td></tr><tr><td align="left">for</td><td align="left">一种循环语句</td></tr><tr><td align="left">goto</td><td align="left">无条件跳转语句</td></tr><tr><td align="left">if</td><td align="left">条件语句</td></tr><tr><td align="left">int</td><td align="left">声明整型变量或函数</td></tr><tr><td align="left">long</td><td align="left">声明长整型变量或函数返回值类型</td></tr><tr><td align="left">register</td><td align="left">声明寄存器变量</td></tr><tr><td align="left">return</td><td align="left">子程序返回语句（可以带参数，也可不带参数）</td></tr><tr><td align="left">short</td><td align="left">声明短整型变量或函数</td></tr><tr><td align="left">signed</td><td align="left">声明有符号类型变量或函数</td></tr><tr><td align="left">sizeof</td><td align="left">计算数据类型或变量长度（即所占字节数）</td></tr><tr><td align="left">static</td><td align="left">声明静态变量</td></tr><tr><td align="left">struct</td><td align="left">声明结构体类型</td></tr><tr><td align="left">switch</td><td align="left">用于开关语句</td></tr><tr><td align="left">typedef</td><td align="left">用以给数据类型取别名</td></tr><tr><td align="left">unsigned</td><td align="left">声明无符号类型变量或函数</td></tr><tr><td align="left">union</td><td align="left">声明共用体类型</td></tr><tr><td align="left">void</td><td align="left">声明函数无返回值或无参数，声明无类型指针</td></tr><tr><td align="left">volatile</td><td align="left">说明变量在程序执行中可被隐含地改变</td></tr><tr><td align="left">while</td><td align="left">循环语句的循环条件</td></tr></tbody></table><p><strong>分类如下：</strong></p><p><strong>数据类型关键字(12个)：</strong></p><p>char、short、int、long、signed、unsigned、float、double、struct、union、enum、void</p><p><strong>控制语句关键字(12个）：</strong></p><p><strong>1、循环控制（5个）</strong></p><p>for、do、while、break、continue</p><p><strong>2、条件语句（3个）</strong></p><p>if、else、goto</p><p><strong>3、开关语句（3个）</strong></p><p>switch、case、default</p><p><strong>4、返回语句（1个）</strong></p><p>return</p><p><strong>存储类型关键字（5个）</strong></p><p>auto、extern、register、static、typedef</p><p><strong>其他关键字（3个）</strong></p><p>const、sizeof、volatil</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol><li><p>算术运算符：加+、减-、乘*、除&#x2F;、取余%、自增++、自减–；</p></li><li><p>赋值运算符：</p><p>①简单赋值运算符：&#x3D;，右值赋给左变量</p><p>②符合赋值：+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;</p><p>注意：连续复合赋值运算：自右向左运算</p></li><li><p>关系运算符：&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&#x3D;&#x3D;、!&#x3D;(不等于)</p></li><li><p>逻辑运算符：&amp;&amp;与 ||或 非！</p></li><li><p>三目运算符（表达式1？表达式2：表达式3）</p><p>表达式1为真执行表达式2，为假执行表达式3</p></li></ol><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>第一优先级： [ ] ( ) . -&gt; &#x2F;&#x2F;“.“为成员选择（对象）,”-&gt;”为成员选择（指针）；</p><p>第二优先级： 负号运算符- ++ – * &amp; ！ 强制类型转换(类型) sizeof</p><p>第三优先级：&#x2F; * %</p><p>第四优先级： + -</p><p>第五优先级：左移&lt;&lt; 右移&gt;&gt;</p><p>第六优先级：&gt; &gt;&#x3D; &lt; &lt;&#x3D;</p><p>第七优先级：&#x3D;&#x3D; !&#x3D;</p><p>第八：按位与&amp; 第九：按位异或^ 第十：按位或| 第十一：&amp;&amp; 第十二：|| 第十三：三目运算符（ ？ ： ）</p><p>第十四：赋值运算符</p><p>第十五：逗号运算符（逗号也是运算符他的优先级最低）</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="一、整型-int、short、long、long-long"><a href="#一、整型-int、short、long、long-long" class="headerlink" title="一、整型(int、short、long、long long)"></a>一、整型(int、short、long、long long)</h3><h5 id="1、有符号整型"><a href="#1、有符号整型" class="headerlink" title="1、有符号整型"></a><strong>1、有符号整型</strong></h5><p>有符号整型的数据类型通常包括 int、short、long、long long 四种，因为是有符号类型，所以前面要加上 signed ，但是通常省略，也就是说在代码中直接打出 int 类型就代表是有符号类型的。</p><p><strong>（1）int类型</strong><br>数据类型大小是 4 字节，能表示的数值范围是<br>-2^(32-1) – 2^(32-1)-1 （即 -2147483648 ~ 2147483647）<br>打印类型是 %d ，使用格式为 int 名 &#x3D; 值;</p><p><strong>（2）short类型</strong><br>数据类型大小是 2 字节，能表示的数值范围是<br>-2^(16-1) – 2(16-1) -1 （即 -32768 ~ 32767）<br>打印类型是 %hd ，使用格式为 short 名 &#x3D; 值;</p><p><strong>（3）long类型</strong><br>数据类型大小是 4 字节，能表示的数值范围是<br>-2^(32-1) – 2^(32-1)-1 （即 -2147483648 ~ 2147483647）<br>打印类型是 %ld ，使用格式为 int 名 &#x3D; 值;</p><p><strong>（4）long long类型</strong><br>数据类型大小是 8 字节，能表示的数值范围是<br>-2^(63) ~ 2^(63)-1 (这个数足够大了)<br>打印类型是 %lld ，使用格式为 long long 名 &#x3D; 值;</p><h5 id="2、无符号整型"><a href="#2、无符号整型" class="headerlink" title="2、无符号整型"></a>2、无符号整型</h5><p>无符号数用 unsigned 表示 ，只表示数据量，而没有方向（没有正负，且无符号数最高位不是符号位，而就是数的一部分，无符号数不可能是负数。</p><p><strong>（1）unsigned int 类型</strong><br>数据类型大小是 4 字节，能表示的数值范围是<br>0 – 2^(32）-1 （即 0~4294967295）<br>打印类型是 %u ，使用格式为 unsigned int 名 &#x3D; 值;</p><p><strong>（2）unsigned short 类型</strong><br>数据类型大小是 2 字节，能表示的数值范围是<br>0 ~ 2^8 -1 （即 0~65535）<br>打印类型是 %hu ，使用格式为 unsigned short 名 &#x3D; 值;</p><p><strong>（3）unsigned long 类型</strong><br>数据类型大小是 4 字节，能表示的数值范围是<br>0 – 2^(32）-1 （即 0~4294967295）<br>打印类型是 %lu ，使用格式为 unsigned long 名 &#x3D; 值;</p><p><strong>（4）unsigned long long 类型</strong><br>数据类型大小是 8 字节，能表示的数值范围是<br>0~2^63-1<br>打印类型是 %llu ，使用格式为 unsigned long long 名 &#x3D; 值;</p><h4 id="二、-字符型（char）"><a href="#二、-字符型（char）" class="headerlink" title="二、 字符型（char）"></a>二、 字符型（char）</h4><p>字符型变量用于存储一个单一字符，在 C 语言中用 char 表示，其中每个字符变量都会占用 1 个字节。在给字符型变量赋值时，需要用一对英文半角格式的单引号(’ ‘)把字符括起来。字符变量实际上并不是把该字符本身放到变量的内存单元中去，而是将该字符对应的 ASCII 编码放到变量的存储单元中。char的本质就是一个1字节大小的整型。</p><p>char 的格式匹配符（打印格式) 为：%c</p><p>数值表示范围是：<br>有符号: -2^(8-1) – 2(8-1) -1 （即 -128 ~ 127）<br>无符号： 0 ~ 2^8 -1 （即 0~255）</p><p>常用的ASCLL码为：<br>‘A’：65</p><p>‘a’：97（大小写相差 32 ）</p><p>‘0’：48</p><p>‘\n’:10</p><p>‘\0’: 0</p><h4 id="三、浮点型（float、double）"><a href="#三、浮点型（float、double）" class="headerlink" title="三、浮点型（float、double）"></a>三、浮点型（float、double）</h4><h5 id="1、单精度浮点型（float）"><a href="#1、单精度浮点型（float）" class="headerlink" title="1、单精度浮点型（float）"></a>1、单精度浮点型（float）</h5><p>单精度浮点型的大小是 4 字节<br>float v1 &#x3D; 4.345;<br>unsigned float v1 &#x3D; 4.345; 无符号的 float 数据<br>格式匹配符是：%f ， 默认保留 6 位小数。</p><h5 id="2、双精度浮点型（double）"><a href="#2、双精度浮点型（double）" class="headerlink" title="2、双精度浮点型（double）"></a>2、双精度浮点型（double）</h5><p>双精度浮点型的大小为 8 字节<br>double v2 &#x3D; 5.678;<br>unsigned double v2 &#x3D; 5.678; 无符号的 double 数据</p><p>printf(“n &#x3D; %08.3f\n”, n);<br>输出的含义为：显示8位数（包含小数点）， 不足8位用0填充。并且保留3位小数。对第4位做四舍五入。</p><h3 id="四、void型"><a href="#四、void型" class="headerlink" title="四、void型"></a>四、void型</h3><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p><table><thead><tr><th align="left">序号</th><th align="left">类型与描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>函数返回为空</strong> C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 <strong>void exit (int status);</strong></td></tr><tr><td align="left">2</td><td align="left"><strong>函数参数为空</strong> C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 <strong>int rand(void);</strong></td></tr><tr><td align="left">3</td><td align="left"><strong>指针指向 void</strong> 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 <strong>void *malloc( size_t size );</strong> 返回指向 void 的指针，可以转换为任何数据类型。</td></tr></tbody></table><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>顾名思义，就是可以发生改变的量就叫做变量</p><p>变量有一个概念就是先定义，再使用</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>不会改变的量就叫做常量</p><p>字面常量，可分为整型常量，实型常量，字符常量和字符串常量。举例：如10，20和30都是整型常量；如 2.3，4.5和7.7都是实型常量；如 ‘a’，‘b’ 和 ‘c’都是字符常量；如 “abc”是字符串常量。</p><p>在C语言中，可以用一个标识符来表示一个常量，称之为符号常量。符号常量在使用之前必须先定义，其一般形式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define 标识符 常量值 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define POCKETMONEY 10    //定义常量及常量值</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // POCKETMONEY = 12;  //小明私自增加零花钱对吗？</span><br><span class="line">    printf(&quot;小明今天又得到%d元零花钱</span><br><span class="line">&quot;, POCKETMONEY);</span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p><strong>1.使用scanf()函数进行输入</strong></p><p>scanf()函数的原型是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int scanf(const char * restrict format,...);</span><br></pre></td></tr></table></figure><p>scanf()函数位于C标准库头文件&lt;stdio.h&gt;中<br>format 是 类似于 %d %s %e %f %lf %lld之类的格式串<br>格式后面按格式串里面定义的先后顺序 依次书写变量的地址 如&amp;a和&amp;b 但是字符数组的变量名就代表了该字符数组的首地址了，不用加上&amp;取地址运算符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//声明了两个整形变量a和b</span><br><span class="line">    int a=0,b=0; </span><br><span class="line">//输入两个整数并赋值给整形变量a和b</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;a,&amp;b); </span><br><span class="line">//计算a+b的值并输出</span><br><span class="line">printf(&quot;a+b=%d\n&quot;, a+b);  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>2.scanf() 常见的格式控制符汇总</strong></p><table><thead><tr><th>格式控制符</th><th>含义</th></tr></thead><tbody><tr><td>%d %ld %lld</td><td>输入一个int型整数 输入一个long型整数 输入一个long long型整数</td></tr><tr><td>%c</td><td>输入一个字符</td></tr><tr><td>%s</td><td>输入一个字符串(遇到空格截断)</td></tr><tr><td>%f %lf</td><td>输入一个float单精度浮点数 输入一个double双精度浮点数</td></tr><tr><td>%o %x %u</td><td>输入一个八进制整数到int型变量 输入一个十六进制整数到int型变量 输入一个无符号整数到int型整数</td></tr><tr><td>%e %le</td><td>输入一个指数形式的小数到float单精度浮点数 输入一个指数形式的小数到double单精度浮点数</td></tr></tbody></table><p><strong>3.fscanf()是文件输入的函数</strong></p><p><strong>4.getchar()是从输入流中读取一个字符的函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char ch;</span><br><span class="line">getchar(ch);</span><br></pre></td></tr></table></figure><p>getchar()函数位于C标准库头文件&lt;stdio.h&gt;中<br>后续的getchar()调用是不会等待用户按键，而直接读取缓冲区中的字符</p><p><strong>5.getch()是从控制台中读取一个字符的函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char ch;</span><br><span class="line">getch(ch);</span><br></pre></td></tr></table></figure><p>getch()函数位于C标准库头文件&lt;conio.h&gt;中<br>getch()调用会等待用户按键，从控制台读入字符 并不会回显到控制台</p><p><strong>6.getche()是从控制台中读取一个字符的函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char ch;</span><br><span class="line">getche(ch);</span><br></pre></td></tr></table></figure><p>getche()函数位于C标准库头文件&lt;conio.h&gt;中<br>getche()调用会等待用户按键，从控制台读入字符 并立刻回显到控制台</p><p><strong>7.gets()是从输入缓冲区读入一个字符串赋值到指定的字符数组中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char str[2048];</span><br><span class="line">gets(str);</span><br></pre></td></tr></table></figure><p>上述代码基本等价于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanf(&quot;%s&quot;, str);</span><br></pre></td></tr></table></figure><p>但是使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanf(&quot;%s&quot;, str);</span><br></pre></td></tr></table></figure><p>遇到空格会截断字符串</p><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gets(str);</span><br></pre></td></tr></table></figure><p>遇到空格不会截断字符串<br>gets()函数位于C标准库头文件&lt;stdio.h&gt;中<br>gets() 函数的功能是从输入缓冲区中读取一个字符串存储到字符指针变量 str 所指向的内存空间。<br>gets() 可以直接用于输入带空格的字符串，遇到换行符才结束输入</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><strong>1.使用printf()函数进行输出</strong></p><p>printf()函数的原型为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int printf(const char *format, ...);</span><br></pre></td></tr></table></figure><p>printf()函数位于C标准库头文件&lt;stdio.h&gt;中<br>printf的控制格式和scanf是差不多的 printf还可以输出相关的转义字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello World!\n&quot;);  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>printf中想要输出’‘必须要使用转义字符’’才能输出成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Hello World!\\&quot;);</span><br></pre></td></tr></table></figure><p>就能输出Hello World!\</p><p><strong>2.printf的输出格式</strong></p><table><thead><tr><th>输出格式</th><th>含义</th></tr></thead><tbody><tr><td>%d %ld %lld</td><td>十进制有符号整数 对应int型变量&#x2F;long型变量&#x2F;long long型变量</td></tr><tr><td>%u</td><td>十进制无符号整数int型变量</td></tr><tr><td>%f %lf</td><td>单精度浮点数 双精度浮点数</td></tr><tr><td>%s</td><td>字符数组(串)</td></tr><tr><td>%c</td><td>一个字符</td></tr><tr><td>%p</td><td>指针指向的内存地址</td></tr><tr><td>%e</td><td>指数形式的单精度浮点数</td></tr></tbody></table><p><strong>3.printf的输出的格式控制</strong></p><p><strong>1、%d的格式控制格式：</strong><br>%对齐方式+最长输出位数d<br>对齐方式:-表示向左对齐 默认向右对齐<br>如%Nd: N是指定输出的宽度。默认是向右对齐，整形位数小于N位时，，空位补上空格；大于N位时，按实际位数输出。想输出01,可以使用%01d控制输出<br><strong>2、%f的格式控制格式：</strong><br>%对齐方式+最长位数.小数点后位数f<br>对齐方式:-表示向左对齐 默认向右对齐<br>如%k.nf：默认是向右对齐，最大长度为k位，小数位为n位，整数为则为k-n-1位。 %4.2f 输出类似12.13这样的单精度浮点数 也可以让i留白 %.2f 输出xxxxx. 02这样的单精度浮点数 此时总位数是不定的值</p><p><strong>4.fprintf()是输出到文件的函数</strong></p><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><h3 id="1、简单if语句"><a href="#1、简单if语句" class="headerlink" title="1、简单if语句"></a>1、简单if语句</h3><p>C语言中的分支结构语句中的if条件语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if()</span><br><span class="line">&#123;</span><br><span class="line">执行代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果表达式的值为真，则执行其后的语句，否则不执行该语句。</p><p>注意：if()后面没有分号，直接写{}</p><h3 id="2、简单if-else语句"><a href="#2、简单if-else语句" class="headerlink" title="2、简单if-else语句"></a>2、简单if-else语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(表达式)</span><br><span class="line">&#123;</span><br><span class="line">执行代码块1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">执行代码块2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果表达式的值为真，则执行代码块1，否则执行代码块2。</p><p>注意：<br>if()后面没有分号，直接写{},else后面也没有分号，直接写{}</p><h3 id="3、多重if-else语句"><a href="#3、多重if-else语句" class="headerlink" title="3、多重if-else语句"></a>3、多重if-else语句</h3><p>依次判断表达式的值，当出现某个值为真时，则执行对应代码块，否则执行代码块n。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if()</span><br><span class="line">&#123;</span><br><span class="line">xxx;</span><br><span class="line">&#125;</span><br><span class="line">if else()</span><br><span class="line">&#123;</span><br><span class="line">xxx;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、嵌套if-else语句"><a href="#4、嵌套if-else语句" class="headerlink" title="4、嵌套if-else语句"></a>4、嵌套if-else语句</h3><p>C语言中嵌套if-else语句。嵌套if-else语句的意思，就是在if-else语句中，再写if-else语句。</p><h3 id="5、switch语句"><a href="#5、switch语句" class="headerlink" title="5、switch语句"></a>5、switch语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式)</span><br><span class="line">&#123;</span><br><span class="line">case 常量表达式1:</span><br><span class="line">执行代码块；</span><br><span class="line">break；</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">case 常量代码块n:</span><br><span class="line">执行代码块；</span><br><span class="line">break；</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">执行代码块n+1；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>在case后的各常量表达式的值不能相同，否则会出现错误。<br>在case子句后如果没有break;会一直往后执行**一直到遇到break;<strong>才会跳出switch语句。<br>switch后面的表达式语句只能是整型或者字符类型。<br>在case后，允许有多个语句，</strong>可以不用{}**括起来。<br>各case和default子句的先后顺序可以变动，而不会影响程序执行结果。<br>default子句可以省略不用。</p><h3 id="6、goto语句"><a href="#6、goto语句" class="headerlink" title="6、goto语句"></a>6、goto语句</h3><p>C语言中也有这样的语句，就是goto语句，goto语句是一种无条件分支语句。</p><p><em>臭名远扬。</em></p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="1、while循环"><a href="#1、while循环" class="headerlink" title="1、while循环"></a>1、while循环</h3><p>反复不停的执行某个动作就是循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(表达式)</span><br><span class="line">&#123;</span><br><span class="line">执行代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中表达式表示循环条件，执行代码块为循环体。</p><p>计算表达式的值，当值为真(非0)时， 执行循环体代码块。</p><p>while语句中的表达式一般是关系表达或逻辑表达式，当表达式的值为假时不执行循环体，反之则循环体一直执行。</p><p>一定要记着在循环体中改变循环变量的值，否则会出现死循环（无休止的执行）。</p><p>循环体如果包括有一个以上的语句，则必须用{}括起来，组成复合语句。</p><h3 id="2、do-while循环"><a href="#2、do-while循环" class="headerlink" title="2、do-while循环"></a>2、do-while循环</h3><p>C语言中的do-while循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">执行代码块;</span><br><span class="line">&#125;while(表达式);</span><br></pre></td></tr></table></figure><p>它先执行循环中的执行代码块，然后再判断while中表达式是否为真，如果为真则继续循环；如果为假，则终止循环。因此，do-while循环至少要执行一次循环语句。</p><p>注意：使用do-while结构语句时，while括号后必须有分号。</p><h3 id="3、for循环"><a href="#3、for循环" class="headerlink" title="3、for循环"></a>3、for循环</h3><p>c语言中for循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(执行表达式1;判断表达式2;执行表达式3)</span><br><span class="line">&#123;</span><br><span class="line">执行代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行表达式1，对循环变量做初始化；</p><p>判断表达式2，若其值为真(非0)，则执行for循环体中执行代码块，然后向下执行；若其值为假(0)，则结束循环;</p><p>执行表达式3，(i++)等对于循环变量进行操作的语句;</p><p>执行for循环中执行代码块后执行第二步;第一步初始化只会执行一次。<br>循环结束，程序继续向下执行。</p><p>注意：for循环中的两个分号一定要写</p><p>在for循环中:</p><p>表达式1是一个或多个赋值语句，它用来控制变量的初始值；</p><p>表达式2是一个关系表达式，它决定什么时候退出循环；</p><p>表达式3是循环变量的步进值，定义控制循环变量每循环一次后按什么方式变化。</p><p>这三部分之间用分号 ; 分开。</p><p>for循环中的“表达式1、2、3”均可不写为空，但两个分号(;;)不能缺省。</p><p>省略“表达式1（循环变量赋初值）”，表示不对循环变量赋初始值。</p><p>省略“表达式2(循环条件)”，不做其它处理，循环一直执行（死循环）。</p><p>省略“表达式3(循环变量增减量)”，不做其他处理，循环一直执行（死循环）。</p><p>表达式1可以是设置循环变量的初值的赋值表达式，也可以是其他表达式。</p><p>表达式1和表达式3可以是一个简单表达式也可以是多个表达式以逗号分割。</p><p>表达式2一般是关系表达式或逻辑表达式，但也可是数值表达式或字符表达式，只要其值非零，就执行循环体。</p><p>各表达式中的变量一定要在for循环之前定义。</p><h3 id="4、三种循环比较"><a href="#4、三种循环比较" class="headerlink" title="4、三种循环比较"></a>4、三种循环比较</h3><p>while, do-while和for三种循环在具体的使用场合上是有区别的，如下：</p><p>在知道循环次数的情况下更适合使用for循环;</p><p>在不知道循环次数的情况下适合使用while或者do-while循环:</p><p>如果有可能一次都不循环应考虑使用while循环</p><p>如果至少循环一次应考虑使用do-while循环。</p><p>但是从本质上讲，while,do-while和for循环之间是可以相互转换的。</p><h3 id="5、循环控制语句"><a href="#5、循环控制语句" class="headerlink" title="5、循环控制语句"></a>5、循环控制语句</h3><p>循环控制语句改变你代码的执行顺序。通过它你可以实现代码的跳转。</p><table><thead><tr><th align="left">控制语句</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">break 语句</td><td align="left">终止<strong>循环</strong>或 <strong>switch</strong> 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。</td></tr><tr><td align="left">continue 语句</td><td align="left">告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。</td></tr><tr><td align="left">goto 语句</td><td align="left">将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td></tr></tbody></table><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="（1）函数调用"><a href="#（1）函数调用" class="headerlink" title="（1）函数调用"></a>（1）函数调用</h4><p>在C语言中，函数调用的一般形式为：</p><p><strong>函数名（[参数]）;</strong></p><h4 id="（2）有参函数和无参函数"><a href="#（2）有参函数和无参函数" class="headerlink" title="（2）有参函数和无参函数"></a>（2）有参函数和无参函数</h4><p>在函数中不需要函数参数的称之为<strong>无参函数</strong>，在函数中需要函数参数的称之为<strong>有参函数</strong></p><h5 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h5><p>函数的参数分为<strong>形参</strong>和<strong>实参</strong>两种,<strong>形参是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数</strong></p><p><strong>实参是在调用时传递该函数的参数</strong></p><p>在参数传递时，实参和形参在<strong>数量上，类型上，顺序上应严格一致</strong>，否则会发生类型不匹配”的错误</p><h4 id="（3）递归函数"><a href="#（3）递归函数" class="headerlink" title="（3）递归函数"></a>（3）递归函数</h4><p>即在一个函数中调用这个函数，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">int factorial(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int result;</span><br><span class="line">    if (n&lt;0)                                         </span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;输入错误!\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; </span><br><span class="line">    else if (n==0 || n==1)</span><br><span class="line">    &#123;</span><br><span class="line">        result = 1; </span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        result = factorial(n-1) * n; </span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n = 5;                                             </span><br><span class="line">    printf(&quot;%d的阶乘=%d&quot;,n,factorial(n));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归函数必须有<strong>结束条件</strong>。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><em><strong>简而言之，就是把一堆数据类型相同的数据放在一起</strong></em></p><p>形式为</p><p>**数据类型 数组名称[长度]; **</p><h6 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h6><p><em>数据类型 数组名称[长度n] &#x3D; {元素1,元素2…元素n};</em></p><p>获取数组元素时： 数组名称[元素所对应下标];</p><p>如：初始化一个数组 int arr[3] &#x3D; {1,2,3}; 那么arr[0]就是元素1。</p><h6 id="元素引用"><a href="#元素引用" class="headerlink" title="元素引用"></a>元素引用</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int arr[3]=&#123;1,2,3&#125;;</span><br><span class="line">t=arr[2];//t=3</span><br></pre></td></tr></table></figure><h5 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h5><p>二话不说，直接上例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int i;</span><br><span class="line">int arr[10];</span><br><span class="line">printf(&quot;请输入十个数字，我会把他从大到小排序:\n&quot;);</span><br><span class="line">for (i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">int i, j, temp;</span><br><span class="line">for (i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">for (j = 0; j &lt; 10 - i; j++) &#123;</span><br><span class="line">if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + 1];</span><br><span class="line">arr[j + 1] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h5><p>二维数组就像一个表格，它的性质和一维数组是一样的</p><p>比如我存入十六个数字{1，2，6，5，9，8，7，4，5，6，5，5，6，6，6，5}</p><p>int arr[4] [4]&#x3D;{1，2，6，5，9，8，7，4，5，6，5，5，6，6，6，5}</p><p>那么这个二维数组有四行四列，即</p><table><thead><tr><th>列数&#x2F;行数</th><th>第一列</th><th>第二列</th><th>第三列</th><th>第四列</th></tr></thead><tbody><tr><td>第一行</td><td>1</td><td>2</td><td>6</td><td>5</td></tr><tr><td>第二行</td><td>9</td><td>8</td><td>7</td><td>4</td></tr><tr><td>第三行</td><td>5</td><td>6</td><td>5</td><td>5</td></tr><tr><td>第四行</td><td>6</td><td>6</td><td>6</td><td>5</td></tr></tbody></table><p><em><strong>注：行数可以不写，但是列数必须写</strong></em></p><p><em><strong>注2：例如用数组储存单词，一个字母就对应一个元素</strong></em></p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>1.基本概念</p><p>1.1地址的理解</p><p>整型占四个字节，图中四个方格可以看作存放整型a的区域，则第一个方格的位置100就是a的地址</p><p>1.2为什么使用指针</p><p>在你想要调用某个数时，可以把那个数据当作你的另一半。你可以在茫茫人海中大范围寻找，可想而知很难。但是有一个角色叫做媒婆对吧？媒婆可以作为媒介将你和你的另一半介绍到一起，我们就不需要大范围找啦，只需要根据媒婆的指引直接就可以找到另一半。媒婆的作用其实就是指针的作用。同样，在我们传入形参时，若传入的数据过于庞大，我们只需要将其指针传入，在运行时系统就可以根据指针直接到对应的位置找到需要的数据，就方便多了。</p><p>2.指针的定义</p><p>int *p&#x3D;&a;</p><p>在声明指针的形式中,这里的星是起到了说明的作用，说明声明的变量p是一个指针。不要将其和p联系在一 起，觉得*p是一个数，并不是一个指针。可以这样理解：</p><p>int *(p&#x3D;&amp;a)</p><p>“*”是说明的作用，括号中&amp;取地址将a的地址取出来赋予p，声明的是一个指针p。</p><p>注意：</p><p>1、避免野指针：</p><p>1.在声明指针变量时就赋予其地址</p><p>2.在声明指针变量时先赋予NULL</p><p>3.避免指针的访问越界4.避免返回局部变量的地址</p><p>2、避免访问空指针</p><p>3.指针的运算</p><p>p++</p><p>代表的是地址往后移动一个单位，指向下一个数据，运算之后得到的还是一个指针</p><p>(*p)++</p><p>代表的是地址后移之后再取出该地址之中存的数据，其结果是一个数据。</p><p>*(p++)</p><p>代表将原地址中存储的数据取出来再加一。</p><p>4.指针和数组</p><p>4.1返回值是指针的函数</p><p>指针函数**：<br>函数的返回值的类型既可以是整型(若没有设定，则默认为整型)，实型，字符型，也可以是指针型。<br>返回值为指针类型的函数又称为指针类型的函数，建成指针函数。</p><p>声明一个指针函数：</p><p>int <em>a(int x)首先由单目运算符，a与（int x）结合，表示这是一个函数，int x 表示是一个参数传入，前面的</em>表示这是一个指针函数，返回值是指针。</p><p>4.2指向函数的指针变量</p><p>定义形式：<br>类型说明符 （*变量名） （传参列表）</p><p>指向函数的指针变量在声明的时候，并不指向某个具体的函数，而是一个空指针。</p><h2 id="关于c语言的结构体"><a href="#关于c语言的结构体" class="headerlink" title="关于c语言的结构体:"></a>关于c语言的结构体:</h2><p>为什么要用到结构体，我们都已经学了很多int char …等类型还学到了同类型元素构成的数组，以及取上述类型的指针，在一些小应用可以灵活使用，然而，在我们实际应用中，每一种变量进行一次声明，再结合起来显然是不太实际的，类如一位学生的信息管理，他可能有，姓名（char），学号（int）成绩（float）等多种数据。如果把这些数据分别单独定义，就会特别松散、复杂，难以规划，因此我们需要把一些相关的变量组合起来，以一个整体形式对对象进行描述，这就是结构体的好处。</p><h2 id="关于结构体的小知识"><a href="#关于结构体的小知识" class="headerlink" title="关于结构体的小知识"></a>关于结构体的小知识</h2><p>2.1<strong>只有结构体变量才分配地址，而结构体的定义是不分配空间的。</strong><br>2.2结构体中各成员的定义和之前的变量定义一样，但在定义时也不分配空间。<br>2.3结构体变量的声明需要在主函数之上或者主函数中声明，如果在主函数之下则会报错<br>2.4c语言中的结构体不能直接进行强制转换，只有结构体指针才能进行强制转换<br>2.5相同类型的成员是可以定义在同一类型下的<br>列如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Student</span><br><span class="line">&#123; </span><br><span class="line">int number,age；//int型学号和年龄</span><br><span class="line">char name[20],sex;//char类型姓名和性别</span><br><span class="line">float score;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h3 id="3关于结构体变量的定义和引用"><a href="#3关于结构体变量的定义和引用" class="headerlink" title="3关于结构体变量的定义和引用"></a><strong>3关于结构体变量的定义和引用</strong></h3><p>在编译时，结构体的定义并不分配存储空间，对结构体变量才按其数据结构分配相应的存储空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">`` struct Book`</span><br><span class="line"> `&#123;` </span><br><span class="line"> `char title[20];//一个字符串表`</span><br><span class="line"></span><br><span class="line">`示的titile 题目`</span><br><span class="line">`char author[20];//一个字符串表示的author作者`</span><br><span class="line"> `float value;//价格表示` </span><br><span class="line"> `&#125;;//这里只是声明 结构体的定义` </span><br><span class="line">struct Book book1,book2;//结构体变量的定义 分配空间</span><br><span class="line"></span><br><span class="line">book1.value;//引用结构体变量`</span><br></pre></td></tr></table></figure><p>定义结构体变量以后，系统就会为其分配内存单元，比如book1和book2在内存中占<strong>44</strong>个字节（20+20+4）具体的长度可以在你的编译器中使用sizeof关键字分别求出来。</p><p>要注意一点：用sizeof关键字求结构体长度时，返回的最大基本类型所占字节的整数倍 比方说我们上面求得的为44 为 float(4个字节)的整数倍，<br>但是我们把title修改为title[22]; 这时正常长度为46 ，但是你会发现实际求得的为48，(4的整数倍)</p><p>这就涉及到结构体的存储：</p><p>1结构体整体空间是占用空间最大的成员（的类型）所占字节数的整数倍。</p><p>2.结构体的每个成员相对结构体首地址的偏移量(offset)都是最大基本类型成员字节大小的整数倍，如果不是编译器会自动补齐，</p><p>1.偏移量—-偏移量指的是结构体变量中成员的地址和结构体变量首地址的差。即偏移字节数，结构体大小等于最后一个成员的偏移量加上他的大小，第一个成员的偏移量为0，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct S1</span><br><span class="line">&#123;</span><br><span class="line">    char a;</span><br><span class="line"></span><br><span class="line">    int b;</span><br><span class="line">    </span><br><span class="line">    double c;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里char a 偏移量为1 之后为int b 因为偏移量1不为int(4)的整数倍，所以会自动补齐，而在 double c 时，偏移量为8 是double(8)的整数倍，所以不用自动补齐 最后求得结构体得大小为 16</p><p>具体看下图：这里char a 偏移量为1 之后为int b 因为偏移量1不为int(4)的整数倍，所以会自动补齐，而在 double c 时，偏移量为8 是double(8)的整数倍，所以不用自动补齐 最后求得结构体得大小为 16</p><p>具体看下图：<br><img src="https://img-blog.csdnimg.cn/20190511100507608.png" alt="在这里插入图片描述"></p><p>4结构体变量的初始化</p><p>结构体的初始化有很多需要注意的地方，这里我们说明下<br>首先是几种初始化的方法<br>ps：在对结构体变量初始化时，要对结构体成员一一赋值，不能跳过前面成员变量，而直接给后面成员赋初值，但是可以只赋值前面几个，对与后面未赋值的变量，如果是数值型，则会自动赋值为0,对于字符型，会自动赋初值为NULL，即‘\0’</p><h4 id="4-1定义时直接赋值"><a href="#4-1定义时直接赋值" class="headerlink" title="4.1定义时直接赋值"></a>4.1定义时直接赋值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct Student`</span><br><span class="line">`&#123;` </span><br><span class="line">`char name[20];`</span><br><span class="line">`char sex;`</span><br><span class="line">`int number;`</span><br><span class="line">`&#125;stu1=&#123;&quot;zhaozixuan&quot;,&#x27;M&#x27;,12345&#125;;`</span><br><span class="line">`//或者`</span><br><span class="line">`struct Student`</span><br><span class="line">`&#123;` </span><br><span class="line">`char name[20];`</span><br><span class="line">`char sex;`</span><br><span class="line">`int number;`</span><br><span class="line">`&#125;；`</span><br><span class="line">`struct Student stu1=&#123;&quot;zhaozixuan&quot;,&#x27;M&#x27;,12345&#125;;`</span><br><span class="line"></span><br><span class="line">**`注意字符为‘ ’ 字符串为&quot;&quot;**</span><br></pre></td></tr></table></figure><h4 id="4-2定义结构体之后逐个赋值"><a href="#4-2定义结构体之后逐个赋值" class="headerlink" title="4.2定义结构体之后逐个赋值"></a><code>4.2定义结构体之后逐个赋值</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`stu1.name=&quot;王伟&quot;；`</span><br><span class="line">`stu1.sex=&#x27;M&#x27;;`</span><br><span class="line">`stu1.number=12305;`</span><br><span class="line">`//也可用strcpy函数进行赋值`</span><br><span class="line">`strcpy(stu1.name,&quot;王伟&quot;);`</span><br></pre></td></tr></table></figure><h4 id="4-3定义之后任意赋值"><a href="#4-3定义之后任意赋值" class="headerlink" title="4.3定义之后任意赋值"></a>4.3定义之后任意赋值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">``struct Student stu1=&#123;`</span><br><span class="line"> `.name=&quot;Wang&quot;,`</span><br><span class="line"> `.number=12345,`</span><br><span class="line"> `.sex=&#x27;W&#x27;,` </span><br><span class="line">&#125;;//可以对任意变量赋值`</span><br></pre></td></tr></table></figure><h4 id="结构体变量的引用"><a href="#结构体变量的引用" class="headerlink" title="结构体变量的引用"></a>结构体变量的引用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Student</span><br><span class="line">&#123;char name[20];</span><br><span class="line">char sex;</span><br><span class="line">int number;</span><br><span class="line">    struct Date</span><br><span class="line">&#123;</span><br><span class="line">int year;</span><br><span class="line"> int month;</span><br><span class="line"> int day;</span><br><span class="line">&#125;birthday;</span><br><span class="line"></span><br><span class="line">&#125;stu1;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;stu1.birthday.month);</span><br></pre></td></tr></table></figure><p><strong>结构体数组与结构体变量区别只是将结构体变量替换为数组。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Student</span><br><span class="line">&#123; </span><br><span class="line">char name[20];</span><br><span class="line">char sex;</span><br><span class="line">int number;</span><br><span class="line">&#125;stu1[5]=&#123;</span><br><span class="line"> &#123;&quot;zhaozixuan&quot;,&#x27;M&#x27;,12345&#125;,</span><br><span class="line"> &#123;&quot;houxiaohong&quot;,&#x27;M&#x27;,12306&#125;,</span><br><span class="line"> &#123;&quot;qxiaoxin&quot;,&#x27;W&#x27;,12546&#125;,</span><br><span class="line"> &#123;&quot;wangwei&quot;,&#x27;M&#x27;,14679&#125;,</span><br><span class="line"> &#123;&quot;yulongjiao&quot;,&#x27;W&#x27;,17857&#125;</span><br><span class="line">&#125;;</span><br><span class="line">stu1[3].name[3]</span><br></pre></td></tr></table></figure><h3 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h3><p>为了访问结构的成员，我们使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。可以使用 struct 关键字来定义结构类型的变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   char  title[50];</span><br><span class="line">   char  author[50];</span><br><span class="line">   char  subject[100];</span><br><span class="line">   int   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   struct Books Book1;        /* 声明 Book1，类型为 Books */</span><br><span class="line">   struct Books Book2;        /* 声明 Book2，类型为 Books */</span><br><span class="line"> </span><br><span class="line">   /* Book1 详述 */</span><br><span class="line">   strcpy( Book1.title, &quot;C Programming&quot;);</span><br><span class="line">   strcpy( Book1.author, &quot;Nuha Ali&quot;); </span><br><span class="line">   strcpy( Book1.subject, &quot;C Programming Tutorial&quot;);</span><br><span class="line">   Book1.book_id = 6495407;</span><br><span class="line"> </span><br><span class="line">   /* Book2 详述 */</span><br><span class="line">   strcpy( Book2.title, &quot;Telecom Billing&quot;);</span><br><span class="line">   strcpy( Book2.author, &quot;Zara Ali&quot;);</span><br><span class="line">   strcpy( Book2.subject, &quot;Telecom Billing Tutorial&quot;);</span><br><span class="line">   Book2.book_id = 6495700;</span><br><span class="line"> </span><br><span class="line">   /* 输出 Book1 信息 */</span><br><span class="line">   printf( &quot;Book 1 title : %s\n&quot;, Book1.title);</span><br><span class="line">   printf( &quot;Book 1 author : %s\n&quot;, Book1.author);</span><br><span class="line">   printf( &quot;Book 1 subject : %s\n&quot;, Book1.subject);</span><br><span class="line">   printf( &quot;Book 1 book_id : %d\n&quot;, Book1.book_id);</span><br><span class="line"> </span><br><span class="line">   /* 输出 Book2 信息 */</span><br><span class="line">   printf( &quot;Book 2 title : %s\n&quot;, Book2.title);</span><br><span class="line">   printf( &quot;Book 2 author : %s\n&quot;, Book2.author);</span><br><span class="line">   printf( &quot;Book 2 subject : %s\n&quot;, Book2.subject);</span><br><span class="line">   printf( &quot;Book 2 book_id : %d\n&quot;, Book2.book_id);</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Book 1 author : Nuha Ali</span><br><span class="line">Book 1 subject : C Programming Tutorial</span><br><span class="line">Book 1 book_id : 6495407</span><br><span class="line">Book 2 title : Telecom Billing</span><br><span class="line">Book 2 author : Zara Ali</span><br><span class="line">Book 2 subject : Telecom Billing Tutorial</span><br><span class="line">Book 2 book_id : 6495700</span><br></pre></td></tr></table></figure><p>结构作为函数参数<br>可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。可以使用上面实例中的方式来访问结构变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   char  title[50];</span><br><span class="line">   char  author[50];</span><br><span class="line">   char  subject[100];</span><br><span class="line">   int   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 函数声明 */</span><br><span class="line">void printBook( struct Books book );</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   struct Books Book1;        /* 声明 Book1，类型为 Books */</span><br><span class="line">   struct Books Book2;        /* 声明 Book2，类型为 Books */</span><br><span class="line"> </span><br><span class="line">   /* Book1 详述 */</span><br><span class="line">   strcpy( Book1.title, &quot;C Programming&quot;);</span><br><span class="line">   strcpy( Book1.author, &quot;Nuha Ali&quot;); </span><br><span class="line">   strcpy( Book1.subject, &quot;C Programming Tutorial&quot;);</span><br><span class="line">   Book1.book_id = 6495407;</span><br><span class="line"> </span><br><span class="line">   /* Book2 详述 */</span><br><span class="line">   strcpy( Book2.title, &quot;Telecom Billing&quot;);</span><br><span class="line">   strcpy( Book2.author, &quot;Zara Ali&quot;);</span><br><span class="line">   strcpy( Book2.subject, &quot;Telecom Billing Tutorial&quot;);</span><br><span class="line">   Book2.book_id = 6495700;</span><br><span class="line"> </span><br><span class="line">   /* 输出 Book1 信息 */</span><br><span class="line">   printBook( Book1 );</span><br><span class="line"> </span><br><span class="line">   /* 输出 Book2 信息 */</span><br><span class="line">   printBook( Book2 );</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line">void printBook( struct Books book )</span><br><span class="line">&#123;</span><br><span class="line">   printf( &quot;Book title : %s\n&quot;, book.title);</span><br><span class="line">   printf( &quot;Book author : %s\n&quot;, book.author);</span><br><span class="line">   printf( &quot;Book subject : %s\n&quot;, book.subject);</span><br><span class="line">   printf( &quot;Book book_id : %d\n&quot;, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Book author : Nuha Ali</span><br><span class="line">Book subject : C Programming Tutorial</span><br><span class="line">Book book_id : 6495407</span><br><span class="line">Book title : Telecom Billing</span><br><span class="line">Book author : Zara Ali</span><br><span class="line">Book subject : Telecom Billing Tutorial</span><br><span class="line">Book book_id : 6495700</span><br></pre></td></tr></table></figure><p>指向结构的指针<br>可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似</p><p>struct Books *struct_pointer;<br>可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：</p><p>struct_pointer &#x3D; &Book1;<br>为了使用指向该结构的指针访问结构的成员，必须使用 -&gt; 运算符，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   char  title[50];</span><br><span class="line">   char  author[50];</span><br><span class="line">   char  subject[100];</span><br><span class="line">   int   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 函数声明 */</span><br><span class="line">void printBook( struct Books *book );</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   struct Books Book1;        /* 声明 Book1，类型为 Books */</span><br><span class="line">   struct Books Book2;        /* 声明 Book2，类型为 Books */</span><br><span class="line"> </span><br><span class="line">   /* Book1 详述 */</span><br><span class="line">   strcpy( Book1.title, &quot;C Programming&quot;);</span><br><span class="line">   strcpy( Book1.author, &quot;Nuha Ali&quot;); </span><br><span class="line">   strcpy( Book1.subject, &quot;C Programming Tutorial&quot;);</span><br><span class="line">   Book1.book_id = 6495407;</span><br><span class="line"> </span><br><span class="line">   /* Book2 详述 */</span><br><span class="line">   strcpy( Book2.title, &quot;Telecom Billing&quot;);</span><br><span class="line">   strcpy( Book2.author, &quot;Zara Ali&quot;);</span><br><span class="line">   strcpy( Book2.subject, &quot;Telecom Billing Tutorial&quot;);</span><br><span class="line">   Book2.book_id = 6495700;</span><br><span class="line"> </span><br><span class="line">   /* 通过传 Book1 的地址来输出 Book1 信息 */</span><br><span class="line">   printBook( &amp;Book1 );</span><br><span class="line"> </span><br><span class="line">   /* 通过传 Book2 的地址来输出 Book2 信息 */</span><br><span class="line">   printBook( &amp;Book2 );</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line">void printBook( struct Books *book )</span><br><span class="line">&#123;</span><br><span class="line">   printf( &quot;Book title : %s\n&quot;, book-&gt;title);</span><br><span class="line">   printf( &quot;Book author : %s\n&quot;, book-&gt;author);</span><br><span class="line">   printf( &quot;Book subject : %s\n&quot;, book-&gt;subject);</span><br><span class="line">   printf( &quot;Book book_id : %d\n&quot;, book-&gt;book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Book author : Nuha Ali</span><br><span class="line">Book subject : C Programming Tutorial</span><br><span class="line">Book book_id : 6495407</span><br><span class="line">Book title : Telecom Billing</span><br><span class="line">Book author : Zara Ali</span><br><span class="line">Book subject : Telecom Billing Tutorial</span><br><span class="line">Book book_id : 6495700</span><br></pre></td></tr></table></figure><h1 id="简单文件操作"><a href="#简单文件操作" class="headerlink" title="简单文件操作"></a>简单文件操作</h1><h2 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h2><p>基本格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line">fp = fopen(filename,mode); //filename 输入文件的地址mode 输入操作模式</span><br><span class="line">fclose(fp); //用了fopen一定要使用fclose进行关闭（代码规范）</span><br></pre></td></tr></table></figure><p>mode的操作模式</p><p>mode字符串对应的操作模式：</p><table><thead><tr><th align="center">读写方式</th><th align="center">文件类型</th><th align="left">含义</th><th align="center">读写方式</th><th align="center">文件类型</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">文本文件</td><td align="left">打开文本，只读</td><td align="center">rb+</td><td align="center">二进制文件</td><td align="left">打开二进制文件，读、覆盖写</td></tr><tr><td align="center">w</td><td align="center">文本文件</td><td align="left">建立文本文件，只写</td><td align="center">wb+</td><td align="center">二进制文件</td><td align="left">打开二进制文件，先写后读</td></tr><tr><td align="center">a</td><td align="center">文本文件</td><td align="left">打开文本文件，追加</td><td align="center">ab+</td><td align="center">二进制文件</td><td align="left">打开二进制文件，读，追加</td></tr><tr><td align="center">rb</td><td align="center">二进制文件</td><td align="left">打开二进制文件，只读</td><td align="center">rt</td><td align="center">文本文件</td><td align="left">打开文本文件，只读</td></tr><tr><td align="center">wb</td><td align="center">二进制文件</td><td align="left">建立二进制文件，只写</td><td align="center">wt</td><td align="center">文本文件</td><td align="left">建立文本文件，只写</td></tr><tr><td align="center">ab</td><td align="center">二进制文件</td><td align="left">打开二进制文件，读、追加</td><td align="center">at</td><td align="center">文本文件</td><td align="left">打开文本文件，追加</td></tr><tr><td align="center">r+</td><td align="center">文本文件</td><td align="left">打开文本文件，读、覆盖写</td><td align="center">rt+</td><td align="center">文本文件</td><td align="left">打开文本文件，读、覆盖写</td></tr><tr><td align="center">w+</td><td align="center">文本文件</td><td align="left">打开文本文件，先写后读</td><td align="center">wt+</td><td align="center">文本文件</td><td align="left">打开文本文件，先写后读</td></tr><tr><td align="center">a+</td><td align="center">文本文件</td><td align="left">打开文本文件，读、追加</td><td align="center">at+</td><td align="center">文本文件</td><td align="left">打开文本文件，读、追加</td></tr></tbody></table><p>三个基本模式：<br>“r”(read)模式总是打开一个已经存在的文件，如果文件不存在则出错。<br>“w”(write)模式建立一个新文件，如果文件已经存在，那么先删除存在的文件，再建立新文件<br>“a”(append)打开一个存在的文件，在文件的尾部追加数据。</p><p>三个追加符：<br>“b”(binary)表示二进制文件。<br>“t”(或默认)表示文本文件。<br>“+”表示将模式扩展为可读、可写方式。</p><p>注意：r+ 和 w+ 的区别是 找不到文件时 r+ 会返回NULL 无法进行<strong>读写</strong> ；w+ 会<strong>添加</strong>一个文件并进行<strong>写读</strong></p><h2 id="文件的一般打开方式-fopen（）"><a href="#文件的一般打开方式-fopen（）" class="headerlink" title="文件的一般打开方式 fopen（）"></a>文件的一般打开方式 fopen（）</h2><p>fopen()函数打开文件有可能失败。如用“r”模式打开不存在的文件，此时会返回一个空指针NULL。则程序无法继续输入&#x2F;输出数据。</p><p>故需要在打开文件时判断是否有错。</p><p>基本格式为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line">if((fp=fopen(filename,mode))==NULL)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;打开文件错误！\n&quot;);//可加可不加</span><br><span class="line">    exit(1);//由exit函数终止程序运行。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件的关闭-fclose（）"><a href="#文件的关闭-fclose（）" class="headerlink" title="文件的关闭 fclose（）"></a>文件的关闭 fclose（）</h2><p>文件打开的目的是为了读&#x2F;写，当文件使用完毕后，应当关闭文件。</p><p>关闭文件的三个目的:<br>1.保证文件的数据不丢失，将缓冲区中的数据回写文件。<br>2.释放缓冲区。<br>3.切断文件指针与文件的关联，使关闭后的文件指针可以用于打开其他文件。</p><h2 id="文件的读-写"><a href="#文件的读-写" class="headerlink" title="文件的读&#x2F;写"></a>文件的读&#x2F;写</h2><h3 id="字符输入-输出函数"><a href="#字符输入-输出函数" class="headerlink" title="字符输入&#x2F;输出函数"></a>字符输入&#x2F;输出函数</h3><h4 id="字符输出函数fputc"><a href="#字符输出函数fputc" class="headerlink" title="字符输出函数fputc()"></a>字符输出函数fputc()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fputc(ch,fp);//ch 输出的字符fp 文件指针变量</span><br></pre></td></tr></table></figure><p>写一个字符到fp对应文件的当前位置上</p><p>如果调用函数成功，则返回ch的值；如果失败，则返回值EOF(系统定义的宏，值为-1);</p><h4 id="字符输入函数fgetc"><a href="#字符输入函数fgetc" class="headerlink" title="字符输入函数fgetc()"></a>字符输入函数fgetc()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch=fgetc(fp);//fp 文件指针变量</span><br></pre></td></tr></table></figure><p>从fp对应的当前位置读一个字符。</p><p>如果调用成功，则返回读到的字符(赋值给ch);如果读到文件结束，则返回EOF(-1)。</p><h3 id="字符串输入-输出函数"><a href="#字符串输入-输出函数" class="headerlink" title="字符串输入&#x2F;输出函数"></a>字符串输入&#x2F;输出函数</h3><h4 id="字符串输入函数fgets"><a href="#字符串输入函数fgets" class="headerlink" title="字符串输入函数fgets()"></a>字符串输入函数fgets()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgets(str,n,fp);//str 字符指针或数组名n 整型量，说明输入字符串的最大长度(包括‘\0’)fp 文件指针</span><br></pre></td></tr></table></figure><p>从fp对应文件的当前位置，最多输入n-1个字符，在最后加‘\0’，之后放在str为首地址的内存中。</p><p>在输入过程中，如果遇到换行符或EOF，输入即结束。</p><p>函数正常调用，返回str的首地址，当出错或遇到文件结束标志时，返回NULL。</p><h4 id="字符串输出函数fputs"><a href="#字符串输出函数fputs" class="headerlink" title="字符串输出函数fputs()"></a>字符串输出函数fputs()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fputs(str,fp);//str 函数参数str是字符指针或数组名fp 文件指针</span><br></pre></td></tr></table></figure><p>将首地址是str的字符串输出到fp对应文件的当前位置，自动丢弃str后的‘\0’。</p><p>函数调用成功后返回值是0，否则是EOF。</p><p>在文件使用中，可采用标准的设备文件，系统为每一个设备指定了标准的文件指针名称。</p><h4 id="文件结束检测函数feof"><a href="#文件结束检测函数feof" class="headerlink" title="文件结束检测函数feof()"></a>文件结束检测函数feof()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feof(fp);//fp 文件指针变量</span><br></pre></td></tr></table></figure><p>判断文件是否处于文件结束位置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python的内存管理</title>
      <link href="/2024/05/03/Python%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2024/05/03/Python%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Python的内存管理机制"><a href="#Python的内存管理机制" class="headerlink" title="Python的内存管理机制"></a>Python的内存管理机制</h1><h2 id="内存的申请"><a href="#内存的申请" class="headerlink" title="内存的申请"></a>内存的申请</h2><p>python申请内存会调用_PyObject_Malloc 函数来进行函数的申请</p><p>当申请内存大于512个byte的时候会调用C的malloc函数来申请内存</p><p>小于512时就会调用下面的pymalloc_alloc。在调用pymalloc_alloc时会首先进行一个内存对齐。他会把你申请的内存大小都改为8的倍数，比如你申请1~8个byte内存他都会给你8个8byte，这样做的目的也是为了减少内存碎片的产生。当你对齐结束后，Python会去找对应大小的Pool里找一个没有使用的一个Block丢给你，这样就完成了一次内存的分配。同样的返还的时候也是返还到对应的Pool里而不是直接Free。会被加入到Pool里边的FreeBolck链表中去，标记成可用状态。这样做的好处就是不需要再去找系统申请空间。</p><p>Python一般不会直接Free内存，只会在Arena里面没有一个Pool的时候free空间，所以Python里对于空间的free都是在Arena这个层级进行操作的</p><p><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/03/Python%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20240104172510193.png?raw=true" alt="image-20240104172510193"></p><h2 id="python的内存管理层级"><a href="#python的内存管理层级" class="headerlink" title="python的内存管理层级"></a>python的内存管理层级</h2><p>为了减少内存碎片 python有一套自己的内存管理机制</p><p><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/03/Python%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20240104221757082.png?raw=true" alt="image-20240104221757082"></p><h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><p>一共有三个层级 最小的一层叫做Block</p><h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool:"></a>Pool:</h3><p>4k和一个内存页一样大,每一个Pool里都有相同大小的Block，一个Pool和另一个Pool之间他们拥有的Block的大小不一样大，但是每一个Pool的内部他们Block的大小都是相同的，</p><h3 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h3><p>Arena里有一个usedPools，usedPools是一个保存许多Pool指针的数组，而这个数组的下标对应着这个Pool的Block的大小 比如第0个Pool的Block的大小就是8个byte第1个就是16个Byte</p><p>256kArena里存放了许多的Pool 当Pool从没有使用到使用时 Block才会被使用，每一个Pool的大小是一样的但是Block的大小不一样，因此每一个Pool里存放的Block的数量也是不一样的。当Python 开始运行时会一般会建立16个Arena。在申请空间时候会优先给空间占据比较满的Arena使用 因此Arena实际上是Sort过的，这样就会保证Python不会使内存需求一直上升</p><h2 id="垃圾回收garba-coolction"><a href="#垃圾回收garba-coolction" class="headerlink" title="垃圾回收garba coolction"></a>垃圾回收garba coolction</h2><p>Python的一个最简单的垃圾回收机制是统计引用计数，也就是你每次引用一些东西的时候Python解释器会帮你数引用数，但是有的时候会出现循环引用的情况，导致释放了对象以后对象的一些属性依然在引用着对方，导致应用技术失效，这个时候就会用garba coolction来处理循环引用的问题</p><h3 id="容器-container"><a href="#容器-container" class="headerlink" title="容器(container)"></a>容器(container)</h3><p>所谓容器，就是可以引用其他对象的对象，比如List，Tuple 而 String int 就不是一个容器，也就不存在循环引用的问题。</p><p>所有容器类型的Object，在建立的时候就会告诉他你是一个容器 然后将这个Object放到垃圾回收的双向链表里，这也就是为什么Python找不到Object以后垃圾回收依然能找到这个Object</p><p>每一次触发垃圾回收的时候就会查找双向循环链表里有没有只剩下循环引用的容器，然后释放这个容器</p><h3 id="genneration"><a href="#genneration" class="headerlink" title="genneration"></a>genneration</h3><p>为什么要有genneration </p><p>因为在编程的过程中有大量的Object的生命周期非常短，用完就可以扔了，少部分变量生命周期非常长，如果我们把这些变量一直都放在链表里边，每次垃圾回收都需要检查一遍这些生命周期非常长的对象，而去判断一个变量是否循环引用是一非常耗时的工作，如果这些对象一直在这个链表里，程序会越跑越慢，因此我们会把这些生命周期非常长的对象复制到另一个genneration里 </p><p>在一个容器被创建时永远先存放在genneration0里边，每700次将这些东西合并到genneration1 genneration1 执行10次以后合并到genneration2里，达到一个分级管理的效果</p><p>但是genneration2 本身的对象大概率是不会被回收的，因此Cpython对垃圾回收做了一个优化的机制   genneration2中没有检测的对象的数量占总数量的25%以上的时候才会触发genneration2的垃圾回收</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络自顶向下方法</title>
      <link href="/2024/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
      <url>/2024/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-自顶向下方法"><a href="#计算机网络-自顶向下方法" class="headerlink" title="计算机网络 自顶向下方法"></a>计算机网络 自顶向下方法</h1><hr><h2 id="计算机网络与互联网"><a href="#计算机网络与互联网" class="headerlink" title="计算机网络与互联网"></a><strong>计算机网络与互联网</strong></h2><p>由节点和边构成的网络我们称其为计算机网络</p><p>从服务的角度看，计算机网络是分布式的应用进程和为分布式应用进程提供服务的基础设施。</p><h2 id="一些术语："><a href="#一些术语：" class="headerlink" title="一些术语："></a>一些术语：</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><h4 id="主机节点"><a href="#主机节点" class="headerlink" title="主机节点"></a>主机节点</h4><p>各种联网的设备，主机 服务器、包括联网的机顶盒，冰箱上运行的应用程序</p><p>主机节点和主机上运行的应用程序也被成为网络边缘</p><h4 id="数据交换节点："><a href="#数据交换节点：" class="headerlink" title="数据交换节点："></a>数据交换节点：</h4><p>交换机、路由器等网络交换设备</p><p>互联的路由器交换机也被成为网络核心</p><h3 id="边"><a href="#边" class="headerlink" title="边"></a>边</h3><p>通信链路</p><p>光纤、同轴电缆、无线电、卫星</p><p>传输速率 就是带宽bps （bit per second）单位是bit 而不是Byte 所以所谓的百兆带宽也就10M多的下载速度&#x3D;     &#x3D;</p><h4 id="接入网链路"><a href="#接入网链路" class="headerlink" title="接入网链路"></a>接入网链路</h4><p>主机连接到互联网的链路</p><h4 id="主干链路"><a href="#主干链路" class="headerlink" title="主干链路"></a>主干链路</h4><p>路由器之间的链路</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议是支撑互联网工作的标准，在通信过程中所要遵守的规则</p><p>协议定义了两个或多个通信实体之间交换的报文格式和次序，以及在报文传输或接收或其他事件方面所采取的动作</p><h3 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h3><p>Internet是网络的网络，是多个局域网相连得到的大的网络结构</p><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>网络分为了三个结构</p><p>边缘系统，核心系统和接入系统</p><p>边缘系统就是上面提到的主机节点以及主机节点上运行的程序 比如Web</p><p>核心系统就是上面的数据链路以及路由器以及交换机</p><p>接入系统把边缘系统接入到核心系统中从而达到互联的效果,</p><p>比如WIfi 再比如接入到家的光纤，卫星 等等 都算作接入网</p><h3 id="客户服务器模式"><a href="#客户服务器模式" class="headerlink" title="客户服务器模式"></a>客户服务器模式</h3><p>客户端向服务端发送请求接受服务</p><p>比如说浏览器—服务器    客户端—服务器</p><h3 id="对等（peer-peer）模式"><a href="#对等（peer-peer）模式" class="headerlink" title="对等（peer-peer）模式"></a>对等（peer-peer）模式</h3><p>很少甚至没有专门的服务器 在这个模式下 主机既可以是客户端又可以是服务器 我们可以向别人请求数据，别人也可以向我们请求数据（磁力链接&#x3D;  &#x3D;）</p><h3 id="采用网络设施的面向连接服务"><a href="#采用网络设施的面向连接服务" class="headerlink" title="采用网络设施的面向连接服务"></a>采用网络设施的面向连接服务</h3><p>在端与系统之间传输数据</p><h3 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h3><p>在传输数据之前做好准备，两个通信主机之间为连接建立状态</p><h3 id="TCP-传输控制协议（Transmission-Control-Protocol）"><a href="#TCP-传输控制协议（Transmission-Control-Protocol）" class="headerlink" title="TCP-传输控制协议（Transmission Control Protocol）"></a>TCP-传输控制协议（Transmission Control Protocol）</h3><p>是Internet上面向连接的服务</p><p>可以可靠的按顺序返回数据对数据做确认如果丢包会重新传输</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>保证数据不会淹没对方</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>当网络拥塞时，发送方降低传送速率</p><p>+++</p><h2 id="笔记："><a href="#笔记：" class="headerlink" title="笔记："></a>笔记：</h2><h3 id="网络核心："><a href="#网络核心：" class="headerlink" title="网络核心："></a>网络核心：</h3><p>网络资源（比如带宽）被分成片供个人使用，有按频率分片（Frequency-division-multiplexing），按时间分片(Time-division-multiplexing)，按波长分片(Wave-division-multiplexing)</p><p>网络核心的关键功能就是转发和路由</p><p>转发 就是将分组从路由器的输入链路转移到输出链路</p><p>路由 决定分组采用的源到目标的路径</p><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a><strong>电路交换</strong></h4><p>电路交换是在两个端到端之间分配出一条专用的网络供通信使用</p><p>端到端之间的资源被分配给从源端到目标端的呼叫叫做<strong>Call</strong></p><p>电路交换的好处是独享资源，每个呼叫建立起来就能够保证性能，不同于分组交换可能会受到网络拥堵造成的延迟和丢包。</p><p>如果建立通讯而没有使用就会造成资源的浪费</p><p>通常被传统电话网络使用而不用于计算机当中，因为建立连接时间长，计算机之间的通信具有突发性，如果使用线路交换，浪费的片比较多（即便这个片没有数据传递，其所占据的片也不能被别的呼叫使用）</p><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a><strong>分组交换</strong></h4><p>不同于电路交换，分组交换不再分为一个个的专用通道，而是使用全部的信道来通信</p><p>主机和主机之间的通讯被分为一个个的单位，而这个的单位我们称其为分组（packet）在每个交换节点间通过存储-转发的方式来进行传输</p><p>为什么要使用存储-转发的方式进行传输呢？ 因为如果你拿到一个bit就向其他交换机传输这一比特的话，就会同时占用两条信道，信道也就没有了共享的效果，变成了一个专用信道。</p><p>分组交换适合应对突发式的数据传输，因为其资源共享且简单不必建立呼叫，但是过度使用可能会造成<strong>网络拥塞</strong>（分组延时和丢包）对可靠的传输数据需要协议来约束。也就是<strong>拥塞控制</strong>。</p><h5 id="排队延迟"><a href="#排队延迟" class="headerlink" title="排队延迟"></a>排队延迟</h5><p>每台分组交换机都有多条链路相连，对于每条线路，都有一个输出缓存（也叫输出队列）</p><p>如果到达速率&gt;链路的传输速率，分组就会排队，等待输出</p><p>如果路由器的缓存用完了，分组就会抛弃，也就是丢包</p><h4 id="数据报的工作原理"><a href="#数据报的工作原理" class="headerlink" title="数据报的工作原理"></a>数据报的工作原理</h4><p>在通信前，无需建立连接，有数据就传输，每个分组都独立路由（路径不同，可能会失序），路由器根据分组的目标地址进行路由，</p><h3 id="接入网与物理媒体"><a href="#接入网与物理媒体" class="headerlink" title="接入网与物理媒体"></a>接入网与物理媒体</h3><h3 id="住宅接入-Modem"><a href="#住宅接入-Modem" class="headerlink" title="住宅接入 Modem"></a>住宅接入 Modem</h3><p>将上网数据调制加载到音频信号上，在电话线上传输，在局域将其中的数据解调出来，反之亦然</p><p>在互联网早期，由于专线接入家庭，成本高且收益差，所以使用电话线来做传输 有保证的带宽只有4KHz，在家里接入一个猫（光猫）也就是拨号调制解调器，这样就可以上网冲浪了（为什么叫冲浪呢，因为在音频的信号上 起起伏伏就和冲浪一样）</p><h5 id="拨号调制解调器"><a href="#拨号调制解调器" class="headerlink" title="拨号调制解调器"></a>拨号调制解调器</h5><p>56kbps的速率接入路由器，不能同时上网打电话，更不能总是在线</p><p>采用现有的电话线，但是根据频率，划分出用于音通信的部分，和上行带宽和下行带宽</p><h4 id="线缆网络"><a href="#线缆网络" class="headerlink" title="线缆网络"></a>线缆网络</h4><p>有线电视信号线缆双向改造，FDM在不同频段传输不同信道的数据，数字电视和上网数据（上下行）</p><p>铜芯线缆和光纤网络将各个家庭用户接入到ISP路由器，各个用户共享到线缆头端的接入网络</p><h4 id="企业接入网络"><a href="#企业接入网络" class="headerlink" title="企业接入网络"></a>企业接入网络</h4><p>被企业和大学采用，端系统直接接到以太网交换机上</p><h4 id="无线接入网络"><a href="#无线接入网络" class="headerlink" title="无线接入网络"></a>无线接入网络</h4><p>各无线端系统共享无线接入网络（端系统到无线路由器）</p><p>通过基站或者接入点</p><h5 id="无线LANs"><a href="#无线LANs" class="headerlink" title="无线LANs"></a>无线LANs</h5><p>靠路由器来接入互联网 在建筑物内部，11，54Mbps的传输速率</p><h5 id="广域无线接入"><a href="#广域无线接入" class="headerlink" title="广域无线接入"></a>广域无线接入</h5><p>由运营商提供1~10Mbps</p><p>3G，4G，LTE</p><h4 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h4><p>把互联网连接起来的介质</p><p>引导型媒体： 信号沿着固体媒介被导引比如同轴电缆、光纤、双绞线</p><h4 id="非引导媒体："><a href="#非引导媒体：" class="headerlink" title="非引导媒体："></a>非引导媒体：</h4><p>信号自由从传播：无线电</p><h5 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h5><p>两根绝缘铜线</p><h5 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h5><p>两根同心的铜导线 双向，有基带电缆和宽带电缆电缆上有多个信道</p><h5 id="光缆"><a href="#光缆" class="headerlink" title="光缆"></a>光缆</h5><p>光脉冲，每个脉冲表示一个bit，在玻璃纤维中传输</p><p>点到点高速传输 10Gbps~100Gbps传输速率</p><p>在两个中继器之间可以有很长距离，不受电磁噪声的干扰</p><h4 id="无线链路"><a href="#无线链路" class="headerlink" title="无线链路"></a>无线链路</h4><p>开放空间传输电磁波，携带需要传输的数据，无需线缆  LAN（WIFI）蜂窝 卫星</p><h4 id="Internet结构和ISP"><a href="#Internet结构和ISP" class="headerlink" title="Internet结构和ISP"></a>Internet结构和ISP</h4><p>在网络的最中心，一些为数不多的充分连接的大范围网络</p><p>ISP即网络服务提供商 比如中国联通、电信</p><p>第一层ISP 国家&#x2F;国际覆盖，速率极高，与大量的第二层ISP和其他客户网络相连</p><p>第二层ISP 区域性的ISP</p><p>POP高层ISP面对客户的接入点，设计费用结算</p><p>IXP 多个ISP对等互联互通的地方</p><p>很多内容提供商ICP比如Google Akamai会部署自己的网络，连接自己的数据中心，并且连接很多Local ISP和各级ISP 靠近自己用户</p><h3 id="分组交换-延时-吞吐量"><a href="#分组交换-延时-吞吐量" class="headerlink" title="分组交换 延时 吞吐量"></a>分组交换 延时 吞吐量</h3><h4 id="丢失和延迟产生的原因："><a href="#丢失和延迟产生的原因：" class="headerlink" title="丢失和延迟产生的原因："></a>丢失和延迟产生的原因：</h4><p>分组到达链路的速率超过了链路的输出的能力，就会丢失</p><h5 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h5><p>检查分组的首部和决定该分组导向何处需要的时间是处理时延的一部分，此外，包括检查比特级别的差错所需要的时间也是处理时延。</p><h5 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h5><p>在输出链路上等待的时间</p><p>排队延迟的长度取决于其路由器上的拥塞程度（前面排了多少分组）</p><p>流量强度 &#x3D; $\frac{分组长度*分组到达队列平均速率}{链路带宽}$</p><h5 id="传输延时"><a href="#传输延时" class="headerlink" title="传输延时"></a>传输延时</h5><p>R &#x3D; 链路带宽</p><p>L &#x3D; 分组长度</p><p>传输延时 &#x3D;  $\frac{L}{R}$</p><p>将分组转发到链路上的延时，也就是储存转发的延时。</p><h5 id="传播延时"><a href="#传播延时" class="headerlink" title="传播延时"></a>传播延时</h5><p>在物理链路上的传输时间（比如光纤，同轴双绞线之类的）</p><p>同样的 传播延时 &#x3D; $\frac{物理链路长度}{媒介上的传播速度}$</p><h5 id="Internet的延时和路由"><a href="#Internet的延时和路由" class="headerlink" title="Internet的延时和路由"></a>Internet的延时和路由</h5><p>沿着路径向每个路由器发送探测分组</p><p>路由器向发送方返回分组</p><p>发送方和回复之间间隔计时</p><h5 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h5><p>在源端和目标端的速率（$\frac{数据量}{单位时间}$）</p><p>瞬间吞吐量 在一个时间点的速率</p><p>平均吞吐量 长时间的平均值</p><h3 id="协议层次和服务模型"><a href="#协议层次和服务模型" class="headerlink" title="协议层次和服务模型"></a>协议层次和服务模型</h3><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>底层实体向上层提供他们之间通信的能力</p><p>服务用户</p><p>服务提供者</p><h4 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h4><p>上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的形式</p><p>说白了就是底层给的函数接口</p><h4 id="服务访问点"><a href="#服务访问点" class="headerlink" title="服务访问点"></a>服务访问点</h4><p>上层用下层提供服务通过层间接口的地点</p><p>比如邮箱</p><p>地址</p><p>端口</p><h4 id="服务的类型"><a href="#服务的类型" class="headerlink" title="服务的类型"></a>服务的类型</h4><h5 id="面向无连接的服务"><a href="#面向无连接的服务" class="headerlink" title="面向无连接的服务"></a>面向无连接的服务</h5><p>两个对等层实体在通信前不需要建立一个连接，不预留资源，不需要双方活跃</p><p>不可靠，可能重复，可能失序</p><p>IP分组 数据包</p><p>适合传送零星数据</p><h5 id="面向连接的服务"><a href="#面向连接的服务" class="headerlink" title="面向连接的服务"></a>面向连接的服务</h5><p>过程：</p><p>建立连接 通信 拆除连接</p><p>用于大数据块的传输</p><p>保序</p><h4 id="服务和协议的区别"><a href="#服务和协议的区别" class="headerlink" title="服务和协议的区别"></a>服务和协议的区别</h4><p>服务是底层向上层提供他们之间的通信 通过原语来操作</p><p>协议是对等实体之间相互通信需要遵守的规则</p><p>本层协议的实现选哟下层提供的服务来实现</p><p>本层实体通过的协议为上层提供更高级的服务</p><h4 id="分层实现的好处："><a href="#分层实现的好处：" class="headerlink" title="分层实现的好处："></a>分层实现的好处：</h4><p>概念化结构清晰</p><p>结构化 模块维护升级方便</p><h4 id="Internet协议栈"><a href="#Internet协议栈" class="headerlink" title="Internet协议栈"></a>Internet协议栈</h4><h5 id="应用层-网络应用"><a href="#应用层-网络应用" class="headerlink" title="应用层 网络应用"></a>应用层 网络应用</h5><p>为人类用户或者其他应用进程提供网络应用服务</p><p>FTP HTTP SMTP DNS</p><h5 id="传输层-主机之间数据传输"><a href="#传输层-主机之间数据传输" class="headerlink" title="传输层 主机之间数据传输"></a>传输层 主机之间数据传输</h5><p>在网络层提供的端到端基础上细分为进程到进程 把不可靠通信变为可靠通信</p><p>TCP UDP</p><h5 id="网络层-为数据报从源到目标选择路由"><a href="#网络层-为数据报从源到目标选择路由" class="headerlink" title="网络层 为数据报从源到目标选择路由"></a>网络层 为数据报从源到目标选择路由</h5><p>主机和主机之间的通信，端到端通信 不可靠</p><p>IP 路由协议</p><h5 id="链路层-相邻节点之间数据传输"><a href="#链路层-相邻节点之间数据传输" class="headerlink" title="链路层 相邻节点之间数据传输"></a>链路层 相邻节点之间数据传输</h5><p>相邻两个网络节点之间的数据传输</p><p>可靠或不可靠</p><h5 id="物理层-线路上传输bit"><a href="#物理层-线路上传输bit" class="headerlink" title="物理层 线路上传输bit"></a>物理层 线路上传输bit</h5><p>物理层的任务是将该帧的一个个比特从一 个节点移动到下一个节点</p><p> 接受端把物理信号转换为0 1</p><p>OSI模型</p><p>OSI模型在应用层和传输层之间加入了表示层和和会话层</p><h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>允许应用解释传输的数据 加密 压缩 机器相关的表示转换</p><h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>数据交换的同步 检查点 恢复</p><p>这两层在Internet协议里是 归应用层自己去做的</p><h4 id="封装与解封装"><a href="#封装与解封装" class="headerlink" title="封装与解封装"></a>封装与解封装</h4><p>在源端会做一个大的封装 每一层都把自己的头加在 传输数据里</p><p>各层次协议数据单元</p><p>应用层：报文 message</p><p>传输层 报文段 segment TCP段 UDP数据报</p><p>网络层 分组 packet</p><p>数据链路层 帧 frame</p><p>物理层 位 bit</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><strong>应用层</strong></h2><h4 id="网络应用体系结构"><a href="#网络应用体系结构" class="headerlink" title="网络应用体系结构"></a>网络应用体系结构</h4><h5 id="客户服务器模式-client-server"><a href="#客户服务器模式-client-server" class="headerlink" title="客户服务器模式 client server"></a>客户服务器模式 client server</h5><p>服务器 一直运行</p><p>有固定的IP地址和周知的端口号</p><p>扩展性差</p><p>客户端主动和服务器通信 </p><p>与互联网间歇性连接</p><h5 id="对等模式-p2p"><a href="#对等模式-p2p" class="headerlink" title="对等模式 p2p"></a>对等模式 p2p</h5><p>没有一个一直运行的服务 </p><p>任意端系统之间可以通信 每个节点技是客户端又是服务器</p><p>参与连接的主机可以间歇性改变IP地址</p><p>比如迅雷</p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>在主机上运行的应用程序</p><p>在同一个主机可以用进程间通信机制通信</p><p>不同主机可以通过交换报文来通信</p><p> 进程为了接受报文 必须有一个标识 SAP</p><h5 id="主机-唯一的32位地址"><a href="#主机-唯一的32位地址" class="headerlink" title="主机 唯一的32位地址"></a>主机 唯一的32位地址</h5><p>但是仅仅有Ip地址不能唯一的表示意给进程 因为一台设备上同时会有多个进程在运行</p><p>使用TCP 或者UDP进行传输</p><p>HTTP TCP 80 端口 默认web页面 TCP 25  ftp TCP 2</p><p>一个进程用 IP+port表示端节点</p><p>层间接口所需要的信息</p><p>要传输的报文</p><p>对方的应用标识（谁来传的）</p><p>对望应用进程标识（传给谁）</p><p><strong>报文段</strong></p><p>源端口号目标端口号 </p><p>将IP地址向下交给IP实体 用于封装IP数据段 源IP以及目标IP</p><p><strong>socket是本地IP 本地端口和对方 IP 对方端口的一个标识</strong></p><p><strong>TCP socket 是一个会话关系</strong></p><p>如果Socket 每次传输报文都携带这么多信息 太繁琐 不方便管理</p><p>所以使用代号标示通信的双方或单方 socket</p><p>Tcp socket</p><table><thead><tr><th>源IP</th><th>源端口</th><th>目标IP目标</th><th>端口</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>两个进程之间的通信需要之前建立连接 两个进程的通信会持续一段时间</p><p>可以用一个整数  表示 两个应用实体之间的通信关系</p><p>就像你经常寄东西 直接给你个标识码 就不用每次都填那么多东西了</p><p>穿过层间接口的信息量最小</p><p>源IP 源端口  目标IP 目标端口</p><p>UDP socket 没有目标IP和端口</p><p>因此每次传输数据的时候需要指定对方IP和端口</p><p>好处是 不用握手 少了建立连接的延时</p><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>运行在不同端系统上的应用进程如何互相交换报文</p><ul><li>交换的报文类型，请求和应答报文</li><li>各种报文类型的语法，报文的各个字段的描述</li><li>字段的语义</li><li>进程何时发送报文 对报文进行相应</li></ul><p>公开协议：</p><ul><li>允许互操作 </li><li>RFC文档定义</li><li>HTTP SMTP</li></ul><p>web应用 HTTP协议 Web客户端 HTML</p><h4 id="应用层对传输层提供服务的指标"><a href="#应用层对传输层提供服务的指标" class="headerlink" title="应用层对传输层提供服务的指标"></a>应用层对传输层提供服务的指标</h4><p>数据丢失率</p><ul><li>有些应用需要100%可靠传输（文件）</li><li>有些应用在一定比例的丢失无所谓（直播）</li></ul><p>延迟</p><ul><li>一些应用出于有效性考虑对时间有限制</li><li>打游戏 电话 上网冲浪</li></ul><p>吞吐</p><p>安全性</p><ul><li>机密</li><li>完整</li><li>可认证</li></ul><p>安全TCP</p><ul><li>TCP &amp; UDP</li><li>都没有加密</li><li>明文通过互联网传输，甚至密码</li></ul><p>SSL</p><ul><li>在TCP上面实现，提供加密的TCP连接</li><li>私密性</li><li>数据完整性</li><li>端到端的鉴别</li></ul><p>SSL在应用层</p><ul><li>应用采用SSL库，SSL库使用TCP通信</li></ul><p>SSL socket API</p><ul><li>应用通过API将明文交给socket，SSL将其加密在互联网上传输</li></ul><hr><h3 id="Web-and-Http"><a href="#Web-and-Http" class="headerlink" title="Web and Http"></a>Web and Http</h3><h4 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h4><p>HTTP即Hypertext Transfer Protocol 超文本传输协议</p><p>使用TCP</p><ul><li>客户发起一个与服务器的TCP连接 端口号为80</li><li>服务器接受客户的TCP连接</li><li>在浏览器与Web服务器交换HTTP报文</li><li>TCP连接关闭</li></ul><p>HTTP是无状态的</p><p>服务器并不维护关于客户的任何信息</p><p>非持久HTTP</p><ul><li>最多只有一个对象在TCP连接上发送</li><li>下载多个对象需要多个TCP链接</li><li>HTTP&#x2F;1.0使用非持久连接</li></ul><p>持久HTTP</p><p>多个对象可以在一个TCP链接上传输</p><p>HTTP&#x2F;1.1 默认使用持久HTTP </p><h4 id="响应时间模型"><a href="#响应时间模型" class="headerlink" title="响应时间模型"></a>响应时间模型</h4><p>往返时间 RTT</p><p>一个小的分组从客户端到服务器，再回到客户端的时间</p><p>响应时间</p><ul><li>一个RTT用来发起TCP连接</li><li>一个RTT用来HTTP请求 等待HTTP响应</li><li>文件传输时间</li></ul><p>$$<br>2RTT + 传输时间<br>$$</p><h4 id="持久HTTP"><a href="#持久HTTP" class="headerlink" title="持久HTTP"></a>持久HTTP</h4><p>非持久HTTP的缺点</p><ul><li><p>每个对象都需要两个RTT</p></li><li><p>操作系统必须为每个TCP连接分配资源</p></li><li><p>浏览器通常打开并行TCP连接，以获取引用对象</p></li></ul><p>持久HTTP</p><ul><li>服务器发送响应后仍保持TCP连接</li><li>在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送</li><li>客户端在遇到一个引用对象的时候，就可以尽快发送该对象的请求</li></ul><p>非流水方式的持久HTTP</p><ul><li><p>客户端在收到前一个响应后发送新请求</p></li><li><p>每个引用花费一个RTT</p></li></ul><p>流水方式的持久HTTP（并行处理）</p><ul><li>HTTP&#x2F;1.1的默认模式</li><li>客户端遇到一个引用对象就产生一个请求</li><li>所有引用的对象只花费一个RTT是可能的</li></ul><h4 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h4><p>HTTP有请求和响应两种格式的报文</p><p><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/image-20240125221710700.png?raw=true" alt="image-20240125221710700"></p><img src="/2024/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/image-20240125221710700.png" class title="This is an example image"><h5 id="提交表单输入"><a href="#提交表单输入" class="headerlink" title="提交表单输入"></a>提交表单输入</h5><p>POST</p><ul><li>网页通常包括表单输入</li><li>包含在实体主体中的输入被提交到服务器</li></ul><p>URL方式</p><p>GET</p><p>通过请求行的URL进行上载 （就是?xxx&#x3D;那玩意）</p><p>HTTP&#x2F;1.1</p><p>PUT</p><p>将实体主题的文件上载到URL规定的路径</p><p>DELETE</p><p>删除URL规定的文件</p><p>其实这俩都可以用POST替代</p><h4 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h4><p><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/image-20240125222950794.png?raw=true" alt="img"></p><h4 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h4><p>大多数主要的门户网站都使用cookies</p><ol><li>在HTTP报文中有一个cookies的首部行</li><li>在HTTP请求报文含有一个cookies的首部行</li><li>在用户端系统中保留有一个cookies文件 由用户的浏览器管理</li><li>在Web站点由一个后端数据库</li></ol><h4 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h4><ul><li>缓存既是客户端又是服务器</li><li>缓存一般由ISP安装</li></ul><p>使用Web缓存的好处</p><ul><li>降低客户端的请求响应时间</li><li>减少内部接入Internet接入链路的流量</li><li>采用缓存后较弱的ICP也能有效提供内容</li></ul><p>条件GET方法</p><ul><li>如果缓冲器中的对象拷贝是最新的，就不要发送对象</li><li>缓冲器 在HTTP请求中指定缓存拷贝日期</li><li>服务器 如果缓存拷贝陈旧，则响应报文没包含对象</li></ul><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>文件传输协议</p><p>向远程主机上传输文件或接受文件</p><p>端口号为21</p><p>FTP客户端与服务器通过21号端口联系 并使用TCP为传输协议</p><p>客户端通过控制连接获得身份确认（账号密码）这玩意比较古老都是明文传输</p><p>客户端通过控制连接发送命令浏览远程目录</p><p>收到传输命令时 服务器打开一个到客户端的数据连接</p><p>一个文件传输完成后服务器关闭连接</p><p>服务器打开第二个TCP数据连接用来传输另一个文件</p><p>FTP服务器维护用户的状态信息，当前路径 用户账户与控制连接对应</p><h3 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h3><p>三个主要组成部分</p><ul><li>用户代理</li><li>邮件服务器</li><li>简单邮件传输协议</li></ul><p>用户代理</p><ul><li>撰写编辑阅读邮件</li><li>比如Outlook</li><li>输出和输入邮件保存在服务器上</li></ul><p>邮件服务器</p><ul><li>邮箱中管理和维护发给用户的邮件</li><li>输出报文队列保存待发送邮件</li><li>邮件服务器之间的SMTP协议发送email报文<ul><li>客户发送邮件</li><li>接受端邮件服务器</li></ul></li></ul><h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><p>交换email报文的协议</p><ul><li>使用TCP在客户端和服务器之间传送报文</li><li>端口号为25</li><li>直接传输从发送方到接收方服务器</li><li>三个阶段<ul><li>握手</li><li>传输报文</li><li>关闭</li></ul></li><li>命令 响应<ul><li>命令 ASCII文本</li><li>响应 状态码和状态信息</li></ul></li><li>报文必须为7为ASCII码</li></ul><p>邮件服务器有一个队列 会攒一波 定期去发送</p><p>SMTP使用持久连接</p><p>SMTP 要求报文为7位ASCLII编码</p><p>SMTP服务器使用 CRLF CRLF决定报文的尾部</p><p>HTTP 拉 pull</p><p>SMTP 推 push</p><p>两者都是ASCII形式的命令 响应交互</p><p>HTTP 每个镀锡那个封装在各自的响应报文中</p><p>SMTP 多个对象包含在一个报文中</p><h4 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h4><p>首部行 to</p><p>From</p><p>Subject</p><p>主体 报文只能是ASCII字符</p><h5 id="多媒体扩展："><a href="#多媒体扩展：" class="headerlink" title="多媒体扩展："></a>多媒体扩展：</h5><p>MIME 多媒体邮件扩展</p><p>在报文首部用额外行申明MIME的内容类型</p><p>使用BASE64编码</p><p>Base64 是一种把不在ASCII中的编码改写成ASCII编码的一种格式</p><p>SMTP传送到接受方的邮件服务器</p><p>邮件访问协议 从服务器访问邮件</p><p>​POP邮局访问协议</p><p>用户身份确认 代理服务器并下载</p><p>HTTP：</p><p>方便</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>IP地址标识主机 路由器 </p><p>但是IP地址不好记忆 不便于人类使用</p><p>人类用户提供要访问机器的字符串名称</p><p>由DNS负责转换成为二进制的网络地址</p><p>DNS需要解决的问题：</p><ul><li><p>如何命名设备</p><ul><li><p>用有意义的字符串 好记 便于人类使用</p></li><li><p>剞劂一个平面命名的重名问题 层次化命名</p></li></ul></li><li><p>如何完成名字到IP地址的转换</p><ul><li>分布式的数据库维护和响应名字查询</li></ul></li></ul><p>DNS的总体思路</p><ul><li>分层的基于域的命名机制</li><li>若干分布式数据完成名字到IP地址的转换</li><li>运行在UDP之上端口号为53的应用服务</li><li>和兴Internet功能 但以应用层协议实现</li></ul><p>DNS主要目的</p><ul><li>实现主机名IP地址的转换</li><li>其他目的</li><li>邮件服务器别名到邮件服务器正规名字的转换</li><li>负载均衡</li></ul><p>DNS域名结构</p><p>一个层面的命名设备会有很多重名</p><p>DNS采用层次树状结构的命名方法</p><p>Internet根被分为几百个顶级域</p><p>通用的  .com .edu  .int .net .orrg</p><p>国家的  .cn .us .jp</p><p>每个子域下面可花费为若干个子域 </p><p>树叶是主机</p><h4 id="DNS名字空间"><a href="#DNS名字空间" class="headerlink" title="DNS名字空间"></a>DNS名字空间</h4><p>域名 从本域往上 直到树根</p><p>中间使用“.”间隔不同级别</p><p>例如 ustc.edu.cn</p><p>域的域名可标识一个域</p><p>主机的域名 一个域上的一个主机</p><h4 id="域名的管理"><a href="#域名的管理" class="headerlink" title="域名的管理"></a>域名的管理</h4><p>一个域管理其下的子域</p><p>.jp被划分为 ac.jp co.jp</p><p>.cn 被划分为edu.cn com.cn</p><p>域与物理网络无关</p><p>域遵从组织界限而不是物理网络</p><ul><li><p>一个域的主机可以不在一个网络</p></li><li><p>一个网路哦哦对主机不一定在一个域</p></li></ul><p>域的划分是逻辑的，而不是物理的</p><p>区域</p><ul><li><p>区域的花费由区域管理者自己决定</p></li><li><p>将DNS名字空间划分为互不相交的区域你没u给区域都是树的一部分</p></li></ul><p>名字服务器</p><ul><li>每个区域都有一个名字服务器 维护着他所管辖区域的权威信息</li><li>名字服务允许放置在区域之外 以保证可靠性</li></ul><p>TLD服务器 </p><ul><li>顶级域服务器负责顶级域名 比如.com .org .net 和所有国家的域.cn .uk </li><li>Network solutions 公司维护com TLD服务器</li><li>Educause 公司维护edu TLD 服务器</li></ul><p>本地名字服务器</p><ul><li>并不严格属于层次结构</li><li>每个ISP都有一个本地DNS服务器也称为 默认名字服务器</li><li>当一个追发起一个DNS查询时查询到其本地DNS服务器</li><li>起着代理的作用 将查询转发到层次结构中</li></ul><p>迭代查询</p><p>主机 cis.poly.edu 想知道主机 gaia.cs.umass.edu的IP地址</p><p>更服务器返回的不是查询结果而是下个NS的地址</p><p>最后由权威名字服务器给出解析结果</p><p>当前联络的服务器给出可以联系的服务器的名字</p><p>我不知道这个名字 但是可以向则会个服务器请求</p><p>DNS协议 报文</p><p>DNS协议 查询和响应的报文的报文格式相同</p><p>报文首部 标识符 id 16位</p><p>flasgs</p><ul><li>查询 应答</li><li>希望递归</li><li>递归可用</li><li>应答权威</li></ul><p>提高性能 缓存</p><ul><li><p>一旦名字服务器 学到了一个映射就将该映射缓存起来</p></li><li><p>更服务器通常都在本地服务器中缓存着</p><ul><li>使得根服务器 不用经常被访问</li></ul><p>目的 提高效率</p><p>可能存在的问题 如果情况变化 缓存结果和权威资源记录不一致</p><p>解决方法 TTL（默认两天）</p></li></ul><p>新增一个域</p><ul><li>在上级域的名字服务器加两条记录 指向这个域 和域名服务器地址</li><li>在新增子域的名字服务器上运行名字服务器 负责本域名字解析 名字-&gt;IP</li></ul><h3 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h3><p>没有或极少一直运行的服务器</p><p>任意端之间可直接通信</p><p>Peer节点间歇上网 每次IP地址都有可能变化</p><ul><li>文件分发</li><li>流媒体</li><li>VOIP</li></ul><p>C&#x2F;S模式</p><ul><li>服务器传输 都是由服务器发送给peer 服务器必须顺序传输N个文件拷贝</li></ul><p>客户端必须下载一个文件拷贝</p><p>$d_{min}$ &#x3D; 客户端最小的下载速率</p><p>下载代开你最小的客户端下载的时间： F&#x2F;$d_{min}$</p><p>采用C-S方法将一个F大小的文件分发给N个客户端耗时<br>$$<br>D_{C-S}&gt;max{NF&#x2F;U_{s}},F&#x2F;d_{min}<br>$$<br>P2P模式</p><p>服务器传输： 最少需要上载一份拷贝</p><ul><li>发送一个拷贝的时间 F&#x2F;us</li></ul><p>客户端 每个客户端必须下载一个拷贝</p><p>所有客户端总体下载量NF</p><ul><li>最大上载带宽是u + $\sum u$</li><li>除了服务器可以上载 其他所有的peer节点都可以上载</li></ul><p>P2P系统与客户端服务器模式不同的是随着请求数量的增加 提供服务的人也增加 性能高 并且可扩展性好</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>Content Distribution Networks（内容分发网络）</p><p>流化播放 边下边看（有缓存）减少带宽和等待时间</p><h4 id="多媒体流化服务-DASH"><a href="#多媒体流化服务-DASH" class="headerlink" title="多媒体流化服务 DASH"></a>多媒体流化服务 DASH</h4><p>服务器：</p><ul><li>将视频文件分割成多个块</li><li>每个块独立存储，编码与不同码率</li><li>告示文件： 提供不同的URL</li></ul><p>客户端</p><ul><li>先获取告示文件</li><li>周期性的测量服务器到客户端的带宽</li><li>查询告示文件在一个时刻请求一个块 HTTP指定直接范围<ul><li>如果带宽够请求最大码率</li><li>不同时刻请求不同的编码块</li></ul></li><li>智能客户端 动态的决定请求什么视频块</li></ul><p>通过CDN 全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验  俗称内容加速服务</p><p>enter deep 将CDN服务器深度到接入网</p><ul><li>更接近用户 数量多，离用户近</li><li>Akamai 1700个位置</li></ul><p>bring home 部署在关键位置</p><ul><li>采用租用线路将服务器连接</li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>Socket编程</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a><strong>传输层</strong></h2><p>传输服务和协议</p><ul><li><p>为用韵在不同主机上的应用进程提供逻辑通信</p></li><li><p>传输协议运行在端系统</p><ul><li>发送方将应用层报文分为报文段，然后传递给网络层</li><li>接收方 将报文段重组成报文 然后传递给应用层</li></ul><p>有多个传输层协议可供应用选择：</p><p>TCP UDP</p></li></ul><p>网络层提供主机间的逻辑通信</p><p>传输层提供进程间的逻辑通信</p><ul><li>依赖网络层的服务器</li><li>对网络层的服务进行增强</li></ul><p>+++</p><h3 id="多路复用和解复用"><a href="#多路复用和解复用" class="headerlink" title="多路复用和解复用"></a>多路复用和解复用</h3><ul><li>解复用作用： TCP或者UDP实体采用那些信息，将报文段数据部分交给正确的socket 从而交给正确的进程</li><li>主机收到IP数据报<ul><li>每个数据报有源IP地址和目标地址</li><li>每个数据报承载一个传输层报文段</li><li>每个报文段有一个源端口号和目标端口号</li></ul></li><li>主机使用IP地址和端口号将报文发送给合适的套接字</li></ul><h3 id="无连接传输UDP"><a href="#无连接传输UDP" class="headerlink" title="无连接传输UDP"></a>无连接传输UDP</h3><p>UDP socket 没有目标IP和端口</p><p>因此每次传输数据的时候需要指定对方IP和端口</p><p>好处是 不用握手 少了建立连接的延时</p><h5 id="UDP校验和"><a href="#UDP校验和" class="headerlink" title="UDP校验和"></a>UDP校验和</h5><p>发送方</p><ul><li>将报文的内容视为16比特的整数</li><li>校验和： 报文段的加法和（1的补运算）</li><li>发送方将校验和放在UDP的校验和字段</li></ul><p>接受方：</p><p>计算收到的报文段的校验和</p><p>检查计算出的校验和与检验的字段内容是否相等</p><ul><li>不相等  检查到差错</li><li>相等 没有检查出差错 但是可能还有差错</li></ul><p>对两个16bit相加后取反码运算 将其加起来（1变0 0变1）如果溢出就回卷（把溢出位加到最后一位）如果分组没有差错结果应该是16个1</p><h3 id="可靠传输的原理"><a href="#可靠传输的原理" class="headerlink" title="可靠传输的原理"></a>可靠传输的原理</h3><p>底层的IP协议是不可靠，而实现在不可靠的基础上实现可靠，就是可靠传输 比如TCP</p><h5 id="不可靠信道的传输"><a href="#不可靠信道的传输" class="headerlink" title="不可靠信道的传输"></a>不可靠信道的传输</h5><p>rdt2.0</p><p>就像打电话一样 对方如果和你说一个事情 你听懂了 你就和他说 好 行（肯定确认） 如果你听不懂对方的话 那你就可以要求其给你重新说一遍（否定确认）</p><p>这就是自动请求重传协议 ARQ</p><p>ARQ需要差错检测 接收方反馈 重传来实现</p><p>但是实际上 肯定确认和否定确认也有可能没有成功传输</p><p>一个解决办法是当手段哦哦含糊不清的 确认时重新传输当前的数据即可，但是这样可能会造成冗余，因此TCP在数据分组上添加了序号 这样就知道数据有没有被重传。</p><p>但是实际上底层的网络层可能也会出现丢包 双方都接受不到对方的消息造成死锁</p><p> 所以引入一个超时重传机制 发送方如果长时间没有收到ACK那么就重传</p><p>需要一个倒计时定时器</p><p>rdt3.0的可靠性很好，但是性能并不好 因为他是一个停等协议 当链路比较长的时候，发送方只有很少的时间在工作，这使得效率十分堪忧 </p><h5 id="流水线协议"><a href="#流水线协议" class="headerlink" title="流水线协议"></a>流水线协议</h5><p>流水线：允许发送方在未得到对方确认的情况下一次发送多个分组</p><ul><li>必须增加序号的范围 用多个bit表示分组的序号</li><li>在发送方接收方要有缓存区</li></ul><p>发送方的缓冲区用于超时重发 接收方的缓冲区是因为发送方发送的速度和接收方提取的速率是不一样的因此需要一个缓存来抵消这种不一致</p><h5 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h5><ul><li>发送缓冲区<ul><li>内存中的一个区域，，落入缓冲区的分组可以发送</li><li>用于存放已发送，但是没有得到确认的分组</li><li>需要重发时可用</li></ul></li><li>发送缓冲区的大小:一次最多可以发送多少个未经确认的分组<ul><li>停止等待协议&#x3D;1</li><li>流水线协议&gt;1，合理的值，不能很大，链路利用率不能够超100%口发送缓冲区中的分组</li><li>未发送的:落入发送缓冲区的分组，可以连续发送出去;</li></ul></li><li>发送缓冲区中的分组<ul><li>未发送的:落入发送缓冲区的分组，可以连续发送出去;</li><li>已经发送出去的、等待对方确认的分组:发送缓冲区的分组只有得到确认才能删除</li></ul></li></ul><p>和滑动窗口一样 只不过这是一个循环队列 每当发送一个右指针向前 当接受到对方返回的ask的时候左指针向前</p><p>GBN </p><ul><li><p>只发送ACK 对顺序接受最高序号的分组</p><ul><li>可能会产生重复的ACK</li></ul></li><li><p>对乱序的分组</p><ul><li>丢弃</li><li>对顺序接受的最高序号进行确认累积</li></ul><p><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/image-20240223002144709.png?raw=true" alt="image-20240223002144709"></p></li></ul><p>选择重传：</p><p><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/image-20240223002244415.png?raw=true" alt="image-20240223002244415"></p><h3 id="面向传输的连接TCP"><a href="#面向传输的连接TCP" class="headerlink" title="面向传输的连接TCP"></a>面向传输的连接TCP</h3><ul><li>点对点:<ul><li>一个发送方，一个接收方</li></ul></li><li>可靠的、按顺序的字节流<ul><li>没有报文边界</li></ul></li><li>管道化(流水线):<ul><li>TCP拥塞控制和流量控制设置窗口大小</li></ul></li><li>全双工数据:<ul><li>在同一连接中数据流双向流动</li><li>MSS最大报文段大小</li></ul></li><li>发送和接收缓存</li><li>面向连接<ul><li>在数据交换之前，通过握手初始化发送方和接收方的状态变量</li></ul></li><li>有流量控制<ul><li>发送方不会淹没接收方·0</li></ul></li></ul><h5 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h5><p><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/image-20240225200014366.png?raw=true" alt="image-20240225200014366"></p><p>序号</p><ul><li>报文段首字节的在字节流的编号（从多少开始发 ）</li></ul><p>确认号</p><ul><li>期望从另一方收到的下一个字节的序号（比如说55意思是55之前的我已经收到了希望你从55及之后开始发）</li><li>累计确认</li></ul><p>往返延迟和超时</p><ul><li>比RTT要长</li></ul><p>SampleRTT 测量报文段发出到收到确认的时间</p><ul><li><p>如果有重传 忽略这次测量</p></li><li><p>SampleRTT会变化 因此估计的RTT应该比较平滑</p><ul><li>对最近的几个测量值求平均 而不是用当前的SampleRTT</li></ul></li></ul><p>$$<br>EstimatedRTT&#x3D;(1-a)<em>EstimatedRTT+a</em>sampleRTT<br>$$</p><ul><li>指数加权移动平均</li><li>过去样本的影响呈指数衰减</li><li>推荐值:a &#x3D;0.125</li></ul><p>因此公式变为<br>$$<br>EstimatedRTT&#x3D;0.875<em>EstimatedRTT + 0.125</em>sampleRTT<br>$$<br>EstimtedRTT+安全边界时间</p><ul><li>EstimatedRTT变化大(方差大)→较大的安全边界时间</li></ul><p>SampleRTT会偏离EstimatedRTT多远:</p><ul><li><p>$$<br>DevRTT &#x3D;(1-β)<em>DevRTT +β</em>|SampleRTT-EstimatedRTT|<br>$$</p></li><li><p>推荐值  &#x3D; $β$ &#x3D; 0.25</p></li></ul><p>超时时间间隔设置为:<br>$$<br>TimeoutInterval&#x3D;EstimatedRTT +4*DevRTT<br>$$<br>可靠数据传输</p><h5 id="快速重传："><a href="#快速重传：" class="headerlink" title="快速重传："></a>快速重传：</h5><p>如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK（其实是收到4个同样的ACK，第一个是正常的，后三个才是冗余的），发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出，大大提高了效率。这便是快速重传机制。</p><p>快速重传机制是GBN和SR协议的混合体</p><h5 id="流量控制-1"><a href="#流量控制-1" class="headerlink" title="流量控制"></a>流量控制</h5><p>通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力</p><p>接收方控制发送方发，不让发送的太多、太快以至于让接收方的缓冲区溢出</p><p>缓存中的可用的空间<br>$$<br>&#x3D;RcvBuffer-[LastByteRcvd-astByteRead]<br>$$</p><h5 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h5><p>在正式交换数据之前，发送方和接收方握手建立通信关系：</p><ul><li>同意建立连接</li><li>同意连接参数</li></ul><p>Q:在网络中，2次握手建立连接总是可行吗?</p><ul><li>变化的延迟(连接请求的段没有丢，但可能超时)</li><li>由于丢失造成的重传(e.9greq_conn(x))</li><li>报文乱序</li><li>相互看不到对方</li></ul><p>导致服务器维护了大量的虚假的半连接 每次建立连接都要开辟一片缓存区域 长此以往使得资源耗尽</p><h6 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a><em><strong>TCP三次握手</strong></em></h6><h6 id="TCP-三次握手过程是怎样的？"><a href="#TCP-三次握手过程是怎样的？" class="headerlink" title="TCP 三次握手过程是怎样的？"></a>TCP 三次握手过程是怎样的？</h6><p>TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而<strong>建立连接是通过三次握手来进行的</strong>。三次握手的过程如下图：</p><p><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png?raw=true" alt="TCP 三次握手"></p><ul><li>一开始，客户端和服务端都处于 <code>CLOSE</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li></ul><p><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/format,png-20230309230500953.png?raw=true" alt="第一个报文 —— SYN 报文"></p><ul><li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code>，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li></ul><p><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/format,png-20230309230504118.png?raw=true" alt="第二个报文 —— SYN + ACK 报文"></p><ul><li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li></ul><p><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/format,png-20230309230508297.png?raw=true" alt="第三个报文 —— ACK 报文"></p><ul><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li><li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li></ul><p>从上面的过程可以发现<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>，这也是面试常问的题。</p><p>一旦完成三次握手，双方都处于 <code>ESTABLISHED</code> 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了</p><p> TCP 关闭连接</p><ul><li>客户端，服务器分别关闭它自己这一侧的连接·发送FIN bit&#x3D;1的TCP段</li><li>一旦接收到FIN，用ACK回应接到FIN段，ACK可以和它自己发出的FIN段一起发送</li><li>可以处理同时的FIN交换</li></ul><p>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图：</p><p><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/format,png-20230309230614791.png?raw=true" alt="客户端主动关闭连接 —— TCP 四次挥手"></p><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li></ul><p>你可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p><p>这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p><h6 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a><a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%A5%E6%89%8B%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1">为什么挥手需要四次？</a></h6><p>再来回顾下四次挥手双方发 <code>FIN</code> 包的过程，就能理解为什么需要四次了。</p><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，因此是需要四次挥手。</p><h3 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h3><p>为什么有了流量控制还要有拥塞控制</p><p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p><p>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。</p><p>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p><p>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。</p><p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p><p>我们在前面提到过发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd &#x3D; min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p><p>拥塞窗口 <code>cwnd</code> 变化的规则：</p><ul><li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li><li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li></ul><p>只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p><p>拥塞控制方法·</p><ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发生</li><li>快速恢复</li></ul><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量</p><p>慢启动的算法 ：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong></p><p>这里假定拥塞窗口 <code>cwnd</code> 和发送窗口 <code>swnd</code> 相等，下面举个栗子：</p><ul><li>连接建立完成后，一开始初始化 <code>cwnd = 1</code>，表示可以传一个 <code>MSS</code> 大小的数据。</li><li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li><li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li><li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li></ul><p>可以看出慢启动算法，发包的个数是<strong>指数性的增长</strong>。</p><blockquote><p>那慢启动涨到什么时候是个头呢？</p></blockquote><p>有一个叫慢启动门限 <code>ssthresh</code> （slow start threshold）状态变量。</p><ul><li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</li><li>当 <code>cwnd</code> &gt;&#x3D; <code>ssthresh</code> 时，就会使用「拥塞避免算法」。</li></ul><h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><p>当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法。</p><p>一般来说 <code>ssthresh</code> 的大小是 <code>65535</code> 字节。</p><p>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd。</strong></p><p>接上前面的慢启动的栗子，现假定 <code>ssthresh</code> 为 <code>8</code>：</p><ul><li>当 8 个 ACK 应答确认到来时，每个确认增加 1&#x2F;8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 <code>MSS</code> 大小的数据，变成了<strong>线性增长。</strong></li><li><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/28.jpg?raw=true" alt="拥塞避免"></li></ul><p>拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p><p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p><p>当触发了重传机制，也就进入了「拥塞发生算法」。</p><h4 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h4><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p><ul><li>超时重传</li><li>快速重传</li></ul><p>当发生了「超时重传」，则就会使用拥塞发生算法。</p><p>这个时候，ssthresh 和 cwnd 的值会发生变化：</p><ul><li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li><li><code>cwnd</code> 重置为 <code>1</code> （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）</li></ul><p>接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。</p><p>就好像本来在秋名山高速漂移着，突然来个紧急刹车，轮胎受得了吗。。。</p><blockquote><p>发生快速重传的拥塞发生算法</p></blockquote><p>还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p><p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 <code>ssthresh</code> 和 <code>cwnd</code> 变化如下：</p><ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li><li>进入快速恢复算法</li></ul><h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。</p><p>正如前面所说，进入快速恢复之前，<code>cwnd</code> 和 <code>ssthresh</code> 已被更新了：</p><ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li></ul><p>然后，进入快速恢复算法如下：</p><ul><li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul><h3 id="TCP拥塞"><a href="#TCP拥塞" class="headerlink" title="TCP拥塞"></a>TCP拥塞</h3><h2 id="网络层：数据平面"><a href="#网络层：数据平面" class="headerlink" title="网络层：数据平面"></a><strong>网络层：数据平面</strong></h2><p>网络层的服务</p><ul><li>在发送主机和接收主机对之间传送段(segment)</li><li>在发送端将段封装到数据报中</li><li>在接收端，将段上交给传输层实体</li><li>网络层协议存在于每一个主机和路由器</li><li>路由器检查每一个经过它的IP数据报的头部</li></ul><p>网络层的功能</p><ul><li>转发：将分组从路由器的输入接口转发到合适的输出接口</li><li>路由： 使用路由算法来决定分组从发送主机到目标接受主机的路径</li></ul><p>转发是单个路口的过程</p><p>路由是源目标到目的的路径规划的过程</p><p>其实好像就算是 控制平面是网络层做的事情 数据平面是网络层的功能</p><p>数据平面：</p><ul><li>本地，每个路由器功能</li><li>决定从路由器输入端口到达的分组如何转发到输出端口</li><li>转发功能：<ul><li>传统方式基于目标地址和转发表</li><li>SDN方式 基于多个字段+流表</li></ul></li></ul><p>SDN其实可以理解为有一大堆机器算路由表 然后分发给路由器把控制平面从路由器剥离出来 达到解耦合的目的</p><p>控制平面</p><ul><li><p>网络范围内的逻辑</p></li><li><p>决定数据报如何在路由器之间路由，决定数据报从源到目标主机之间的端到端路径”</p></li><li><p>2个控制平面方法:</p><ul><li><p>传统的路由算法:在路由器中被实现</p></li><li><p>software-definednetworking(SDN):在远程的服务器中实现</p></li></ul></li><li><p>连接建立<br>在某些网络架构中是第三个重要的功能O ATM, frame relay,X.25</p></li><li><p>在分组传输之前，在两个主机之间，在通过一些路由器所构成的路径上建立一个网络层连接</p><ul><li>涉及到路由器</li></ul></li><li><p>网络层和传输层连接服务区别:</p><ul><li>网络层:在2个主机之间，涉及到路径上的一些路由器</li><li>传输层:在2个进程之间，很可能只体现在端系统上(TCP连接)</li></ul></li></ul><hr><h3 id="路由器组成"><a href="#路由器组成" class="headerlink" title="路由器组成"></a>路由器组成</h3><h3 id="IP-internet-Protocol"><a href="#IP-internet-Protocol" class="headerlink" title="IP internet Protocol"></a>IP internet Protocol</h3><h3 id="通用转发SDN"><a href="#通用转发SDN" class="headerlink" title="通用转发SDN"></a>通用转发SDN</h3><h2 id="网络层：控制平面"><a href="#网络层：控制平面" class="headerlink" title="网络层：控制平面"></a><strong>网络层：控制平面</strong></h2><hr><h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><h3 id="自治系统内部的路由选择"><a href="#自治系统内部的路由选择" class="headerlink" title="自治系统内部的路由选择"></a>自治系统内部的路由选择</h3><h3 id="ISP之间的路由选择-BGP"><a href="#ISP之间的路由选择-BGP" class="headerlink" title="ISP之间的路由选择  BGP"></a>ISP之间的路由选择  BGP</h3><h3 id="SDN控制平面"><a href="#SDN控制平面" class="headerlink" title="SDN控制平面"></a>SDN控制平面</h3><h2 id="数据链路层和局域网"><a href="#数据链路层和局域网" class="headerlink" title="数据链路层和局域网"></a><strong>数据链路层和局域网</strong></h2><hr><h3 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h3><h3 id="多点访协议"><a href="#多点访协议" class="headerlink" title="多点访协议"></a>多点访协议</h3><h3 id="LANs"><a href="#LANs" class="headerlink" title="LANs"></a>LANs</h3><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a><strong>网络安全</strong></h2><hr><h3 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h3><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><h3 id="报文完整性"><a href="#报文完整性" class="headerlink" title="报文完整性"></a>报文完整性</h3><h3 id="密钥分发和证书"><a href="#密钥分发和证书" class="headerlink" title="密钥分发和证书"></a>密钥分发和证书</h3><h3 id="各个层次的安全性"><a href="#各个层次的安全性" class="headerlink" title="各个层次的安全性"></a>各个层次的安全性</h3><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><h3 id="攻击和对策"><a href="#攻击和对策" class="headerlink" title="攻击和对策"></a>攻击和对策</h3><h2 id="无线和移动网络"><a href="#无线和移动网络" class="headerlink" title="无线和移动网络"></a><strong>无线和移动网络</strong></h2><hr><h3 id="软件定义网络"><a href="#软件定义网络" class="headerlink" title="软件定义网络"></a>软件定义网络</h3><h3 id="命名数据网络"><a href="#命名数据网络" class="headerlink" title="命名数据网络"></a>命名数据网络</h3><h2 id="多媒体网络"><a href="#多媒体网络" class="headerlink" title="多媒体网络"></a><strong>多媒体网络</strong></h2><p>TODO：</p><h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a><strong>网络管理</strong></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 计网 </tag>
            
            <tag> http </tag>
            
            <tag> TCP&#92;IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP2的问题</title>
      <link href="/2024/05/02/HTTP2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/02/HTTP2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h1><h2 id="HTTP-2-的问题"><a href="#HTTP-2-的问题" class="headerlink" title="HTTP&#x2F;2 的问题"></a><strong>HTTP&#x2F;2 的问题</strong></h2><p><strong>队头阻塞</strong></p><p><strong>HTTP&#x2F;2解决了HTTP的队头阻塞问题，但是并没有解决TCP队头阻塞问题！</strong></p><p>HTTP&#x2F;1.1相比较于HTTP&#x2F;1.0来说，最主要的改进就是引入了持久连接（keep-alive）。</p><p><strong>所谓的持久连接就是：在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。</strong></p><p>引入了持久连接之后，在性能方面，HTTP协议有了明显的提升。</p><p>HTTP&#x2F;1.1允许在持久连接上使用请求管道，是相对于持久连接的又一性能优化。</p><p>所谓请求管道，就是在HTTP响应到达之前，可以将多条请求放入队列，当第一条HTTP请求通过网络流向服务器时，第二条和第三条请求也可以开始发送了。在高时延网络条件下，这样做可以降低网络的环回时间，提高性能。</p><p><strong>但是，对于管道连接还是有一定的限制和要求的，其中一个比较关键的就是服务端必须按照与请求相同的顺序回送HTTP响应。</strong></p><p>这也就意味着，如果一个响应返回发生了延迟，那么其后续的响应都会被延迟，直到队头的响应送达。这就是所谓的<strong>HTTP队头阻塞</strong>。</p><p>但是HTTP队头阻塞的问题在HTTP&#x2F;2中得到了有效的解决。<strong>HTTP&#x2F;2废弃了管道化的方式</strong>，而是创新性的引入了帧、消息和数据流等概念。<strong>客户端和服务器可以把 HTTP 消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来。</strong></p><p><strong>因为没有顺序了，所以就不需要阻塞了，就有效的解决了HTTP对头阻塞的问题。</strong></p><p>但是，HTTP&#x2F;2仍然会存在对头阻塞的问题，那是因为HTTP&#x2F;2其实还是依赖TCP协议实现的。</p><p>TCP传输过程中会把数据拆分为一个个<strong>按照顺序</strong>排列的数据包，这些数据包通过网络传输到了接收端，接收端再<strong>按照顺序</strong>将这些数据包组合成原始数据，这样就完成了数据传输。</p><p>但是如果其中的某一个数据包没有按照顺序到达，接收端会一直保持连接等待数据包返回，这时候就会阻塞后续请求。这就发生了<strong>TCP队头阻塞</strong>。</p><p>HTTP&#x2F;1.1的管道化持久连接也是使得同一个TCP链接可以被多个HTTP使用，但是HTTP&#x2F;1.1中规定一个域名可以有6个TCP连接。而HTTP&#x2F;2中，同一个域名只是用一个TCP连接。</p><p>所以，<strong>在HTTP&#x2F;2中，TCP对头阻塞造成的影响会更大</strong>，因为HTTP&#x2F;2的多路复用技术使得多个请求其实是基于同一个TCP连接的，那如果某一个请求造成了TCP队头阻塞，那么多个请求都会受到影响。</p><h2 id="升级TCP是否可行？"><a href="#升级TCP是否可行？" class="headerlink" title="升级TCP是否可行？"></a><strong>升级TCP是否可行？</strong></h2><p>基于上面我们提到的这些问题，很多人提出来说：既然TCP存在这些问题，并且我们也知道这些问题的存在，甚至解决方案也不难想到，为什么不能对协议本身做一次升级，解决这些问题呢？</p><p>这就涉及到一个”<strong>协议僵化</strong>“的问题。</p><p>我们知道的，想要在家里使用网络有几个前提，首先我们要通过运行商开通网络，并且需要使用路由器，而路由器就是网络传输过程中的一个中间设备。</p><blockquote><p>中间设备是指插入在数据终端和信号转换设备之间，完成调制前或解调后某些附加功能的辅助设备。例如集线器、交换机和无线接入点、路由器、安全解调器、通信服务器等都是中间设备。</p></blockquote><p>在我们看不到的地方，这种中间设备还有很多很多，<strong>一个网络需要经过无数个中间设备的转发才能到达终端用户。</strong></p><p>如果TCP协议需要升级，那么意味着需要这些中间设备都能支持新的特性，我们知道路由器我们可以重新换一个，但是其他的那些中间设备呢？尤其是那些比较大型的设备呢？更换起来的成本是巨大的。</p><p>而且，除了中间设备之外，操作系统也是一个重要的因素，<strong>因为TCP协议需要通过操作系统内核来实现，而操作系统的更新也是非常滞后的。</strong></p><p>所以，这种问题就被称之为”中间设备僵化”，也是导致”协议僵化”的重要原因。这也是限制着TCP协议更新的一个重要原因。</p><p>所以，近些年来，由IETF标准化的许多TCP新特性都因缺乏广泛支持而没有得到广泛的部署或使用！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>因为HTTP&#x2F;2底层是采用TCP协议实现的，虽然解决了HTTP队头阻塞的问题，但是对于TCP队头阻塞的问题却无能为力。</p><p>TCP传输过程中会把数据拆分为一个个<strong>按照顺序</strong>排列的数据包，这些数据包通过网络传输到了接收端，接收端再<strong>按照顺序</strong>将这些数据包组合成原始数据，这样就完成了数据传输。</p><p>但是如果其中的某一个数据包没有按照顺序到达，接收端会一直保持连接等待数据包返回，这时候就会阻塞后续请求。这就发生了<strong>TCP队头阻塞</strong>。</p><p>另外，TCP这种可靠传输是靠三次握手实现的，TCP三次握手的过程客户端和服务器之间需要交互三次，那么也就是说需要消耗1.5 RTT。如果是HTTPS那么消耗的RTT就更多。</p><p>而因为很多中间设备比较陈旧，更新换代成本巨大，这就导致TCP协议升级或者采用新的协议基本无法实现。</p><p>所以，HTTP&#x2F;3选择了一种新的技术方案，那就是基于UDP做改造，这种技术叫做QUIC。</p><h1 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h1><h2 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a><strong>QUIC协议</strong></h2><p>HTTP&#x2F;2之所以”被弃用”，是因为他使用的传输层协议仍然是TCP，所以HTTP&#x2F;3首要解决的问题就是绕开TCP。</p><p>那么如果研发一种新的协议，同样还是会因为受到中间设备僵化的影响，导致无法被大规模应用。所以，研发人员们想到了一种基于UDP实现的方式。</p><p>于是，Google是最先采用这种方式并付诸于实践的，他们在2013年推出了一种叫做QUIC的协议，全称是Quick UDP Internet Connections。</p><p>在设计之初，Google就希望使用这个协议来取代HTTPS&#x2F;HTTP协议，使网页传输速度加快。2015年6月，QUIC的网络草案被正式提交至互联网工程任务组。2018 年 10 月，互联网工程任务组 HTTP 及 QUIC 工作小组正式将基于 QUIC 协议的 HTTP（英语：HTTP over QUIC）重命名为HTTP&#x2F;3。</p><p><strong>所以，我们现在所提到的HTTP&#x2F;3，其实就是HTTP over QUIC，即基于QUIC协议实现的HTTP。</strong></p><p>QUIC协议有以下特点：</p><ul><li>基于UDP的传输层协议：它使用UDP端口号来识别指定机器上的特定服务器。</li><li>可靠性：虽然UDP是不可靠传输协议，但是QUIC在UDP的基础上做了些改造，使得<strong>他提供了和TCP类似的可靠性</strong>。它提供了数据包重传、拥塞控制、调整传输节奏以及其他一些TCP中存在的特性。</li><li>实现了无序、并发字节流：<strong>QUIC的单个数据流可以保证有序交付，但多个数据流之间可能乱序</strong>，这意味着单个数据流的传输是按序的，但是多个数据流中接收方收到的顺序可能与发送方的发送顺序不同！</li><li>快速握手：<strong>QUIC提供0-RTT和1-RTT的连接建立</strong></li><li>使用TLS 1.3传输层安全协议：与更早的TLS版本相比，TLS 1.3有着很多优点，但使用它的最主要原因是其握手所花费的往返次数更低，从而能降低协议的延迟。</li></ul><p>QUIC到底属于TCP&#x2F;IP协议族中的那一层呢？我们知道，QUIC是基于UDP实现的，并且是HTTP&#x2F;3的所依赖的协议，那么，按照TCP&#x2F;IP的分层来讲，他是属于传输层的，也就是和TCP、UDP属于同一层。</p><p>更加细化一点的话，因为QUIC不仅仅承担了传输层协议的职责，还具备了TLS的安全性相关能力，所以，可以通过下图来理解QUIC在HTTP&#x2F;3的实现中所处的位置。</p><h2 id="QUIC的连接建立"><a href="#QUIC的连接建立" class="headerlink" title="QUIC的连接建立"></a><strong>QUIC的连接建立</strong></h2><p>QUIC提出一种新的连接建立机制，基于这种连接接机制，实现了快速握手功能，一次QUIC连接建立可以实现使用 0-RTT 或者 1-RTT 来建立连接。</p><p>UIC在握手过程中使用Diffie-Hellman算法来保证数据交互的安全性并合并了它的加密和握手过程来减小连接建立过程中的往返次数。</p><blockquote><p>Diffie–Hellman (以下简称DH)密钥交换是一个特殊的交换密钥的方法。它是密码学领域内最早付诸实践的密钥交换方法之一。DH可以让双方在完全缺乏对方(私有)信息的前提条件下通过不安全的信道达成一个共享的密钥。此密钥用于对后续信息交换进行对称加密。</p></blockquote><p>QUIC 连接的建立整体流程大致为：QUIC在握手过程中使用Diffie-Hellman算法协商初始密钥，初始密钥依赖于服务器存储的一组配置参数，该参数会周期性的更新。初始密钥协商成功后，服务器会提供一个临时随机数，双方根据这个数再生成会话密钥。客户端和服务器会使用新生的的密钥进行数据加解密。</p><p>以上过程主要分为两个步骤：初始握手（Initial handshake）、最终（与重复）握手（Final (and repeat) handshake），分别介绍下这两个过程。</p><p><strong>初始握手（Initial handshake）</strong></p><p>在连接开始建立时，客户端会向服务端发送一个打招呼信息，（inchoate client hello (CHLO)），因为是初次建立，所以，服务端会返回一个拒绝消息（REJ），表明握手未建立或者密钥已过期。</p><p><img src="https://pic2.zhimg.com/80/v2-61ae95afd407dc8097856542c0c88cfd_720w.webp" alt="img"></p><p>但是，这个拒绝消息中还会包含更多的信息（配置参数），主要有：</p><ul><li>Server Config：一个服务器配置，包括服务器端的Diffie-Hellman算法的长期公钥（long term Diffie-Hellman public value）</li><li>Certificate Chain：用来对服务器进行认证的信任链</li><li>Signature of the Server Config：将Server Config使用信任链的叶子证书的public key加密后的签名</li><li>Source-Address Token：一个经过身份验证的加密块，包含客户端公开可见的IP地址和服务器的时间戳。</li></ul><p>在客户端接收到拒绝消息（REJ）之后，客户端会进行数据解析，签名验证等操作，之后会将必要的配置缓存下来。</p><p>同时，在接收到REJ之后，客户端会为这次连接随机产生一对自己的短期密钥（ephemeral Diffie-Hellman private value） 和 短期公钥（ephemeral Diffie-Hellman public value）。</p><p>之后，客户端会将自己刚刚产生的短期公钥打包一个Complete CHLO的消息包中，发送给服务端。这个请求的目的是将自己的短期密钥传输给服务端，方便做前向保密。</p><p>在发送了Complete CHLO消息给到服务器之后，为了减少RTT，客户端并不会等到服务器的响应，而是立刻会进行数据传输。</p><p>为了保证数据的安全性，客户端会自己的短期密钥和服务器返回的长期公钥进行运算，得到一个初始密钥（initial keys）。</p><p>有了这个初识密钥之后，客户端就可以用这个密钥，将想要传输的信息进行加密，然后把他们安全的传输给服务端了。</p><p>另外一面，接收到Complete CHLO请求的服务器，解析请求之后，就同时拥有了客户端的短期公钥和自己保存的长期密钥。这样通过运算，服务端就能得到一份和客户端一模一样的初始密钥（initial keys）。</p><p>接下来他接收到客户端使用初始密钥加密的数据之后，就可以使用这个初始密钥进行解密了，并且可以将自己的响应再通过这个初始密钥进行加密后返回给客户端。</p><p><strong>所以，从开始建立连接一直到数据传送，只消耗了初始连接连接建立的 1 RTT</strong></p><h2 id="最终（与重复）握手"><a href="#最终（与重复）握手" class="headerlink" title="最终（与重复）握手"></a><strong>最终（与重复）握手</strong></h2><p>那么，之后的数据传输就可以使用初始密钥（initial keys）加密了吗？</p><p>其实并不完全是，因为初始密钥毕竟是基于服务器的长期公钥产生的，而在公钥失效前，几乎多有的连接使用的都是同一把公钥，所以，这其实存在着一定的危险性。</p><p>所以，为了达到前向保密 (Forward Secrecy) 的安全性，客户端和服务端需要使用彼此的短期公钥和自己的短期密钥来进行运算。</p><blockquote><p>在密码学中，前向保密（英语：Forward Secrecy，FS）是密码学中通讯协议的安全属性，指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。</p></blockquote><p>那么现在问题是，客户端的短期密钥已经发送给服务端，而服务端只把自己的长期密钥给了客户端，并没有给到自己的短期密钥。</p><p>所以，服务端在收到Complete CHLO之后，会给到服务器一个server hello(SHLO)消息，这个消息会使用初始密钥（initial keys）进行加密。</p><p><img src="https://pic3.zhimg.com/80/v2-593da9ad871376e1b9c94104ec560172_720w.webp" alt="img"></p><p>这个CHLO消息包中，会包含一个服务端重新生成的短期公钥。</p><p>这样客户端和服务端就都有了对方的短期公钥（ephemeral Diffie-Hellman public value）。</p><p>这样，客户端和服务端都可以基于自己的短期密钥和对方的短期公钥做运算，产生一个仅限于本次连接使用的前向保密密钥 (Forward-Secure Key)，后续的请求发送，都基于这个密钥进行加解密就可以了。</p><p>这样，双方就完成了最终的密钥交换、连接的握手并且建立了QUIC连接。</p><p>当下一次要重新创建连接的时候，客户端会从缓存中取出自己之前缓存下来的服务器的长期公钥，并重新创建一个短期密钥，重新生成一个初始密钥，再使用这个初始密钥对想要传输的数据进行加密，向服务器发送一个Complete CHLO 请求即可。这样就达到了0 RTT的数据传输。</p><p><strong>所以，如果是有缓存的长期公钥，那么数据传输就会直接进行，准备时间是0 RTT</strong></p><p><strong>以上，通过使用Diffie-Hellman算法协商密钥，并且对加密和握手过程进行合并，大大减小连接过程的RTT ，使得基于QUIC的连接建立可以少到1 RTT甚至0 RTT。</strong></p><p><img src="https://pic4.zhimg.com/80/v2-cc893cfb594e784cc21cc82cb7330df3_720w.webp" alt="img"></p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a><strong>多路复用</strong></h2><p>基于TCP的协议实现的HTTP有一个最大的问题那就是队头阻塞问题，那么，在这方面，QUIC是如何解决这个问题的呢？</p><p>TCP传输过程中会把数据拆分为一个个按照顺序排列的数据包，这些数据包通过网络传输到了接收端，接收端再按照顺序将这些数据包组合成原始数据，这样就完成了数据传输。</p><p>但是如果其中的某一个数据包没有按照顺序到达，接收端会一直保持连接等待数据包返回，这时候就会阻塞后续请求。这就发生了TCP队头阻塞。</p><p>类似于HTTP&#x2F;2，<strong>QUIC在同一物理连接上可以有多个独立的逻辑数据流，这些数据流并行在同一个连接上传输，且多个数据流之间间的传输没有时序性要求，也不会互相影响。</strong></p><blockquote><p>数据流（Streams）在QUIC中提供了一个轻量级、有序的字节流的抽象化</p></blockquote><p>QUIC的单个数据流可以保证有序交付，但多个数据流之间可能乱序。这意味着单个数据流的传输是按序的，但是多个数据流中接收方收到的顺序可能与发送方的发送顺序不同！</p><p>也就是说同一个连接上面的多个数据流之间没有任何依赖（不要求按照顺序到达），即使某一个数据包没有达到，也只会影响自己这个数据流，并不会影响到到其他的数据流。</p><h2 id="连接迁移你"><a href="#连接迁移你" class="headerlink" title="连接迁移你"></a><strong>连接迁移你</strong></h2><p>对于TCP连接的识别，需要通过服务器和客户端过双方的ip和端口四个参数进行的。在网络切换的场景中，比如手机切换网络，那么自身的ip就会发生变化。</p><p>这就导致之前的TCP连接就会失效，就需要重新建立。这种场景对于移动端设备普及的今天来说，还是比较频繁的。</p><p>所以，在这一点上，QUIC进行了优化。</p><p><strong>QUIC协议使用特有的UUID来标记每一次连接，在网络环境发生变化的时候，只要UUID不变，就能不需要握手，继续传输数据。</strong></p><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a><strong>可靠性</strong></h2><p>TCP之所以被称之为可靠链接，不仅仅是因为他有三次握手和四次关闭的过程，还因为他做了很多诸如<strong>流量控制、数据重传、拥塞控制</strong>等可靠性保证。这</p><p>也是为什么一直以来都是以TCP作为HTTP实现的重要协议的原因。</p><p>那么，QUIC想要取代TCP，就需要在这方面也做出努力，毕竟UDP自身是不具备这些能力的。</p><p>TCP拥塞控制是TCP避免网络拥塞的算法，是互联网上主要的一个拥塞控制措施。经典的算法实现有很多，诸如TCP Tahoe 和 Reno、TCP Vegas、TCP Hybla、TCP New Reno、TCP Westwood和Westwood+以及TCP BIC 和 CUBIC等等。</p><p>QUIC协议同样实现了<strong>拥塞控制</strong>。不依赖于特定的拥塞控制算法，并且提供了一个可插拔的接口，允许用户实验。默认使用了 TCP 协议的 Cubic 拥塞控制算法。</p><p>关于<strong>流量控制</strong>，QUIC提供了基于stream和connection两种级别的流量控制，既需要对单个 Stream 进行控制，又需要针对所有 Stream 进行总体控制。</p><p>QUIC的连接级流控，用以限制 QUIC 接收端愿意分配给连接的总缓冲区，避免服务器为某个客户端分配任意大的缓存。连接级流控与流级流控的过程基本相同，但转发数据和接收数据的偏移限制是所有流中的总和。</p><h2 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a><strong>弊端</strong></h2><p>以上，我们介绍了很多QUIC的相比较于TCP的优点，可以说这种协议相比较于TCP确实要优秀一些。</p><p>因为他是基于UDP的，并没有改变UDP协议本身，只是做了一些增强，虽然可以避开中间设备僵化的问题，但是，在推广上面也不是完全没有问题的。</p><p>首先，<strong>很多企业、运营商和组织对53端口（DNS）以外的UDP流量会进行拦截或者限流</strong>，因为这些流量近来常被滥用于攻击。</p><p>特别是一些<strong>现有的UDP协议和实现易受放大攻击（amplification attack）威胁，攻击者可以控制无辜的主机向受害者投放发送大量的流量。</strong></p><p>所以，基于UDP的QUIC协议的传输可能会受到屏蔽。</p><p>另外，因为UDP一直以来定位都是不可靠连接，所以有很多中间设备对于他的支持和优化程度并不高，所以，出现丢包的可能性还是比较高的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计网 </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.1~7.2前往保定考试旅途随笔</title>
      <link href="/2024/05/02/7-1-7-2%E5%89%8D%E5%BE%80%E4%BF%9D%E5%AE%9A%E8%80%83%E8%AF%95%E6%97%85%E9%80%94%E9%9A%8F%E7%AC%94/"/>
      <url>/2024/05/02/7-1-7-2%E5%89%8D%E5%BE%80%E4%BF%9D%E5%AE%9A%E8%80%83%E8%AF%95%E6%97%85%E9%80%94%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<h1 id="7-1-7-2前往保定考试旅途随笔"><a href="#7-1-7-2前往保定考试旅途随笔" class="headerlink" title="7.1~7.2前往保定考试旅途随笔"></a>7.1~7.2前往保定考试旅途随笔</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今年三月份，我报名参加了日语N2考试。由于考生众多，我没有成功选择到山大作为考点。而且实际上我没有花太多时间来学习，大部分时间都在复习之前学过的内容。这次考试我没有太多底气，但我仍然决定去参加。毕竟N2考试的费用是550块钱，不去的话会觉得很心疼，去了也同样如此。因为七月三号还要参加高数考试，匆忙从保定赶回来再去考试简直是一场灾难。然而，在经过一番思想斗争后，我决定还是去保定参加N2考试。</p><h2 id="旅途"><a href="#旅途" class="headerlink" title="旅途"></a>旅途</h2><h4 id="出发前"><a href="#出发前" class="headerlink" title="出发前"></a>出发前</h4><p>我提前购买了下午三点的火车票。七月份正值放假季节，中考和高考也已结束，大部分大学也陆续放假了（为什么太理放假这么晚呢&#x3D; &#x3D;）。因此，火车票并不容易购买。七月一日中午十二点，我吃完了食堂里六块半的经济套餐，然后回到宿舍整理行李。现代基础设施的完善减少了旅途中的很多麻烦，所以我只带了身份证、手机、N2语法书，还有一些路上吃的食品和一瓶水。在宿舍里闲逛了一阵后，我一点半就前往公交车站准备去太原南站。</p><h4 id="公交车上"><a href="#公交车上" class="headerlink" title="公交车上"></a>公交车上</h4><p>公交车上没有以往星期天那种挤得水泄不通的情景了，大学城的学校基本上已经放假，所以公交车相当空旷。这是我第一次坐上如此空旷的902路公交车，车上只有寥寥十几个人，都是学生，看起来和我一样的很多人是前往南站或太原站的。也许还有一些人是去太原的吧。车内的宽敞空间让我感到非常舒适。公交车在一次次的停靠和行驶中，很快我就到达了南站。</p><h4 id="在南站"><a href="#在南站" class="headerlink" title="在南站"></a>在南站</h4><p>我曾在南京游玩，回程时在南站下车。然而，当时已是晚上九点，南站笼罩在漆黑之中，一片朦胧中无法分辨周围景象。疲惫的旅途使我只想尽快返回学校，无暇顾及南站的容貌。这次我有时间来欣赏南站的建筑风格了。南站前面是一个公园，有许多条蜿蜒曲折的小路，有些人为的痕迹，美感并不十分突出，反而有些多余之感。南站前方是一个广场，中国的火车站广场通常都非常宽广，以应对大量的人流。广场的宽阔程度在一定程度上反映了这个地方的客流量。与吞吐大站如北京站相比，南站和太原站的广场并不宽敞，这说明南站和太原站的客流量并不大。我背着背包走进入站口时，看到武警整齐地在广场上巡逻。广场上还设有许多警亭，显然火车站这种人流众多、人员杂乱的地方存在着安全事故的潜在风险。火车站历来都是诈骗和欺诈的热门地，当然现在随着互联网的兴起，即使在陌生地方，人们也可以通过互联网找到信息，减少了人与人之间的交流，从某种程度上遏制了这类案件的发生。在当前个人社交关系日益碎片化的情况下，人与人之间的交流越来越少，也没有很强的人际联系，因此诈骗的机会也减少了。</p><p>我通过安检进入火车站时已经是两点十几分，火车出发还有一个多小时。我闲暇之余开始观察火车站的结构以及各式各样的人们。太原火车站的候车厅有三层，第一层主要用于安检，并不是主要的候车区域，周围设有厕所和供应热水的房间。热水可以泡面，也可作为饮料，可谓旅途中的必需品。而二层则是主要的候车厅。候车厅内的IED屏幕上显示着各个列车的发车时间和检票站台，工作人员在这里维持秩序并提醒旅客检票。而三层则是各式餐厅，为人们提供丰富的饮食选择，满足他们的渴望填饱肚子的需求。这些餐厅提供各种口味的美食，无论是中餐还是西餐，都能满足不同人的口味偏好。人们可以在这里享受美食，放松身心，为接下来的旅程补充能量。餐厅区域的存在让人们在火车站内不必为饥饿而担忧，提供了方便和便利。</p><p>火车站的人流最能真实地反映当下中国的精神风貌，与网络上所呈现的不同。在车站来来往往的人们中，他们的经历最真实且具有代表性。车站里有返乡的大学生，手拎大包小包的毕业生，还有刚结束高考的学生们外出旅游放松心情。还有灰头土脸的中年男女，看起来像是工地上的工人，他们经常成群结队，互相照应，还有穿着衬衫的中年男士，看起来像是出差。他们代表着中国的新生代和老一代，是两个时代的交汇点。新生代年轻人充满朝气和活力，他们拥抱着现代科技和潮流文化，追求个人价值和自由选择。他们对未来充满希望，并努力追寻自己的梦想。而老一代人则承载着历史的沉淀和智慧的积累。他们经历过风雨，见证了国家的发展和变革。这两代人之间的交流和碰撞，代表着中国社会的多样性和变迁。他们相互启迪，互相影响，共同构建着一个更加开放、包容和进步的社会。他们的共同存在展示了中国社会的丰富性和活力，也为国家的未来发展注入了新的动力和希望。在一圈圈闲逛之中，时间到了三点二十分，开往保定的列车开始检票，我随着人流，走向检票口，正式前往去保定的旅程。</p><h4 id="火车上"><a href="#火车上" class="headerlink" title="火车上"></a>火车上</h4><p>虽然我有心理准备，但刚一上火车就被火车上人员的密集程度深深震撼了。有一种我开学坐绿皮慢火车到学校的既视感。我寻找到我的座位，自言自语地念着座位号24号……突然，面前的一位中年男人告诉我，24号在他旁边。我是25号，所以我旁边就是24号。他直直地看着前方，并没有看向我，但我并没有产生什么疑惑。他站起身让我进去坐下，我的对面坐着一位小妹妹，正在专心地看着一本小说。从外表看，她大约十六七岁的样子。把包放到脚下后我开始和那位中年男人攀谈起来。</p><p>我问他：“您是要去哪儿？”他回答说他要去北京的一家按摩店工作。一提到按摩店，我就想到通常会有一个定语——盲人。然后他告诉我，他是一位视障人士，正如我所预料的。回想起来，他的眼神和行为确实符合一个盲人的特征。我好奇地询问他是先天性还是后天性的视力问题，他回答说是后天的。他从小眼睛就不太好，但还能看清楚东西。然而，随着年龄增长，他的视力状况逐渐恶化。他的家人曾带他到各个医院，但现代医学对于他的症状无能为力。到了他三十岁时，他的视力已经恶化到只剩下光感。相比完全失明，他还能感受到光的存在。然而，他的世界一片黑暗，只能辨别一些光线差距较大的物体。但在相对昏暗或没有明暗差异的环境中，他就无法辨别了，所以他经常在楼梯和电线杆等地方碰撞。只有经过多次碰撞后，他才能记住这些物体的位置，所以他在熟悉的地方仍然能够顺利行走。</p><p>他曾经做了很长时间的销售工作，到过很多地方，如大同、河南、河北、天津、川渝地区，可以说是走遍了北方。然而，随着视力恶化，他无法继续从事销售工作。于是，他报名参加了太原的一所特殊教育学校。在学校里，他学习了许多关于人体构造和生理学等知识。接近四十岁的年龄，他在学校已经成为了学生中的长辈，受到了同学们的尊敬。这次也是在暑假的时候去打暑假工，赚一些钱。他早已成家，有一个七岁的女儿。所以这次也是打工赚钱减轻家中负担，毕竟读书可是没有收入来源的。说到他的女儿，他的脸上露出了幸福的神情，和我讲他女儿的事情，说平时虽然压力很大，但是他女儿扑到他身上叫爸爸的时候，他觉得一切压力在那一刻就好像烟消云散了。</p><p>接着他又讲了许多在学校生活的事情。通过他的讲述，我对特殊教育学校有了更多的了解。这是我第一次面对面的听残障人士讲述他们的日常生活。学校的学生都是残障人士，他们也要学习各种课程，试卷使用盲文打印。他们也为考试而担忧。除了身体上的缺陷，他们与普通学生没有太大区别。如果要说有什么不同，那就是他们的内心非常坚强。面对后天的残疾，要克服这种差距感需要很大的勇气。有很多人像史铁生一样变得暴躁和自暴自弃，但他们仍然会在自己的赛道上努力学习，发挥自己的能力，努力生活。</p><p>我们正谈得起劲时，第二站上上来一位中年妇女，坐在我们对面，加入了我们的谈话。她的丈夫在北京的工地上工作，因受了些工伤需要她去照料。他们开始交谈，我也插不上什么话，于是我拿出平板电脑和语法书，临时抱佛脚地复习N2的语法题。在他们谈论的背景声中，火车抵达了下一站——阳泉站。这时，一个年轻人上车坐在我旁边，看见我手上的书，惊讶地说：“你也是去保定考试的吗？”我回答说：“没错。”他将他的包放下，从包里拿出一份N2的真题开始做。在我一次次翻书的过程中，旁边的中年人询问我：“你在看书吗？”我哈哈一声说：“我在临时抱佛脚。”也是因此我们开始聊起现代学生们所面临的压力等话题。在这个过程中，我也开始描述我在学校看到的各种情景，向他们展示我身边的学霸们每天在学校的作息，以及我们每天学习的课程，以及对未来的规划。谈到规划时，我们又谈论起大学教育。我提到大学需要大量的资金来支持各种研究，而山西省的教育由于资金的缺陷发展受到一定的局限性，导致山西的高等教育相对落后。与之相比，南方的一些高校资金充足，能够有更好的发展。我还分享了我去南京游玩时所看到的与山西完全不同的景色，以及我在南京大学门口参观留念的经历。当提到南京大学时，坐在旁边的年轻人突然插话说：“你去的是哪个校区？”我回答说：“鼓楼校区。”他说：“那是我的学校。”我感到非常惊讶，疑惑地问道：“你是放假回家了吗？”他回答说他是今年考上南京大学研究生的，专业是动物学。我望着他，心生羡慕之情，说道：“我也想去南京大学，南京大学的人工智能学科建设得非常好，而且南京的风景优美，气候宜人，是我心中的梦想之地。”他也只是打个哈哈，继续写他的真题，没有多说什么。</p><p>就这样在火车的摇晃中，我们到达了石家庄，距离保定已经不远了。这时我们又开始讨论手机带来的关怀模式，以及如何帮助残障人士使用手机。我们进一步探讨了互联网的现状。我告诉他，现在由于技术框架的成熟，许多功能都可以模块化，以前需要大团队从头开始构建的项目，现在只需要少数几个人就能完成。尤其是人工智能的快速发展，许多公司专注于小而精的领域，例如Midjourney这样的公司，仅有八个人就能打造出市值上亿美元的企业。</p><p>然后，他告诉我他提前通过12306热线申请了残障人士服务，在下车时会有工作人员一直陪同他到地铁站。他还提到，现在国家对残障人士的关怀越来越好，包括他所就读的学校也是免费的。这时我才意识到，其实身边存在许多我们所不了解的细节和关怀。</p><p>在一句句的对话中，时间过得非常快。旁边的年轻小哥突然问我是否已经预订了酒店，我回答说已经提前预订好了。我们一起研究了考试地点和酒店，决定在下车后一起行动。最后阶段，坐在对面的小妹也加入了我们的对话。她在太原的一所学校学习材料学，但不愿透露学校的名字。</p><p>学历、学校、技术栈、实习和论文等。这些事情不仅压在我们身上，同时也疏远了人与人之间的距离。这是一个既好又坏的时代，在市场经济的大背景下，我们拥有极高的自由度，可以选择自己希望从事的职业。不再需要像父辈那样长时间积累经验，被限定在某个框框里。然而，自由也带来了竞争的激烈。好的资源是每个人都渴望得到的，稍有松懈就可能被他人夺走自己的位置。那位小妹选择沉默，应该也不例外是因为这些原因。</p><p>我们到达保定站后，整理好行李，与一路上的中年男性告别，他祝愿我们考试顺利。我笑了笑，也祝他在北京的工作一切顺利。虽然只是短短三个小时的交谈，但说实话，还是有些不舍。但旅途就是这样，相逢又相离。每个人都有自己要去完成的事情，旅途只是暂时将我们聚集在一起，之后我们都要投身于自己的事务中去。</p><h4 id="在保定"><a href="#在保定" class="headerlink" title="在保定"></a>在保定</h4><p>一下火车，我就感受到了保定扑面而来的热浪。我原本以为太原已经很热了，没想到保定更甚。出了保定站，我和小哥一起打车去他的宾馆，而我的宾馆离他并不远。在路上，我们开始讨论晚餐的问题。我提到保定有名的驴肉火烧，我们是否要去找一家店尝一尝。他也表示同意。我向司机师傅询问附近是否有好吃的驴肉火烧店，但司机告诉我们这附近没有什么好的地方，而且由于时间紧迫，我们也无法专门在保定游玩。只好放弃了这个计划，在宾馆附近找了一家卖凉皮的店解决晚餐。吃完饭后互相道别，我朝着我的酒店前进。</p><p>在路上，我观察着保定城区的建设。感觉就像回到了灵丘县一样，一片破旧的景象，建筑风格也相似。这是理所当然的，毕竟灵丘和保定是接壤的地方，而且保定也不是多富裕的地方，相似的风格是不可避免的。</p><p>到达酒店后，我打开空调遮蔽外部的酷热，然后冲了个澡。疲惫的我躺在床上玩了一会手机，向家人报平安后就入睡了。转眼第二天就到了。我在酒店订了外卖的驴肉火烧和馄饨作为午餐。那肥瘦有秩的驴肉火烧，咬下去，外皮酥脆，里面的肉与小麦一起在口中释放出美味。油脂的香气与小麦的香气交织在一起，让味蕾陶醉。吃了两个后仍然回味无穷。</p><p>午饭后，我离开房间前往考场。路上依然炎热难耐，我看到身边也有背着背包的旅客，他们与我同向同行，看来我们有着相同的目的。走了大约半小时，我们到达一个学校门口，许多背着背包的年轻人聚集在这里，显然这就是考场所在地。尽管大家年龄、性别各异，但我们都透露着一股宅气。我身穿一件IEM冠军T恤，有人认出我，向我说理赔难牛逼，我笑了笑。还有人跟我攀谈，表示紧张，我安慰他说没事放松心态，我也只是凭着N2.5的水平去考N2，放宽心。</p><h2 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h2><p>到了考试时间，大门打开，工作人员开始检查准考证和身份证。这所小学也是非常破旧的，我跟着人群找到了我的考场。炎热的天气让大家都汗流浃背，边拿东西扇风边走向考场。由于考场是在小学里，座椅都非常矮小，我作为一米八的个子坐在那里非常拘束和不便。我观察着考场上的每个人，有几个看起来像初高中生的人，也有像我一样的大学生，甚至还有一位大约四十多岁的中年妇女也在考场上。</p><p>教室里有几个电扇，所以考场上的温度并没有太难受（比太理还好一些）。在大喇叭里播放了各种提示和注意事项后，考试开始了。我拿到了一本被定成小册子一样的卷子，我迅速完成了文法和单词部分，然后开始做阅读理解。题目并不是特别难，但我之前没有做过这种类型的题，推进速度很慢。到后面越来越紧张，阅读理解的题目实在太多，而我阅读速度并不快，结果我最终没有完成，有三个选择题是瞎蒙的。</p><p>文法测验结束后是听力测验，休息了十分钟后，在一声声“天気がいいから、散歩しましょう”（因为天气好，我们去散步吧）的提示下，听力测试开始了。由于我的听力不好，基本上也是半蒙半做。考试结束后，我感到如释重负，走出考场去和小哥会和。人数非常多，而且还出现了交通拥堵，我们花了很多时间才打上车前往保定东站。他要去山东，而我急于赶往太原。在东站我们分别，各自奔向自己的旅途。</p><h2 id="归途"><a href="#归途" class="headerlink" title="归途"></a>归途</h2><p>回程的路上并没有什么特别引人注意的事情，非常平淡。只有在站台等车的时候，被红金色车厢的复兴号速度所震撼。在点外卖的时候，我多点了几个火烧，打算带回去分给朋友。为了考试，我在动车上看高数的课程和真题。高铁有空调和插座，比火车舒适许多。不知不觉中，我已经到达了太原。</p><p>在太原南站，我在地下兜兜转转找到了一个网约车停车场。南站的地下布局非常复杂，我打车后，尽管司机离我不远，我仍然不知道应该去哪里找他。只能等司机来接我。司机绕了一个大圈子才找到我，但态度非常和蔼。他询问我是否刚刚接到了订单，我回答说是的。他告诉我他家在榆次，每天七点多就不接单了，而我恰好是他最后一单。在路上，我逐渐熟悉的景色出现了，我回到了学校。司机说谢谢乘车，我也回答着小心路程。回到学校后，我把火烧分给了朋友们，然后立即投入到紧张的复习中。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>回顾这次前往保定的旅程，我不禁感慨万分。在这短短的两天里，我遇到了许多有趣而特别的人，聆听了他们的故事，分享了彼此的经历和见解。旅途中的火车车厢、公交车、考场和宾馆都成为了我们相聚和别离的见证。每一个细节都彰显着生活的多样性和奇妙之处。</p><p>通过与那位视障人士的交谈，我对特殊教育学校的理解更加深刻，也对身体有缺陷的人们充满了敬意。他们面对挑战，勇敢面对生活，为自己创造机会，证明了坚持和努力的重要性。与那位中年男性的对话让我更加珍惜现在的自由和机会，也让我深刻认识到竞争的激烈和自身的努力不可或缺。</p><p>这次旅程不仅让我体验到了不同城市的风景和氛围，也拓宽了我的眼界，让我更加明白自己的责任和使命。作为新生代的一员，我们要学习和掌握更多的知识，积极面对挑战，不断提升自己的能力和素养。同时，我们也应该尊重和关注他人的需求和感受，为社会的进步和发展贡献自己的力量。</p><p>旅途结束，我回到学校，投入到紧张的复习中。这段经历成为了我人生中的一段美好回忆，激励着我继续努力追求自己的目标。无论是旅途中的相遇还是考试中的挑战，都让我更加坚定了自己的信念和决心。我相信，只要不断努力和奋斗，我们一定能够迎接更加美好的未来。</p><p>愿每一个旅程都成为人生的瑰宝，让我们在不同的路上不断成长，收获智慧和勇气，让我们的人生更加丰富多彩。感谢这次旅程给我带来的一切，我将珍藏这段经历，继续向前迈进。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习入门</title>
      <link href="/2024/05/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
      <url>/2024/05/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="深度学习入门"><a href="#深度学习入门" class="headerlink" title="深度学习入门"></a>深度学习入门</h1><h2 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h2><p>感知机接受两个输入信号。<em>x</em>1、<em>x</em>2是输入信号，<em>y</em>是输出信号，<em>w</em>1、<em>w</em>2是权重（<em>w</em>是weight的首字母）。图中的○称为“神经元”或者“节点”。输入信号被送往神经元时，会被分别乘以固定的权重（<em>w</em>1<em>x</em>1、<em>w</em>2<em>x</em>2）。神经元会计算传送过来的信号的总和，只有当这个总和超过了某个界限值时，才会输出1。这也称为“神经元被激活”。这里将这个界限值称为阈值，用符号<em>θ</em>表示。</p><p><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/image-20231215155935558.png?raw=true" alt="image-20231215155935558"></p><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><h4 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h4><p>将输入信号总和转换为输出信号的就是激活函数<br>$$<br>a &#x3D; b + w_1 x_1 + w_2x_2<br>$$</p><h5 id><a href="#" class="headerlink" title></a></h5><p>$$<br>y &#x3D; h(a)<br>$$</p><h5 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h5><p>$$<br>h(x) &#x3D; \frac{1}{1+exp(-x)}<br>$$<br>神经网络中用sigmoid函数作为激活函数，进行信号的转换，转换后的信号被传送给下一个神经元</p><h5 id="softmax"><a href="#softmax" class="headerlink" title="softmax"></a>softmax</h5><p>分类问题中使用的softmax函数可</p><p>$$<br>y_k &#x3D; \frac{exp(a_k)}{\sum_{i&#x3D;1}^{n}exp(a_i)}<br>$$<br><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/image-20231215161514935.png?raw=true" alt="image-20231215161514935"></p><h4 id="softmax函数的特征"><a href="#softmax函数的特征" class="headerlink" title="softmax函数的特征"></a>softmax函数的特征</h4><p>softmax函数的输出是0*.<em>0到1</em>.*0之间的实数输出总和为1是softmax函数的一个重要性质。正因为有了这个性质，我们才可以把softmax函数的输出解释为“概率”。</p><h2 id="神经网络的学习"><a href="#神经网络的学习" class="headerlink" title="神经网络的学习"></a>神经网络的学习</h2><h4 id="神经网络的学习步骤"><a href="#神经网络的学习步骤" class="headerlink" title="神经网络的学习步骤"></a>神经网络的学习步骤</h4><p>步骤<strong>1</strong>（<strong>mini-batch</strong>）</p><p>从训练数据中随机选择一部分数据。</p><p>步骤<strong>2</strong>（计算梯度）</p><p>计算损失函数关于各个权重参数的梯度。</p><p>步骤<strong>3</strong>（更新参数）</p><p>将权重参数沿梯度方向进行微小的更新。</p><p>步骤<strong>4</strong>（重复）</p><p>重复步骤1、步骤2、步骤3。</p><p>神经网路的特征就是线虫数据中学习，也就是由数据去决定各个参数的值，在神经网络中各种参数的值会是成千上万的，在这种情况下，由人工去决定机器的参数是不现实的事情。</p><p>手写数字识别是深度学习的一个经典案例，每个人写出来的5都是不同的，那么怎么样才能识别一个字是不是五呢，</p><p>从零开始想出一个可以识别5的算法，不如考虑通过有效利用数据来解决这个问题。一种方案是，先从图像中提取特征量再用机器学习技术学习这些特征量的模式。机器学习的方法中，由机器从收集到的数据中找出规律性。与从零开始</p><p>想出算法相比，这种方法可以更高效地解决问题，也能减轻人的负担</p><h4 id="训练数据和测试数据"><a href="#训练数据和测试数据" class="headerlink" title="训练数据和测试数据"></a>训练数据和测试数据</h4><p>我们通过训练数据进行学习，寻找最优的参数；然后，使用测试数据评价训练得到的模型的实际能力。为了正确评价模型的泛化能力，就必须划分训练数据和测试数据。另外，训练数据也可以称为监督数据泛化能力是指处理未被观察过的数据（不包含在训练数据中的数据）的能力。获得泛化能力是机器学习的最终目标。只对某个数据集过度拟合的状态称为过拟合（over fitting）。避免过拟合也是机器学习的一个重要课题</p><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>神经网络以某个指标为线索寻找最优权重参数。神经网络的学习中所用的指标称为损失函数（loss function）。这个损失函数可以使用任意函数，但一般用均方误差和交叉熵误差等。</p><h5 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h5><p>$$<br>E &#x3D; \frac{1}{2} \sum_{k}^{}(yk-tk)^2<br>$$</p><p>$$<br>yk是表示神经网络的输出，tk表示监督数据，k表示数据的维数<br>$$</p><h5 id="交叉熵误差"><a href="#交叉熵误差" class="headerlink" title="交叉熵误差"></a>交叉熵误差</h5><p>交叉熵误差（cross entropy error）也经常被用作损失函数。交叉熵误差如下式所示。</p><p>交叉熵是用来评估当前训练得到的<strong>概率分布</strong>与真实分布的差异情况。 它刻画的是实际输出（概率）与期望输出（概率）的距离，也就是交叉熵的值越小，两个概率分布就越接近。<br>$$<br>E &#x3D;  -\sum_{k}^{}t_k\log_{}{y_k}<br>$$</p><h3 id="mini-batch学习"><a href="#mini-batch学习" class="headerlink" title="mini-batch学习"></a>mini-batch学习</h3><p>$$<br>E &#x3D; -\frac{1}{N}\sum_{n}^{} \sum_{k}^{}t_{nk}\log_{}{y_{nk}}<br>$$</p><p>假设数据有<em>N</em>个，N表示第<em>n</em>个数据的第<em>k</em>个元素的值（$ $是神经网络的输出，tnk是监督数据）</p><h3 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h3><p>$$<br>f(x_0,x_1) &#x3D; x_0^2+x_1^2<br>$$</p><p>这个函数有两个参数式（4*.<em>6）有两个变量，所以有必要区分对哪个变量求导数，即对</em>x<em>0和</em>x*1两个变量中的哪一个求导数。另外，我们把这里讨论的有多个变量的函数的导数称为偏导数。用数学式表示的话，可以写成 $\frac{\partial f}{\partial x_0} $、$\frac{\partial y}{\partial x_1} $</p><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><p>像 $\frac{\partial f}{\partial x_0} $、$\frac{\partial y}{\partial x_1} $​这样的由全部变量的偏导数汇总而成的向量称为梯度（gradient）。梯度指示的方向是各点处的函数值减小最多的方向 。</p><h3 id="梯度法"><a href="#梯度法" class="headerlink" title="梯度法"></a>梯度法</h3><p>深度学习需要找到最优参数（权重与偏置），但是损失函数通常非常的繁杂，无法通过人工计算的方式来做优化，于是我们使用梯度下降的方式来减少损失函数</p><p>但是梯度下降的方式可能不会达到一个全局最优解 而是陷入一个局部的最优解。虽然梯度的方向并不一定指向最小值，但沿着它的方向能够最大限度地减小函数的值。</p><p>此时梯度法就派上用场了。在梯度法中，函数的取值从当前位置沿着梯度方向前进一定距离，然后在新的地方重新求梯度，再沿着新梯度方向前进，如此反复，不断地沿梯度方向前进。像这样，通过不断地沿梯度方向前进，逐渐减小函数值的过程就是梯度法（gradient method）。梯度法是解决机器学习中最优化问题的常用方法，特别是在神经网络的学习中经常被使用。<br>$$<br>x_0 &#x3D;x_0-\eta\frac{\partial f}{\partial x_1}<br>$$</p><p>$$<br>x_1 &#x3D;x_1-\eta\frac{\partial f}{\partial x_1}<br>$$</p><p><em>η</em>表示更新量，在神经网络的学习中，称为学习率（learning rate）。学习率决定在一次学习中，应该学习多少，以及在多大程度上更新参数。</p><h3 id="随机梯度下降法（stochastic-gradient-descent）"><a href="#随机梯度下降法（stochastic-gradient-descent）" class="headerlink" title="随机梯度下降法（stochastic gradient descent）"></a>随机梯度下降法（stochastic gradient descent）</h3><p>“随机”指的是“随机选择的”的意思，因此，随机梯度下降法是“对随机选择的数据进行的梯度下降法</p><h2 id="误差反向传播法"><a href="#误差反向传播法" class="headerlink" title="误差反向传播法"></a>误差反向传播法</h2><h3 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h3><p>如果某个函数由复合函数表示，则该复合函数的导数可以用构成复合函数的各个函数的导数的乘积表示(其实就是从里向外一层一层算)</p><h4 id="反向传播法"><a href="#反向传播法" class="headerlink" title="反向传播法"></a>反向传播法</h4><p>相反与正向传播 反向传播是乘以对应节点的导数</p><p>以$z &#x3D; x + y$为例其导数分别为<br>$$<br>\frac{\partial z}{\partial x}&#x3D;1<br>$$</p><p>$$<br>\frac{\partial z}{\partial y}&#x3D;1<br>$$</p><p>因此加法节点的反向传播只是将输入信号输出到下一个节点</p><h5 id="乘法节点的反向传播"><a href="#乘法节点的反向传播" class="headerlink" title="乘法节点的反向传播"></a>乘法节点的反向传播</h5><p>以$z&#x3D;xy$为例<br>$$<br>\frac{\partial z}{\partial x}&#x3D;y<br>$$</p><p>$$<br>\frac{\partial z}{\partial y}&#x3D;x<br>$$</p><p>乘法的反向传播会将上游的值乘以正向传播时的输入信号的“翻转值”后传递给下游。</p><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><p>确认数值微分求出的梯度结果和误差反向传播法求出的结果是否一致（严格地讲，是非常相近）的操作称为梯度确认（gradient check）</p><h2 id="与学习相关的技巧"><a href="#与学习相关的技巧" class="headerlink" title="与学习相关的技巧"></a>与学习相关的技巧</h2><h4 id="参数的更新"><a href="#参数的更新" class="headerlink" title="参数的更新"></a>参数的更新</h4><p>神经网络的学习的目的是找到使损失函数的值尽可能小的参数。这是寻找最优参数的问题，解决这个问题的过程称为最优化（optimization）。</p><h4 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h4><h4 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h4><p>和前面的SGD一样，<strong>W</strong>表示要更新的权重参数， 表示损失函数关于<strong>W</strong>的梯度，<em>η</em>表示学习率。这里新出现了一个变量<strong>v</strong>，对应物理上的速度。</p><h4 id="AdaGrad"><a href="#AdaGrad" class="headerlink" title="AdaGrad"></a>AdaGrad</h4><p>学习率作为一种超参数十分重要在关于学习率的有效技巧中，有一种被称为学习率衰减（learning rate decay）的方法，即随着学习的进行，使学习率逐渐减小。</p><p>AdaGrad会为参数的每个元素适当地调整学习率，</p><p>AdaGrad会记录过去所有梯度的平方和。因此，学习越深入，更新的幅度就越小。</p><h4 id="权重的初始值"><a href="#权重的初始值" class="headerlink" title="权重的初始值"></a>权重的初始值</h4><p>在神经网络的学习中，权重的初始值特别重要。设定什么样的权重初始值，经常关系到神经网络的学习能否成功。</p><p>如果想减小权重的值，一开始就将初始值设为较小的值才是正途</p><p>数据分布造成反向传播中梯度的值不断变小，最后消失。这个问题称为梯度消失（gradient vanishing）</p><p>Xavier初始值</p><p>如果前一层的节点数为<em>n</em>，则初始值使用标准差为 $\frac{1}{\sqrt{n}}$的分布</p><h5 id="ReLU的权重初始值"><a href="#ReLU的权重初始值" class="headerlink" title="ReLU的权重初始值"></a>ReLU的权重初始值</h5><p>Xavier初始值是以激活函数是线性函数为前提而推导出来的。因为sigmoid函数和tanh函数左右对称，且中央附近可以视作线性函数，所以适合使用Xavier初始值。但当激活函数使用ReLU时，一般推荐使用ReLU专用的初始值，也就是Kaiming He等人推荐的初始值，也称为“He初始值。</p><p>当前一层的节点数为<em>n</em>时，He初始值使用标准差为 $\sqrt\frac{2}{n}$的高斯分布。当Xavier初始值是$\sqrt\frac{1}{n}$时，（直观上）可以解释为，因为ReLU的负值区域的值为0，为了使它更有广度，所以需要2倍的系数</p><h4 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h4><p>机器学习的问题中，过拟合是一个很常见的问题。</p><p>发生过拟合的原因，主要有以下两个。</p><p>• 模型拥有大量参数、表现力强。</p><p>• 训练数据少</p><h4 id="权值衰减"><a href="#权值衰减" class="headerlink" title="权值衰减"></a>权值衰减</h4><p>权值衰减是一直以来经常被使用的一种抑制过拟合的方法。该方法通过在学习的过程中对大的权重进行惩罚，来抑制过拟合。</p><h4 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h4><p>如果网络的模型变得很复杂，只用权值衰减就难以应对了。在这种情况下，我们经常会使用Dropout方法</p><p>Dropout是一种在学习的过程中随机删除神经元的方法。训练时，随机选出隐藏层的神经元，然后将其删除。被删除的神经元不再进行信号的传递，测试时，虽然会传递所有的神经元信号，但是对于各个神经元的输出，要乘上训练时的删除比例后再输出</p><h4 id="超参数的验证"><a href="#超参数的验证" class="headerlink" title="超参数的验证"></a>超参数的验证</h4><p>超参数是指，比如各层的神经元数量、batch大小、参数更新时的学习率或权值衰减等。如果这些超参数没有设置合适的值，模型的性能就会很差。</p><h5 id="验证数据"><a href="#验证数据" class="headerlink" title="验证数据"></a>验证数据</h5><p>之前使用的数据集分成了训练数据和测试数据，训练数据用于学习，测试数据用于评估泛化能力。由此，就可以评估是否只过度拟合了训练数据(是否发生了过拟合），以及泛化能力如何等。</p><p>如果使用测试数据调整超参数，超参数的值会对测试数据发生过拟合。</p><p>所以调整超参数时，必须使用超参数专用的确认数据。用于调整超参数的数据，一般称为验证数据（validation data）。我</p><h4 id="超参数的最优化"><a href="#超参数的最优化" class="headerlink" title="超参数的最优化"></a>超参数的最优化</h4><p>进行超参数的最优化时，逐渐缩小超参数的“好值”指一开始先大致设定一个范围，从这个范围中随机选出一个超参数（采样），用这个采样到的值进行识别精度的评估；然后，多次重复该操作，观察识别精度的结果，根据这个结果缩小超参数的“好值”的范围。通过重复这一操作，就可以逐渐确定超参数的合适范围。</p><h6 id="最优化的步骤："><a href="#最优化的步骤：" class="headerlink" title="最优化的步骤："></a>最优化的步骤：</h6><ol><li>设定超参数的范围。</li><li>从设定的超参数范围中随机采样。</li><li>使用步骤1中采样到的超参数的值进行学习，通过验证数据评估识别精度（但是要将epoch设置得很小）。</li><li>重复步骤1和步骤2（100次等），根据它们的识别精度的结果，缩小超参数的范围。</li></ol><h2 id="卷积神经网络（Convolutional-Neural-Network，CNN）"><a href="#卷积神经网络（Convolutional-Neural-Network，CNN）" class="headerlink" title="卷积神经网络（Convolutional Neural Network，CNN）"></a>卷积神经网络（Convolutional Neural Network，<strong>CNN</strong>）</h2><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><h5 id="全连接层存在的问题"><a href="#全连接层存在的问题" class="headerlink" title="全连接层存在的问题"></a>全连接层存在的问题</h5><p>相邻层的所有神经元之间都有连接，这称为全连接（fully-connected）。</p><p>全连接层存在数据的形状被忽视的问题</p><p>比如，输入数据是图像时，图像通常是高、长、通道方向上的3维形状。但是，向全连接层输入时，需要将3维数据拉平为1维数据。</p><p>图像是3维形状，这个形状中应该含有重要的空间信息。比如，空间上邻近的像素为相似的值、RBG的各个通道之间分别有密切的关联性、相距较远的像素之间没有什么关联等，</p><p>而卷积层可以保持形状不变。当输入数据是图像时，卷积层会以3维数据的形式接收输入数据，并同样以3维数据的形式输出至下一层。因此，在CNN中，可以（有可能）正确理解图像等具有形状的数据</p><p>CNN 中，有时将卷积层的输入输出数据称为<strong>特征图（feature map）</strong>。其中，卷积层的输入数据称为<strong>输入特征图（input feature map）</strong>，输出数据称为<strong>输出特征图（output feature map）</strong>。</p><h5 id="卷积运算"><a href="#卷积运算" class="headerlink" title="卷积运算"></a>卷积运算</h5><p>对于输入数据，卷积运算以一定间隔滑动滤波器的窗口并应用。这里所说的窗口是指图7-4中灰色的3 <em>×</em> 3的部分。如图7-4所示，将各个位置上卷积核的元素和输入的对应元素相乘，然后再求和（有时将这个计算称为乘积累加运算）。</p><h5 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h5><p>在进行卷积层的处理之前，有时要向输入数据的周围填入固定的数据（比如0等），这称为填充（padding）</p><p><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/image-20231227170322471.png?raw=true" alt="image-20231227170322471"></p><p>卷积运算的填充处理：向输入数据的周围填入<strong>0</strong>（图中用虚线表示填充，并省略了填充的内容“<strong>0</strong>”）</p><h5 id="步幅"><a href="#步幅" class="headerlink" title="步幅"></a>步幅</h5><p>应用滤波器的位置间隔称为步幅（stride）。</p><p><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/image-20231227170408400.png?raw=true" alt="image-20231227170408400"></p><p>这里，假设输入大小为(<em>H, W</em>)，滤波器大小为(<em>FH, FW</em>)，输出大小为(<em>OH, OW</em>)，填充为<em>P</em>，步幅为<em>S</em>。此时，输出大小可通过式进行计算。<br>$$<br>OH &#x3D; \frac{H+2P-FH}{S}+1<br>$$</p><p>$$<br>OW &#x3D; \frac{W+2P-FW}{S}+1<br>$$</p><p>其实就是拿这个公式算长和宽</p><h4 id="3维数据的卷积运算"><a href="#3维数据的卷积运算" class="headerlink" title="3维数据的卷积运算"></a>3维数据的卷积运算</h4><p>通道方向上有多个特征图时，会按通道</p><p>进行输入数据和滤波器的卷积运算，并将结果相加，从而得到输出。</p><p>在3维数据的卷积运算中，输入数据和滤波器的通道要设为相同的值。</p><p>有多高的数据就要有多少个卷积核</p><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>我们希望卷积运算也同样对应批处理。为此，需要将在各层间传递的数</p><p>据保存为4维数据。具体地讲，就是按(batch_num*,* channel*,* height*,* width)</p><p>的顺序保存数据。</p><h4 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h4><p>池化是缩小高、长方向上的空间的运算。</p><p><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/image-20231227214606929.png?raw=true" alt="image-20231227214606929"></p><p>就是从多的数据变成少的数据</p><p>除了Max池化之外，还有Average池化等，Average池化则是计算目标区域的平均值，在图像识别领域，主要使用Max池化。</p><h5 id="池化层的特征"><a href="#池化层的特征" class="headerlink" title="池化层的特征"></a><strong>池化层的特征</strong></h5><p>没有要学习的参数池化层和卷积层不同，没有要学习的参数。池化只是从目标区域中取最大值（或者平均值），所以不存在要学习的参数。</p><p>通道数不发生变化</p><p>经过池化运算，输入数据和输出数据的通道数不会发生变化。</p><p>计算是按通道独立进行的对微小的位置变化具有鲁棒性（健壮）</p><p>输入数据发生微小偏差时，池化仍会返回相同的结果。因此，池化对输入数据的微小偏差具有鲁棒性。比如，3 <em>×</em> 3的池化的情况下，如图池化会吸收输入数据的偏差（根据数据的不同，结果有可能不一致）</p><ul><li>CNN在此前的全连接层的网络中新增了卷积层和池化层。</li><li>使用im2col函数可以简单、高效地实现卷积层和池化层。</li></ul><h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><p>深度学习是加深了层的深度神经网络。</p><h2 id="Data-Augmentation"><a href="#Data-Augmentation" class="headerlink" title="Data Augmentation"></a>Data Augmentation</h2><p>Data Augmentation是基于算法“人为地”扩充输入图像（训练图像），比如说对于输入图像，通过施加旋转、垂直或水平方向上的移动等微小变化，增加图像的数量。这在数据集的图像数量有限时尤其有效。Data Augmentation还可以通过其他各种方法扩充图像，比如裁剪图像的“crop处理”、将图像左右翻转的“flip处理”A 等。对于一般的图像，施加亮度等外观上的变化、放大缩小等尺度上的变化也是有效的。不管怎样，通过Data Augmentation巧妙地增加训练图像，就可以提高深度学习的识别精度。虽然这个看上去只是一个简单的技巧，不过经常会有很好的效果。</p><h2 id="加深层的好处"><a href="#加深层的好处" class="headerlink" title="加深层的好处"></a>加深层的好处</h2><p>可以减少网络的参数数量。加深了层的网络可以用更少的参数达到同等水平（或者更强）的表现力。一次5 <em>×</em> 5的卷积运算的区域可以由两次3 <em>×</em> 3的卷积运算抵充。并且，相对于前者的参数数量25（5 <em>×</em> 5），后者一共是18（2 <em>×</em> 3 <em>×</em> 3）</p><p>叠加小型滤波器来加深网络的好处是可以减少参数的数量，扩大感受野（receptive field，给神经元施加变化的某个局部空间区域）。并且，通过叠加层，将 ReLU等激活函数夹在卷积层的中间，进一步提高了网络的表现力。这是因为向网络添加了基于激活函数的“非线性”表现力，通过非线性函数的叠加，可以表现更加复杂的东西。</p><p>加深层的另一个好处就是使学习更加高效。与没有加深层的网络相比，通过加深层，可以减少学习数据，从而高效地进行学习。</p><p>实践中经常会灵活应用使用ImageNet这个巨大的数据集学习到的权重数据，这称为迁移学习，将学习完的权重（的一部分）复制到其他神经网络，进行再学习（fine tuning）。比如，准备一个和 VGG相同结构的网络，把学习完的权重作为初始值，以新数据集为对象，进行再学习。迁移学习在手头数据集较少时非常有效。</p><h3 id="基于GPU的高速化"><a href="#基于GPU的高速化" class="headerlink" title="基于GPU的高速化"></a>基于GPU的高速化</h3><p><strong>GPU</strong>计算的目标就是将这种压倒性的计算能力用于各种用途。所谓GPU计算，是指基于GPU进行通用的数值计算的操作。</p><p>深度学习中需要进行大量的乘积累加运算（或者大型矩阵的乘积运算）。这种大量的并行运算正是GPU所擅长的（反过来说，CPU比较擅长连续的、复杂的计算）。因此，与使用单个CPU相比，使用GPU进行深度学习的运算可以达到惊人的高速化。深度学习的框架中使用了NVIDIA提供的CUDA这个面向GPU计算的综合开发环境。</p><h3 id="分布式学习"><a href="#分布式学习" class="headerlink" title="分布式学习"></a>分布式学习</h3><p>虽然通过GPU可以实现深度学习运算的高速化，但即便如此，当网络较深时，学习还是需要几天到几周的时间。将深度学习的学习过程扩展开来的想法（也就是分布式学习）就变得重要起来。为了进一步提高深度学习所需的计算的速度，可以考虑在多个GPU或者多台机器上进行分布式计算。现在的深度学习框架中，出现了好几个支持多GPU或者多机器的分布式学习的框架。其中，Google的TensorFlow、微软的CNTK（Computational Network Toolki）在开发过程中高度重视分布式学习。以大型数据中心的低延迟·高吞吐网络作为支撑，基于这些框架的分布式学习呈现出惊人的效果</p><p>在使用CNN进行物体检测的方法中，有一个叫作R-CNN的有名的方法。</p><p><img src="https://github.com/sizhouLiu/sizhouLiu.github.io/blob/master/2024/05/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/image-20231227223441101.png?raw=true" alt="image-20231227223441101"></p><h2 id="Deep-Q-Network（强化学习）"><a href="#Deep-Q-Network（强化学习）" class="headerlink" title="Deep Q-Network（强化学习）"></a>Deep Q-Network（强化学习）</h2><p>让计算机也在摸索试验的过程中自主学习，这称为强化学习（reinforcement learning）,通过计算机与环境的交互不断调整参数.在使用了深度学习的强化学习方法中，有一个叫作Deep Q-Network通称<strong>DQN</strong>。该方法基于被称为Q学习的强化学习算法。</p><p>在Q学习中，为了确定最合适的行动，需要确定一个被称为最优行动价值函数的函数。</p><p>不需要提供游戏的状态只需要输入图像就能够让计算机学习。这是强化学习的最大特点</p>]]></content>
      
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
